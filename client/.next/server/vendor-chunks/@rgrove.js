"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@rgrove";
exports.ids = ["vendor-chunks/@rgrove"];
exports.modules = {

/***/ "(ssr)/./node_modules/@rgrove/parse-xml/src/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@rgrove/parse-xml/src/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Parser = __webpack_require__(/*! ./lib/Parser */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/Parser.js\");\nconst XmlCdata = __webpack_require__(/*! ./lib/XmlCdata */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlCdata.js\");\nconst XmlComment = __webpack_require__(/*! ./lib/XmlComment */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlComment.js\");\nconst XmlDocument = __webpack_require__(/*! ./lib/XmlDocument */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlDocument.js\");\nconst XmlElement = __webpack_require__(/*! ./lib/XmlElement */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlElement.js\");\nconst XmlNode = __webpack_require__(/*! ./lib/XmlNode */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlNode.js\");\nconst XmlProcessingInstruction = __webpack_require__(/*! ./lib/XmlProcessingInstruction */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlProcessingInstruction.js\");\nconst XmlText = __webpack_require__(/*! ./lib/XmlText */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlText.js\");\n/**\nParses the given XML string and returns an `XmlDocument` instance representing\nthe document tree.\n\n@example\n\n  const parseXml = require('@rgrove/parse-xml');\n  let doc = parseXml('<kittens fuzzy=\"yes\">I like fuzzy kittens.</kittens>');\n\n@param {string} xml\n  XML string to parse.\n\n@param {object} [options]\n  Parsing options.\n\n  @param {boolean} [options.ignoreUndefinedEntities=false]\n    When `true`, an undefined named entity (like \"&bogus;\") will be left in the\n    output as is instead of causing a parse error.\n\n  @param {boolean} [options.preserveCdata=false]\n    When `true`, CDATA sections will be preserved in the document as `XmlCdata`\n    nodes. Otherwise CDATA sections will be represented as `XmlText` nodes,\n    which keeps the node tree simpler and easier to work with.\n\n  @param {boolean} [options.preserveComments=false]\n    When `true`, comments will be preserved in the document as `XmlComment`\n    nodes. Otherwise comments will not be included in the node tree.\n\n  @param {(entity: string) => string?} [options.resolveUndefinedEntity]\n    When an undefined named entity is encountered, this function will be called\n    with the entity as its only argument. It should return a string value with\n    which to replace the entity, or `null` or `undefined` to treat the entity as\n    undefined (which may result in a parse error depending on the value of\n    `ignoreUndefinedEntities`).\n\n  @param {boolean} [options.sortAttributes=false]\n    When `true`, attributes in an element's `attributes` object will be sorted\n    in alphanumeric order by name. Otherwise they'll retain their original order\n    as found in the XML.\n\n@returns {XmlDocument}\n@public\n*/ function parseXml(xml, options) {\n    return new Parser(xml, options).document;\n}\nparseXml.XmlCdata = XmlCdata;\nparseXml.XmlComment = XmlComment;\nparseXml.XmlDocument = XmlDocument;\nparseXml.XmlElement = XmlElement;\nparseXml.XmlNode = XmlNode;\nparseXml.XmlProcessingInstruction = XmlProcessingInstruction;\nparseXml.XmlText = XmlText;\nmodule.exports = parseXml;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJncm92ZS9wYXJzZS14bWwvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDdkIsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUM7QUFDekIsTUFBTUUsYUFBYUYsbUJBQU9BLENBQUM7QUFDM0IsTUFBTUcsY0FBY0gsbUJBQU9BLENBQUM7QUFDNUIsTUFBTUksYUFBYUosbUJBQU9BLENBQUM7QUFDM0IsTUFBTUssVUFBVUwsbUJBQU9BLENBQUM7QUFDeEIsTUFBTU0sMkJBQTJCTixtQkFBT0EsQ0FBQztBQUN6QyxNQUFNTyxVQUFVUCxtQkFBT0EsQ0FBQztBQUV4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMENBLEdBQ0EsU0FBU1EsU0FBU0MsR0FBRyxFQUFFQyxPQUFPO0lBQzVCLE9BQU8sSUFBS1gsT0FBT1UsS0FBS0MsU0FBVUMsUUFBUTtBQUM1QztBQUVBSCxTQUFTUCxRQUFRLEdBQUdBO0FBQ3BCTyxTQUFTTixVQUFVLEdBQUdBO0FBQ3RCTSxTQUFTTCxXQUFXLEdBQUdBO0FBQ3ZCSyxTQUFTSixVQUFVLEdBQUdBO0FBQ3RCSSxTQUFTSCxPQUFPLEdBQUdBO0FBQ25CRyxTQUFTRix3QkFBd0IsR0FBR0E7QUFDcENFLFNBQVNELE9BQU8sR0FBR0E7QUFFbkJLLE9BQU9DLE9BQU8sR0FBR0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aWN0YWN0b2UvLi9ub2RlX21vZHVsZXMvQHJncm92ZS9wYXJzZS14bWwvc3JjL2luZGV4LmpzPzUwODUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBQYXJzZXIgPSByZXF1aXJlKCcuL2xpYi9QYXJzZXInKTtcbmNvbnN0IFhtbENkYXRhID0gcmVxdWlyZSgnLi9saWIvWG1sQ2RhdGEnKTtcbmNvbnN0IFhtbENvbW1lbnQgPSByZXF1aXJlKCcuL2xpYi9YbWxDb21tZW50Jyk7XG5jb25zdCBYbWxEb2N1bWVudCA9IHJlcXVpcmUoJy4vbGliL1htbERvY3VtZW50Jyk7XG5jb25zdCBYbWxFbGVtZW50ID0gcmVxdWlyZSgnLi9saWIvWG1sRWxlbWVudCcpO1xuY29uc3QgWG1sTm9kZSA9IHJlcXVpcmUoJy4vbGliL1htbE5vZGUnKTtcbmNvbnN0IFhtbFByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IHJlcXVpcmUoJy4vbGliL1htbFByb2Nlc3NpbmdJbnN0cnVjdGlvbicpO1xuY29uc3QgWG1sVGV4dCA9IHJlcXVpcmUoJy4vbGliL1htbFRleHQnKTtcblxuLyoqXG5QYXJzZXMgdGhlIGdpdmVuIFhNTCBzdHJpbmcgYW5kIHJldHVybnMgYW4gYFhtbERvY3VtZW50YCBpbnN0YW5jZSByZXByZXNlbnRpbmdcbnRoZSBkb2N1bWVudCB0cmVlLlxuXG5AZXhhbXBsZVxuXG4gIGNvbnN0IHBhcnNlWG1sID0gcmVxdWlyZSgnQHJncm92ZS9wYXJzZS14bWwnKTtcbiAgbGV0IGRvYyA9IHBhcnNlWG1sKCc8a2l0dGVucyBmdXp6eT1cInllc1wiPkkgbGlrZSBmdXp6eSBraXR0ZW5zLjwva2l0dGVucz4nKTtcblxuQHBhcmFtIHtzdHJpbmd9IHhtbFxuICBYTUwgc3RyaW5nIHRvIHBhcnNlLlxuXG5AcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gIFBhcnNpbmcgb3B0aW9ucy5cblxuICBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlnbm9yZVVuZGVmaW5lZEVudGl0aWVzPWZhbHNlXVxuICAgIFdoZW4gYHRydWVgLCBhbiB1bmRlZmluZWQgbmFtZWQgZW50aXR5IChsaWtlIFwiJmJvZ3VzO1wiKSB3aWxsIGJlIGxlZnQgaW4gdGhlXG4gICAgb3V0cHV0IGFzIGlzIGluc3RlYWQgb2YgY2F1c2luZyBhIHBhcnNlIGVycm9yLlxuXG4gIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucHJlc2VydmVDZGF0YT1mYWxzZV1cbiAgICBXaGVuIGB0cnVlYCwgQ0RBVEEgc2VjdGlvbnMgd2lsbCBiZSBwcmVzZXJ2ZWQgaW4gdGhlIGRvY3VtZW50IGFzIGBYbWxDZGF0YWBcbiAgICBub2Rlcy4gT3RoZXJ3aXNlIENEQVRBIHNlY3Rpb25zIHdpbGwgYmUgcmVwcmVzZW50ZWQgYXMgYFhtbFRleHRgIG5vZGVzLFxuICAgIHdoaWNoIGtlZXBzIHRoZSBub2RlIHRyZWUgc2ltcGxlciBhbmQgZWFzaWVyIHRvIHdvcmsgd2l0aC5cblxuICBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnByZXNlcnZlQ29tbWVudHM9ZmFsc2VdXG4gICAgV2hlbiBgdHJ1ZWAsIGNvbW1lbnRzIHdpbGwgYmUgcHJlc2VydmVkIGluIHRoZSBkb2N1bWVudCBhcyBgWG1sQ29tbWVudGBcbiAgICBub2Rlcy4gT3RoZXJ3aXNlIGNvbW1lbnRzIHdpbGwgbm90IGJlIGluY2x1ZGVkIGluIHRoZSBub2RlIHRyZWUuXG5cbiAgQHBhcmFtIHsoZW50aXR5OiBzdHJpbmcpID0+IHN0cmluZz99IFtvcHRpb25zLnJlc29sdmVVbmRlZmluZWRFbnRpdHldXG4gICAgV2hlbiBhbiB1bmRlZmluZWQgbmFtZWQgZW50aXR5IGlzIGVuY291bnRlcmVkLCB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkXG4gICAgd2l0aCB0aGUgZW50aXR5IGFzIGl0cyBvbmx5IGFyZ3VtZW50LiBJdCBzaG91bGQgcmV0dXJuIGEgc3RyaW5nIHZhbHVlIHdpdGhcbiAgICB3aGljaCB0byByZXBsYWNlIHRoZSBlbnRpdHksIG9yIGBudWxsYCBvciBgdW5kZWZpbmVkYCB0byB0cmVhdCB0aGUgZW50aXR5IGFzXG4gICAgdW5kZWZpbmVkICh3aGljaCBtYXkgcmVzdWx0IGluIGEgcGFyc2UgZXJyb3IgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZlxuICAgIGBpZ25vcmVVbmRlZmluZWRFbnRpdGllc2ApLlxuXG4gIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc29ydEF0dHJpYnV0ZXM9ZmFsc2VdXG4gICAgV2hlbiBgdHJ1ZWAsIGF0dHJpYnV0ZXMgaW4gYW4gZWxlbWVudCdzIGBhdHRyaWJ1dGVzYCBvYmplY3Qgd2lsbCBiZSBzb3J0ZWRcbiAgICBpbiBhbHBoYW51bWVyaWMgb3JkZXIgYnkgbmFtZS4gT3RoZXJ3aXNlIHRoZXknbGwgcmV0YWluIHRoZWlyIG9yaWdpbmFsIG9yZGVyXG4gICAgYXMgZm91bmQgaW4gdGhlIFhNTC5cblxuQHJldHVybnMge1htbERvY3VtZW50fVxuQHB1YmxpY1xuKi9cbmZ1bmN0aW9uIHBhcnNlWG1sKHhtbCwgb3B0aW9ucykge1xuICByZXR1cm4gKG5ldyBQYXJzZXIoeG1sLCBvcHRpb25zKSkuZG9jdW1lbnQ7XG59XG5cbnBhcnNlWG1sLlhtbENkYXRhID0gWG1sQ2RhdGE7XG5wYXJzZVhtbC5YbWxDb21tZW50ID0gWG1sQ29tbWVudDtcbnBhcnNlWG1sLlhtbERvY3VtZW50ID0gWG1sRG9jdW1lbnQ7XG5wYXJzZVhtbC5YbWxFbGVtZW50ID0gWG1sRWxlbWVudDtcbnBhcnNlWG1sLlhtbE5vZGUgPSBYbWxOb2RlO1xucGFyc2VYbWwuWG1sUHJvY2Vzc2luZ0luc3RydWN0aW9uID0gWG1sUHJvY2Vzc2luZ0luc3RydWN0aW9uO1xucGFyc2VYbWwuWG1sVGV4dCA9IFhtbFRleHQ7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VYbWw7XG4iXSwibmFtZXMiOlsiUGFyc2VyIiwicmVxdWlyZSIsIlhtbENkYXRhIiwiWG1sQ29tbWVudCIsIlhtbERvY3VtZW50IiwiWG1sRWxlbWVudCIsIlhtbE5vZGUiLCJYbWxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24iLCJYbWxUZXh0IiwicGFyc2VYbWwiLCJ4bWwiLCJvcHRpb25zIiwiZG9jdW1lbnQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@rgrove/parse-xml/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@rgrove/parse-xml/src/lib/Parser.js":
/*!**********************************************************!*\
  !*** ./node_modules/@rgrove/parse-xml/src/lib/Parser.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst StringScanner = __webpack_require__(/*! ./StringScanner */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/StringScanner.js\");\nconst syntax = __webpack_require__(/*! ./syntax */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/syntax.js\");\nconst XmlCdata = __webpack_require__(/*! ./XmlCdata */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlCdata.js\");\nconst XmlComment = __webpack_require__(/*! ./XmlComment */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlComment.js\");\nconst XmlDocument = __webpack_require__(/*! ./XmlDocument */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlDocument.js\");\nconst XmlElement = __webpack_require__(/*! ./XmlElement */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlElement.js\");\nconst XmlProcessingInstruction = __webpack_require__(/*! ./XmlProcessingInstruction */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlProcessingInstruction.js\");\nconst XmlText = __webpack_require__(/*! ./XmlText */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlText.js\");\nconst emptyString = \"\";\n/**\nParses an XML string into an `XmlDocument`.\n\n@private\n*/ class Parser {\n    /**\n  @param {string} xml\n    XML string to parse.\n\n  @param {object} [options]\n    Parsing options.\n\n    @param {boolean} [options.ignoreUndefinedEntities=false]\n    @param {boolean} [options.preserveCdata=false]\n    @param {boolean} [options.preserveComments=false]\n    @param {(entity: string) => string?} [options.resolveUndefinedEntity]\n    @param {boolean} [options.sortAttributes=false]\n  */ constructor(xml, options = {}){\n        /** @type {XmlDocument} */ this.document = new XmlDocument();\n        /** @type {XmlDocument|XmlElement} */ this.currentNode = this.document;\n        this.options = options;\n        this.scanner = new StringScanner(normalizeXmlString(xml));\n        this.consumeProlog();\n        if (!this.consumeElement()) {\n            this.error(\"Root element is missing or invalid\");\n        }\n        while(this.consumeMisc()){} // eslint-disable-line no-empty\n        if (!this.scanner.isEnd) {\n            this.error(\"Extra content at the end of the document\");\n        }\n    }\n    /**\n  Adds the given `XmlNode` as a child of `this.currentNode`.\n\n  @param {XmlNode} node\n  */ addNode(node) {\n        node.parent = this.currentNode;\n        // @ts-ignore\n        this.currentNode.children.push(node);\n    }\n    /**\n  Adds the given _text_ to the document, either by appending it to a preceding\n  `XmlText` node (if possible) or by creating a new `XmlText` node.\n\n  @param {string} text\n  */ addText(text) {\n        let { children } = this.currentNode;\n        if (children.length > 0) {\n            let prevNode = children[children.length - 1];\n            if (prevNode instanceof XmlText) {\n                // The previous node is a text node, so we can append to it and avoid\n                // creating another node.\n                prevNode.text += text;\n                return;\n            }\n        }\n        this.addNode(new XmlText(text));\n    }\n    /**\n  Consumes an `AttValue` (attribute value) if possible.\n\n  @returns {string|false}\n    Contents of the `AttValue` minus quotes, or `false` if nothing was consumed.\n    An empty string indicates that an `AttValue` was consumed but was empty.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\n  */ consumeAttributeValue() {\n        let { scanner } = this;\n        let quote = scanner.peek();\n        if (quote !== '\"' && quote !== \"'\") {\n            return false;\n        }\n        scanner.advance();\n        let chars;\n        let isClosed = false;\n        let value = emptyString;\n        let regex = quote === '\"' ? /[^\"&<]+/y : /[^'&<]+/y;\n        matchLoop: while(!scanner.isEnd){\n            chars = scanner.consumeMatch(regex);\n            if (chars) {\n                this.validateChars(chars);\n                value += chars.replace(/[\\t\\r\\n]/g, \" \");\n            }\n            let nextChar = scanner.peek();\n            switch(nextChar){\n                case quote:\n                    isClosed = true;\n                    break matchLoop;\n                case \"&\":\n                    value += this.consumeReference();\n                    continue;\n                case \"<\":\n                    this.error(\"Unescaped `<` is not allowed in an attribute value\"); /* istanbul ignore next */ \n                    break;\n                case emptyString:\n                    this.error(\"Unclosed attribute\"); /* istanbul ignore next */ \n                    break;\n            }\n        }\n        if (!isClosed) {\n            this.error(\"Unclosed attribute\");\n        }\n        scanner.advance();\n        return value;\n    }\n    /**\n  Consumes a CDATA section if possible.\n\n  @returns {boolean}\n    Whether a CDATA section was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-cdata-sect\n  */ consumeCdataSection() {\n        let { scanner } = this;\n        if (!scanner.consumeStringFast(\"<![CDATA[\")) {\n            return false;\n        }\n        let text = scanner.consumeUntilString(\"]]>\");\n        this.validateChars(text);\n        if (!scanner.consumeStringFast(\"]]>\")) {\n            this.error(\"Unclosed CDATA section\");\n        }\n        if (this.options.preserveCdata) {\n            this.addNode(new XmlCdata(text));\n        } else {\n            this.addText(text);\n        }\n        return true;\n    }\n    /**\n  Consumes character data if possible.\n\n  @returns {boolean}\n    Whether character data was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata\n  */ consumeCharData() {\n        let { scanner } = this;\n        let charData = scanner.consumeUntilMatch(/<|&|]]>/g);\n        if (!charData) {\n            return false;\n        }\n        this.validateChars(charData);\n        if (scanner.peek() === \"]\" && scanner.peek(3) === \"]]>\") {\n            this.error(\"Element content may not contain the CDATA section close delimiter `]]>`\");\n        }\n        this.addText(charData);\n        return true;\n    }\n    /**\n  Consumes a comment if possible.\n\n  @returns {boolean}\n    Whether a comment was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Comment\n  */ consumeComment() {\n        let { scanner } = this;\n        if (!scanner.consumeStringFast(\"<!--\")) {\n            return false;\n        }\n        let content = scanner.consumeUntilString(\"--\");\n        this.validateChars(content);\n        if (!scanner.consumeStringFast(\"-->\")) {\n            if (scanner.peek(2) === \"--\") {\n                this.error(\"The string `--` isn't allowed inside a comment\");\n            } else {\n                this.error(\"Unclosed comment\");\n            }\n        }\n        if (this.options.preserveComments) {\n            this.addNode(new XmlComment(content.trim()));\n        }\n        return true;\n    }\n    /**\n  Consumes a reference in a content context if possible.\n\n  This differs from `consumeReference()` in that a consumed reference will be\n  added to the document as a text node instead of returned.\n\n  @returns {boolean}\n    Whether a reference was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#entproc\n  */ consumeContentReference() {\n        let ref = this.consumeReference();\n        if (ref) {\n            this.addText(ref);\n            return true;\n        }\n        return false;\n    }\n    /**\n  Consumes a doctype declaration if possible.\n\n  This is a loose implementation since doctype declarations are currently\n  discarded without further parsing.\n\n  @returns {boolean}\n    Whether a doctype declaration was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#dtd\n  */ consumeDoctypeDeclaration() {\n        let { scanner } = this;\n        if (!scanner.consumeStringFast(\"<!DOCTYPE\") || !this.consumeWhitespace()) {\n            return false;\n        }\n        scanner.consumeMatch(/[^[>]+/y);\n        if (scanner.consumeMatch(/\\[[\\s\\S]+?\\][\\x20\\t\\r\\n]*>/y)) {\n            return true;\n        }\n        if (!scanner.consumeStringFast(\">\")) {\n            this.error(\"Unclosed doctype declaration\");\n        }\n        return true;\n    }\n    /**\n  Consumes an element if possible.\n\n  @returns {boolean}\n    Whether an element was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-element\n  */ consumeElement() {\n        let { scanner } = this;\n        let mark = scanner.charIndex;\n        if (scanner.peek() !== \"<\") {\n            return false;\n        }\n        scanner.advance();\n        let name = this.consumeName();\n        if (!name) {\n            scanner.reset(mark);\n            return false;\n        }\n        let attributes = Object.create(null);\n        while(this.consumeWhitespace()){\n            let attrName = this.consumeName();\n            if (!attrName) {\n                continue;\n            }\n            let attrValue = this.consumeEqual() && this.consumeAttributeValue();\n            if (attrValue === false) {\n                this.error(\"Attribute value expected\");\n            }\n            if (attrName in attributes) {\n                this.error(`Duplicate attribute: ${attrName}`);\n            }\n            if (attrName === \"xml:space\" && attrValue !== \"default\" && attrValue !== \"preserve\") {\n                this.error('Value of the `xml:space` attribute must be \"default\" or \"preserve\"');\n            }\n            attributes[attrName] = attrValue;\n        }\n        if (this.options.sortAttributes) {\n            let attrNames = Object.keys(attributes).sort();\n            let sortedAttributes = Object.create(null);\n            for(let i = 0; i < attrNames.length; ++i){\n                let attrName = attrNames[i];\n                sortedAttributes[attrName] = attributes[attrName];\n            }\n            attributes = sortedAttributes;\n        }\n        let isEmpty = Boolean(scanner.consumeStringFast(\"/>\"));\n        let element = new XmlElement(name, attributes);\n        element.parent = this.currentNode;\n        if (!isEmpty) {\n            if (!scanner.consumeStringFast(\">\")) {\n                this.error(`Unclosed start tag for element \\`${name}\\``);\n            }\n            this.currentNode = element;\n            this.consumeCharData();\n            while(this.consumeElement() || this.consumeContentReference() || this.consumeCdataSection() || this.consumeProcessingInstruction() || this.consumeComment()){\n                this.consumeCharData();\n            }\n            let endTagMark = scanner.charIndex;\n            let endTagName;\n            if (!scanner.consumeStringFast(\"</\") || !(endTagName = this.consumeName()) || endTagName !== name) {\n                scanner.reset(endTagMark);\n                this.error(`Missing end tag for element ${name}`);\n            }\n            this.consumeWhitespace();\n            if (!scanner.consumeStringFast(\">\")) {\n                this.error(`Unclosed end tag for element ${name}`);\n            }\n            this.currentNode = element.parent;\n        }\n        this.addNode(element);\n        return true;\n    }\n    /**\n  Consumes an `Eq` production if possible.\n\n  @returns {boolean}\n    Whether an `Eq` production was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Eq\n  */ consumeEqual() {\n        this.consumeWhitespace();\n        if (this.scanner.consumeStringFast(\"=\")) {\n            this.consumeWhitespace();\n            return true;\n        }\n        return false;\n    }\n    /**\n  Consumes `Misc` content if possible.\n\n  @returns {boolean}\n    Whether anything was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Misc\n  */ consumeMisc() {\n        return this.consumeComment() || this.consumeProcessingInstruction() || this.consumeWhitespace();\n    }\n    /**\n  Consumes one or more `Name` characters if possible.\n\n  @returns {string}\n    `Name` characters, or an empty string if none were consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Name\n  */ consumeName() {\n        return syntax.isNameStartChar(this.scanner.peek()) ? this.scanner.consumeMatchFn(syntax.isNameChar) : emptyString;\n    }\n    /**\n  Consumes a processing instruction if possible.\n\n  @returns {boolean}\n    Whether a processing instruction was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-pi\n  */ consumeProcessingInstruction() {\n        let { scanner } = this;\n        let mark = scanner.charIndex;\n        if (!scanner.consumeStringFast(\"<?\")) {\n            return false;\n        }\n        let name = this.consumeName();\n        if (name) {\n            if (name.toLowerCase() === \"xml\") {\n                scanner.reset(mark);\n                this.error(\"XML declaration isn't allowed here\");\n            }\n        } else {\n            this.error(\"Invalid processing instruction\");\n        }\n        if (!this.consumeWhitespace()) {\n            if (scanner.consumeStringFast(\"?>\")) {\n                this.addNode(new XmlProcessingInstruction(name));\n                return true;\n            }\n            this.error(\"Whitespace is required after a processing instruction name\");\n        }\n        let content = scanner.consumeUntilString(\"?>\");\n        this.validateChars(content);\n        if (!scanner.consumeStringFast(\"?>\")) {\n            this.error(\"Unterminated processing instruction\");\n        }\n        this.addNode(new XmlProcessingInstruction(name, content));\n        return true;\n    }\n    /**\n  Consumes a prolog if possible.\n\n  @returns {boolean}\n    Whether a prolog was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-prolog-dtd\n  */ consumeProlog() {\n        let { scanner } = this;\n        let mark = scanner.charIndex;\n        this.consumeXmlDeclaration();\n        while(this.consumeMisc()){} // eslint-disable-line no-empty\n        if (this.consumeDoctypeDeclaration()) {\n            while(this.consumeMisc()){} // eslint-disable-line no-empty\n        }\n        return mark < scanner.charIndex;\n    }\n    /**\n  Consumes a reference if possible.\n\n  This differs from `consumeContentReference()` in that a consumed reference\n  will be returned rather than added to the document.\n\n  @returns {string|false}\n    Parsed reference value, or `false` if nothing was consumed (to distinguish\n    from a reference that resolves to an empty string).\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Reference\n  */ consumeReference() {\n        let { scanner } = this;\n        if (scanner.peek() !== \"&\") {\n            return false;\n        }\n        scanner.advance();\n        let ref = scanner.consumeMatchFn(syntax.isReferenceChar);\n        if (scanner.consume() !== \";\") {\n            this.error(\"Unterminated reference (a reference must end with `;`)\");\n        }\n        let parsedValue;\n        if (ref[0] === \"#\") {\n            // This is a character reference.\n            let codePoint = ref[1] === \"x\" ? parseInt(ref.slice(2), 16) // Hex codepoint.\n             : parseInt(ref.slice(1), 10); // Decimal codepoint.\n            if (isNaN(codePoint)) {\n                this.error(\"Invalid character reference\");\n            }\n            parsedValue = String.fromCodePoint(codePoint);\n            if (!syntax.isXmlChar(parsedValue)) {\n                this.error(\"Character reference resolves to an invalid character\");\n            }\n        } else {\n            // This is an entity reference.\n            parsedValue = syntax.predefinedEntities[ref];\n            if (parsedValue === undefined) {\n                let { ignoreUndefinedEntities, resolveUndefinedEntity } = this.options;\n                let wrappedRef = `&${ref};`; // for backcompat with <= 2.x\n                if (resolveUndefinedEntity) {\n                    let resolvedValue = resolveUndefinedEntity(wrappedRef);\n                    if (resolvedValue !== null && resolvedValue !== undefined) {\n                        let type = typeof resolvedValue;\n                        if (type !== \"string\") {\n                            throw new TypeError(`\\`resolveUndefinedEntity()\\` must return a string, \\`null\\`, or \\`undefined\\`, but returned a value of type ${type}`);\n                        }\n                        return resolvedValue;\n                    }\n                }\n                if (ignoreUndefinedEntities) {\n                    return wrappedRef;\n                }\n                scanner.reset(-wrappedRef.length);\n                this.error(`Named entity isn't defined: ${wrappedRef}`);\n            }\n        }\n        return parsedValue;\n    }\n    /**\n  Consumes a `SystemLiteral` if possible.\n\n  A `SystemLiteral` is similar to an attribute value, but allows the characters\n  `<` and `&` and doesn't replace references.\n\n  @returns {string|false}\n    Value of the `SystemLiteral` minus quotes, or `false` if nothing was\n    consumed. An empty string indicates that a `SystemLiteral` was consumed but\n    was empty.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-SystemLiteral\n  */ consumeSystemLiteral() {\n        let { scanner } = this;\n        let quote = scanner.consumeStringFast('\"') || scanner.consumeStringFast(\"'\");\n        if (!quote) {\n            return false;\n        }\n        let value = scanner.consumeUntilString(quote);\n        this.validateChars(value);\n        if (!scanner.consumeStringFast(quote)) {\n            this.error(\"Missing end quote\");\n        }\n        return value;\n    }\n    /**\n  Consumes one or more whitespace characters if possible.\n\n  @returns {boolean}\n    Whether any whitespace characters were consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#white\n  */ consumeWhitespace() {\n        return Boolean(this.scanner.consumeMatchFn(syntax.isWhitespace));\n    }\n    /**\n  Consumes an XML declaration if possible.\n\n  @returns {boolean}\n    Whether an XML declaration was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-XMLDecl\n  */ consumeXmlDeclaration() {\n        let { scanner } = this;\n        if (!scanner.consumeStringFast(\"<?xml\")) {\n            return false;\n        }\n        if (!this.consumeWhitespace()) {\n            this.error(\"Invalid XML declaration\");\n        }\n        let version = Boolean(scanner.consumeStringFast(\"version\")) && this.consumeEqual() && this.consumeSystemLiteral();\n        if (version === false) {\n            this.error(\"XML version is missing or invalid\");\n        } else if (!/^1\\.[0-9]+$/.test(version)) {\n            this.error(\"Invalid character in version number\");\n        }\n        if (this.consumeWhitespace()) {\n            let encoding = Boolean(scanner.consumeStringFast(\"encoding\")) && this.consumeEqual() && this.consumeSystemLiteral();\n            if (encoding) {\n                this.consumeWhitespace();\n            }\n            let standalone = Boolean(scanner.consumeStringFast(\"standalone\")) && this.consumeEqual() && this.consumeSystemLiteral();\n            if (standalone) {\n                if (standalone !== \"yes\" && standalone !== \"no\") {\n                    this.error('Only \"yes\" and \"no\" are permitted as values of `standalone`');\n                }\n                this.consumeWhitespace();\n            }\n        }\n        if (!scanner.consumeStringFast(\"?>\")) {\n            this.error(\"Invalid or unclosed XML declaration\");\n        }\n        return true;\n    }\n    /**\n  Throws an error at the current scanner position.\n\n  @param {string} message\n  */ error(message) {\n        let { charIndex, string: xml } = this.scanner;\n        let column = 1;\n        let excerpt = \"\";\n        let line = 1;\n        // Find the line and column where the error occurred.\n        for(let i = 0; i < charIndex; ++i){\n            let char = xml[i];\n            if (char === \"\\n\") {\n                column = 1;\n                excerpt = \"\";\n                line += 1;\n            } else {\n                column += 1;\n                excerpt += char;\n            }\n        }\n        let eol = xml.indexOf(\"\\n\", charIndex);\n        excerpt += eol === -1 ? xml.slice(charIndex) : xml.slice(charIndex, eol);\n        let excerptStart = 0;\n        // Keep the excerpt below 50 chars, but always keep the error position in\n        // view.\n        if (excerpt.length > 50) {\n            if (column < 40) {\n                excerpt = excerpt.slice(0, 50);\n            } else {\n                excerptStart = column - 20;\n                excerpt = excerpt.slice(excerptStart, column + 30);\n            }\n        }\n        let err = new Error(`${message} (line ${line}, column ${column})\\n` + `  ${excerpt}\\n` + \" \".repeat(column - excerptStart + 1) + \"^\\n\");\n        Object.assign(err, {\n            column,\n            excerpt,\n            line,\n            pos: charIndex\n        });\n        throw err;\n    }\n    /**\n  Throws an invalid character error if any character in the given _string_ isn't\n  a valid XML character.\n\n  @param {string} string\n  */ validateChars(string) {\n        let charIndex = 0;\n        for (let char of string){\n            if (syntax.isNotXmlChar(char)) {\n                this.scanner.reset(-([\n                    ...string\n                ].length - charIndex));\n                this.error(\"Invalid character\");\n            }\n            charIndex += 1;\n        }\n    }\n}\nmodule.exports = Parser;\n// -- Private Functions --------------------------------------------------------\n/**\nNormalizes the given XML string by stripping a byte order mark (if present) and\nreplacing CRLF sequences and lone CR characters with LF characters.\n\n@param {string} xml\n@returns {string}\n*/ function normalizeXmlString(xml) {\n    if (xml[0] === \"\\uFEFF\") {\n        xml = xml.slice(1);\n    }\n    return xml.replace(/\\r\\n?/g, \"\\n\");\n} /** @typedef {import('./XmlNode')} XmlNode */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJncm92ZS9wYXJzZS14bWwvc3JjL2xpYi9QYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxnQkFBZ0JDLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU1HLGFBQWFILG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1JLGNBQWNKLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU1LLGFBQWFMLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1NLDJCQUEyQk4sbUJBQU9BLENBQUM7QUFDekMsTUFBTU8sVUFBVVAsbUJBQU9BLENBQUM7QUFFeEIsTUFBTVEsY0FBYztBQUVwQjs7OztBQUlBLEdBQ0EsTUFBTUM7SUFDSjs7Ozs7Ozs7Ozs7O0VBWUEsR0FDQUMsWUFBWUMsR0FBRyxFQUFFQyxVQUFVLENBQUMsQ0FBQyxDQUFFO1FBQzdCLHdCQUF3QixHQUN4QixJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJVDtRQUVwQixtQ0FBbUMsR0FDbkMsSUFBSSxDQUFDVSxXQUFXLEdBQUcsSUFBSSxDQUFDRCxRQUFRO1FBRWhDLElBQUksQ0FBQ0QsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0csT0FBTyxHQUFHLElBQUloQixjQUFjaUIsbUJBQW1CTDtRQUVwRCxJQUFJLENBQUNNLGFBQWE7UUFFbEIsSUFBSSxDQUFDLElBQUksQ0FBQ0MsY0FBYyxJQUFJO1lBQzFCLElBQUksQ0FBQ0MsS0FBSyxDQUFDO1FBQ2I7UUFFQSxNQUFPLElBQUksQ0FBQ0MsV0FBVyxHQUFJLENBQUMsRUFBRSwrQkFBK0I7UUFFN0QsSUFBSSxDQUFDLElBQUksQ0FBQ0wsT0FBTyxDQUFDTSxLQUFLLEVBQUU7WUFDdkIsSUFBSSxDQUFDRixLQUFLLENBQUM7UUFDYjtJQUNGO0lBRUE7Ozs7RUFJQSxHQUNBRyxRQUFRQyxJQUFJLEVBQUU7UUFDWkEsS0FBS0MsTUFBTSxH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O1FBQ2Y7SUFDRjtBQUNGO0FBRUFrRSxPQUFPQyxPQUFPLEdBQUd2SDtBQUVqQixnRkFBZ0Y7QUFFaEY7Ozs7OztBQU1BLEdBQ0EsU0FBU08sbUJBQW1CTCxHQUFHO0lBQzdCLElBQUlBLEdBQUcsQ0FBQyxFQUFFLEtBQUssVUFBVTtRQUN2QkEsTUFBTUEsSUFBSWtGLEtBQUssQ0FBQztJQUNsQjtJQUVBLE9BQU9sRixJQUFJK0IsT0FBTyxDQUFDLFVBQVU7QUFDL0IsRUFFQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aWN0YWN0b2UvLi9ub2RlX21vZHVsZXMvQHJncm92ZS9wYXJzZS14bWwvc3JjL2xpYi9QYXJzZXIuanM/Yzg2MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFN0cmluZ1NjYW5uZXIgPSByZXF1aXJlKCcuL1N0cmluZ1NjYW5uZXInKTtcbmNvbnN0IHN5bnRheCA9IHJlcXVpcmUoJy4vc3ludGF4Jyk7XG5jb25zdCBYbWxDZGF0YSA9IHJlcXVpcmUoJy4vWG1sQ2RhdGEnKTtcbmNvbnN0IFhtbENvbW1lbnQgPSByZXF1aXJlKCcuL1htbENvbW1lbnQnKTtcbmNvbnN0IFhtbERvY3VtZW50ID0gcmVxdWlyZSgnLi9YbWxEb2N1bWVudCcpO1xuY29uc3QgWG1sRWxlbWVudCA9IHJlcXVpcmUoJy4vWG1sRWxlbWVudCcpO1xuY29uc3QgWG1sUHJvY2Vzc2luZ0luc3RydWN0aW9uID0gcmVxdWlyZSgnLi9YbWxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24nKTtcbmNvbnN0IFhtbFRleHQgPSByZXF1aXJlKCcuL1htbFRleHQnKTtcblxuY29uc3QgZW1wdHlTdHJpbmcgPSAnJztcblxuLyoqXG5QYXJzZXMgYW4gWE1MIHN0cmluZyBpbnRvIGFuIGBYbWxEb2N1bWVudGAuXG5cbkBwcml2YXRlXG4qL1xuY2xhc3MgUGFyc2VyIHtcbiAgLyoqXG4gIEBwYXJhbSB7c3RyaW5nfSB4bWxcbiAgICBYTUwgc3RyaW5nIHRvIHBhcnNlLlxuXG4gIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICBQYXJzaW5nIG9wdGlvbnMuXG5cbiAgICBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlnbm9yZVVuZGVmaW5lZEVudGl0aWVzPWZhbHNlXVxuICAgIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucHJlc2VydmVDZGF0YT1mYWxzZV1cbiAgICBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnByZXNlcnZlQ29tbWVudHM9ZmFsc2VdXG4gICAgQHBhcmFtIHsoZW50aXR5OiBzdHJpbmcpID0+IHN0cmluZz99IFtvcHRpb25zLnJlc29sdmVVbmRlZmluZWRFbnRpdHldXG4gICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zb3J0QXR0cmlidXRlcz1mYWxzZV1cbiAgKi9cbiAgY29uc3RydWN0b3IoeG1sLCBvcHRpb25zID0ge30pIHtcbiAgICAvKiogQHR5cGUge1htbERvY3VtZW50fSAqL1xuICAgIHRoaXMuZG9jdW1lbnQgPSBuZXcgWG1sRG9jdW1lbnQoKTtcblxuICAgIC8qKiBAdHlwZSB7WG1sRG9jdW1lbnR8WG1sRWxlbWVudH0gKi9cbiAgICB0aGlzLmN1cnJlbnROb2RlID0gdGhpcy5kb2N1bWVudDtcblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zY2FubmVyID0gbmV3IFN0cmluZ1NjYW5uZXIobm9ybWFsaXplWG1sU3RyaW5nKHhtbCkpO1xuXG4gICAgdGhpcy5jb25zdW1lUHJvbG9nKCk7XG5cbiAgICBpZiAoIXRoaXMuY29uc3VtZUVsZW1lbnQoKSkge1xuICAgICAgdGhpcy5lcnJvcignUm9vdCBlbGVtZW50IGlzIG1pc3Npbmcgb3IgaW52YWxpZCcpO1xuICAgIH1cblxuICAgIHdoaWxlICh0aGlzLmNvbnN1bWVNaXNjKCkpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcblxuICAgIGlmICghdGhpcy5zY2FubmVyLmlzRW5kKSB7XG4gICAgICB0aGlzLmVycm9yKCdFeHRyYSBjb250ZW50IGF0IHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gIEFkZHMgdGhlIGdpdmVuIGBYbWxOb2RlYCBhcyBhIGNoaWxkIG9mIGB0aGlzLmN1cnJlbnROb2RlYC5cblxuICBAcGFyYW0ge1htbE5vZGV9IG5vZGVcbiAgKi9cbiAgYWRkTm9kZShub2RlKSB7XG4gICAgbm9kZS5wYXJlbnQgPSB0aGlzLmN1cnJlbnROb2RlO1xuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuY3VycmVudE5vZGUuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgfVxuXG4gIC8qKlxuICBBZGRzIHRoZSBnaXZlbiBfdGV4dF8gdG8gdGhlIGRvY3VtZW50LCBlaXRoZXIgYnkgYXBwZW5kaW5nIGl0IHRvIGEgcHJlY2VkaW5nXG4gIGBYbWxUZXh0YCBub2RlIChpZiBwb3NzaWJsZSkgb3IgYnkgY3JlYXRpbmcgYSBuZXcgYFhtbFRleHRgIG5vZGUuXG5cbiAgQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgKi9cbiAgYWRkVGV4dCh0ZXh0KSB7XG4gICAgbGV0IHsgY2hpbGRyZW4gfSA9IHRoaXMuY3VycmVudE5vZGU7XG5cbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IHByZXZOb2RlID0gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChwcmV2Tm9kZSBpbnN0YW5jZW9mIFhtbFRleHQpIHtcbiAgICAgICAgLy8gVGhlIHByZXZpb3VzIG5vZGUgaXMgYSB0ZXh0IG5vZGUsIHNvIHdlIGNhbiBhcHBlbmQgdG8gaXQgYW5kIGF2b2lkXG4gICAgICAgIC8vIGNyZWF0aW5nIGFub3RoZXIgbm9kZS5cbiAgICAgICAgcHJldk5vZGUudGV4dCArPSB0ZXh0O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hZGROb2RlKG5ldyBYbWxUZXh0KHRleHQpKTtcbiAgfVxuXG4gIC8qKlxuICBDb25zdW1lcyBhbiBgQXR0VmFsdWVgIChhdHRyaWJ1dGUgdmFsdWUpIGlmIHBvc3NpYmxlLlxuXG4gIEByZXR1cm5zIHtzdHJpbmd8ZmFsc2V9XG4gICAgQ29udGVudHMgb2YgdGhlIGBBdHRWYWx1ZWAgbWludXMgcXVvdGVzLCBvciBgZmFsc2VgIGlmIG5vdGhpbmcgd2FzIGNvbnN1bWVkLlxuICAgIEFuIGVtcHR5IHN0cmluZyBpbmRpY2F0ZXMgdGhhdCBhbiBgQXR0VmFsdWVgIHdhcyBjb25zdW1lZCBidXQgd2FzIGVtcHR5LlxuXG4gIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLXhtbC0yMDA4MTEyNi8jTlQtQXR0VmFsdWVcbiAgKi9cbiAgY29uc3VtZUF0dHJpYnV0ZVZhbHVlKCkge1xuICAgIGxldCB7IHNjYW5uZXIgfSA9IHRoaXM7XG4gICAgbGV0IHF1b3RlID0gc2Nhbm5lci5wZWVrKCk7XG5cbiAgICBpZiAocXVvdGUgIT09ICdcIicgJiYgcXVvdGUgIT09IFwiJ1wiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc2Nhbm5lci5hZHZhbmNlKCk7XG5cbiAgICBsZXQgY2hhcnM7XG4gICAgbGV0IGlzQ2xvc2VkID0gZmFsc2U7XG4gICAgbGV0IHZhbHVlID0gZW1wdHlTdHJpbmc7XG4gICAgbGV0IHJlZ2V4ID0gcXVvdGUgPT09ICdcIidcbiAgICAgID8gL1teXCImPF0rL3lcbiAgICAgIDogL1teJyY8XSsveTtcblxuICAgIG1hdGNoTG9vcDogd2hpbGUgKCFzY2FubmVyLmlzRW5kKSB7XG4gICAgICBjaGFycyA9IHNjYW5uZXIuY29uc3VtZU1hdGNoKHJlZ2V4KTtcblxuICAgICAgaWYgKGNoYXJzKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGVDaGFycyhjaGFycyk7XG4gICAgICAgIHZhbHVlICs9IGNoYXJzLnJlcGxhY2UoL1tcXHRcXHJcXG5dL2csICcgJyk7XG4gICAgICB9XG5cbiAgICAgIGxldCBuZXh0Q2hhciA9IHNjYW5uZXIucGVlaygpO1xuXG4gICAgICBzd2l0Y2ggKG5leHRDaGFyKSB7XG4gICAgICAgIGNhc2UgcXVvdGU6XG4gICAgICAgICAgaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrIG1hdGNoTG9vcDtcblxuICAgICAgICBjYXNlICcmJzpcbiAgICAgICAgICB2YWx1ZSArPSB0aGlzLmNvbnN1bWVSZWZlcmVuY2UoKTtcbiAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICB0aGlzLmVycm9yKCdVbmVzY2FwZWQgYDxgIGlzIG5vdCBhbGxvd2VkIGluIGFuIGF0dHJpYnV0ZSB2YWx1ZScpOyAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgZW1wdHlTdHJpbmc6XG4gICAgICAgICAgdGhpcy5lcnJvcignVW5jbG9zZWQgYXR0cmlidXRlJyk7IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWlzQ2xvc2VkKSB7XG4gICAgICB0aGlzLmVycm9yKCdVbmNsb3NlZCBhdHRyaWJ1dGUnKTtcbiAgICB9XG5cbiAgICBzY2FubmVyLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgQ29uc3VtZXMgYSBDREFUQSBzZWN0aW9uIGlmIHBvc3NpYmxlLlxuXG4gIEByZXR1cm5zIHtib29sZWFufVxuICAgIFdoZXRoZXIgYSBDREFUQSBzZWN0aW9uIHdhcyBjb25zdW1lZC5cblxuICBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy14bWwtMjAwODExMjYvI3NlYy1jZGF0YS1zZWN0XG4gICovXG4gIGNvbnN1bWVDZGF0YVNlY3Rpb24oKSB7XG4gICAgbGV0IHsgc2Nhbm5lciB9ID0gdGhpcztcblxuICAgIGlmICghc2Nhbm5lci5jb25zdW1lU3RyaW5nRmFzdCgnPCFbQ0RBVEFbJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgdGV4dCA9IHNjYW5uZXIuY29uc3VtZVVudGlsU3RyaW5nKCddXT4nKTtcbiAgICB0aGlzLnZhbGlkYXRlQ2hhcnModGV4dCk7XG5cbiAgICBpZiAoIXNjYW5uZXIuY29uc3VtZVN0cmluZ0Zhc3QoJ11dPicpKSB7XG4gICAgICB0aGlzLmVycm9yKCdVbmNsb3NlZCBDREFUQSBzZWN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wcmVzZXJ2ZUNkYXRhKSB7XG4gICAgICB0aGlzLmFkZE5vZGUobmV3IFhtbENkYXRhKHRleHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRUZXh0KHRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gIENvbnN1bWVzIGNoYXJhY3RlciBkYXRhIGlmIHBvc3NpYmxlLlxuXG4gIEByZXR1cm5zIHtib29sZWFufVxuICAgIFdoZXRoZXIgY2hhcmFjdGVyIGRhdGEgd2FzIGNvbnN1bWVkLlxuXG4gIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLXhtbC0yMDA4MTEyNi8jZHQtY2hhcmRhdGFcbiAgKi9cbiAgY29uc3VtZUNoYXJEYXRhKCkge1xuICAgIGxldCB7IHNjYW5uZXIgfSA9IHRoaXM7XG4gICAgbGV0IGNoYXJEYXRhID0gc2Nhbm5lci5jb25zdW1lVW50aWxNYXRjaCgvPHwmfF1dPi9nKTtcblxuICAgIGlmICghY2hhckRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnZhbGlkYXRlQ2hhcnMoY2hhckRhdGEpO1xuXG4gICAgaWYgKHNjYW5uZXIucGVlaygpID09PSAnXScgJiYgc2Nhbm5lci5wZWVrKDMpID09PSAnXV0+Jykge1xuICAgICAgdGhpcy5lcnJvcignRWxlbWVudCBjb250ZW50IG1heSBub3QgY29udGFpbiB0aGUgQ0RBVEEgc2VjdGlvbiBjbG9zZSBkZWxpbWl0ZXIgYF1dPmAnKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZFRleHQoY2hhckRhdGEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gIENvbnN1bWVzIGEgY29tbWVudCBpZiBwb3NzaWJsZS5cblxuICBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICBXaGV0aGVyIGEgY29tbWVudCB3YXMgY29uc3VtZWQuXG5cbiAgQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvMjAwOC9SRUMteG1sLTIwMDgxMTI2LyNOVC1Db21tZW50XG4gICovXG4gIGNvbnN1bWVDb21tZW50KCkge1xuICAgIGxldCB7IHNjYW5uZXIgfSA9IHRoaXM7XG5cbiAgICBpZiAoIXNjYW5uZXIuY29uc3VtZVN0cmluZ0Zhc3QoJzwhLS0nKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBjb250ZW50ID0gc2Nhbm5lci5jb25zdW1lVW50aWxTdHJpbmcoJy0tJyk7XG4gICAgdGhpcy52YWxpZGF0ZUNoYXJzKGNvbnRlbnQpO1xuXG4gICAgaWYgKCFzY2FubmVyLmNvbnN1bWVTdHJpbmdGYXN0KCctLT4nKSkge1xuICAgICAgaWYgKHNjYW5uZXIucGVlaygyKSA9PT0gJy0tJykge1xuICAgICAgICB0aGlzLmVycm9yKFwiVGhlIHN0cmluZyBgLS1gIGlzbid0IGFsbG93ZWQgaW5zaWRlIGEgY29tbWVudFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXJyb3IoJ1VuY2xvc2VkIGNvbW1lbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnByZXNlcnZlQ29tbWVudHMpIHtcbiAgICAgIHRoaXMuYWRkTm9kZShuZXcgWG1sQ29tbWVudChjb250ZW50LnRyaW0oKSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gIENvbnN1bWVzIGEgcmVmZXJlbmNlIGluIGEgY29udGVudCBjb250ZXh0IGlmIHBvc3NpYmxlLlxuXG4gIFRoaXMgZGlmZmVycyBmcm9tIGBjb25zdW1lUmVmZXJlbmNlKClgIGluIHRoYXQgYSBjb25zdW1lZCByZWZlcmVuY2Ugd2lsbCBiZVxuICBhZGRlZCB0byB0aGUgZG9jdW1lbnQgYXMgYSB0ZXh0IG5vZGUgaW5zdGVhZCBvZiByZXR1cm5lZC5cblxuICBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICBXaGV0aGVyIGEgcmVmZXJlbmNlIHdhcyBjb25zdW1lZC5cblxuICBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy14bWwtMjAwODExMjYvI2VudHByb2NcbiAgKi9cbiAgY29uc3VtZUNvbnRlbnRSZWZlcmVuY2UoKSB7XG4gICAgbGV0IHJlZiA9IHRoaXMuY29uc3VtZVJlZmVyZW5jZSgpO1xuXG4gICAgaWYgKHJlZikge1xuICAgICAgdGhpcy5hZGRUZXh0KHJlZik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgQ29uc3VtZXMgYSBkb2N0eXBlIGRlY2xhcmF0aW9uIGlmIHBvc3NpYmxlLlxuXG4gIFRoaXMgaXMgYSBsb29zZSBpbXBsZW1lbnRhdGlvbiBzaW5jZSBkb2N0eXBlIGRlY2xhcmF0aW9ucyBhcmUgY3VycmVudGx5XG4gIGRpc2NhcmRlZCB3aXRob3V0IGZ1cnRoZXIgcGFyc2luZy5cblxuICBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICBXaGV0aGVyIGEgZG9jdHlwZSBkZWNsYXJhdGlvbiB3YXMgY29uc3VtZWQuXG5cbiAgQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvMjAwOC9SRUMteG1sLTIwMDgxMTI2LyNkdGRcbiAgKi9cbiAgY29uc3VtZURvY3R5cGVEZWNsYXJhdGlvbigpIHtcbiAgICBsZXQgeyBzY2FubmVyIH0gPSB0aGlzO1xuXG4gICAgaWYgKCFzY2FubmVyLmNvbnN1bWVTdHJpbmdGYXN0KCc8IURPQ1RZUEUnKVxuICAgICAgICB8fCAhdGhpcy5jb25zdW1lV2hpdGVzcGFjZSgpKSB7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzY2FubmVyLmNvbnN1bWVNYXRjaCgvW15bPl0rL3kpO1xuXG4gICAgaWYgKHNjYW5uZXIuY29uc3VtZU1hdGNoKC9cXFtbXFxzXFxTXSs/XFxdW1xceDIwXFx0XFxyXFxuXSo+L3kpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIXNjYW5uZXIuY29uc3VtZVN0cmluZ0Zhc3QoJz4nKSkge1xuICAgICAgdGhpcy5lcnJvcignVW5jbG9zZWQgZG9jdHlwZSBkZWNsYXJhdGlvbicpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gIENvbnN1bWVzIGFuIGVsZW1lbnQgaWYgcG9zc2libGUuXG5cbiAgQHJldHVybnMge2Jvb2xlYW59XG4gICAgV2hldGhlciBhbiBlbGVtZW50IHdhcyBjb25zdW1lZC5cblxuICBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy14bWwtMjAwODExMjYvI05ULWVsZW1lbnRcbiAgKi9cbiAgY29uc3VtZUVsZW1lbnQoKSB7XG4gICAgbGV0IHsgc2Nhbm5lciB9ID0gdGhpcztcbiAgICBsZXQgbWFyayA9IHNjYW5uZXIuY2hhckluZGV4O1xuXG4gICAgaWYgKHNjYW5uZXIucGVlaygpICE9PSAnPCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzY2FubmVyLmFkdmFuY2UoKTtcbiAgICBsZXQgbmFtZSA9IHRoaXMuY29uc3VtZU5hbWUoKTtcblxuICAgIGlmICghbmFtZSkge1xuICAgICAgc2Nhbm5lci5yZXNldChtYXJrKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgYXR0cmlidXRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB3aGlsZSAodGhpcy5jb25zdW1lV2hpdGVzcGFjZSgpKSB7XG4gICAgICBsZXQgYXR0ck5hbWUgPSB0aGlzLmNvbnN1bWVOYW1lKCk7XG5cbiAgICAgIGlmICghYXR0ck5hbWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxldCBhdHRyVmFsdWUgPSB0aGlzLmNvbnN1bWVFcXVhbCgpXG4gICAgICAgICYmIHRoaXMuY29uc3VtZUF0dHJpYnV0ZVZhbHVlKCk7XG5cbiAgICAgIGlmIChhdHRyVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZXJyb3IoJ0F0dHJpYnV0ZSB2YWx1ZSBleHBlY3RlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0ck5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgICB0aGlzLmVycm9yKGBEdXBsaWNhdGUgYXR0cmlidXRlOiAke2F0dHJOYW1lfWApO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0ck5hbWUgPT09ICd4bWw6c3BhY2UnXG4gICAgICAgICAgJiYgYXR0clZhbHVlICE9PSAnZGVmYXVsdCdcbiAgICAgICAgICAmJiBhdHRyVmFsdWUgIT09ICdwcmVzZXJ2ZScpIHtcblxuICAgICAgICB0aGlzLmVycm9yKCdWYWx1ZSBvZiB0aGUgYHhtbDpzcGFjZWAgYXR0cmlidXRlIG11c3QgYmUgXCJkZWZhdWx0XCIgb3IgXCJwcmVzZXJ2ZVwiJyk7XG4gICAgICB9XG5cbiAgICAgIGF0dHJpYnV0ZXNbYXR0ck5hbWVdID0gYXR0clZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc29ydEF0dHJpYnV0ZXMpIHtcbiAgICAgIGxldCBhdHRyTmFtZXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5zb3J0KCk7XG4gICAgICBsZXQgc29ydGVkQXR0cmlidXRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0ck5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGxldCBhdHRyTmFtZSA9IGF0dHJOYW1lc1tpXTtcbiAgICAgICAgc29ydGVkQXR0cmlidXRlc1thdHRyTmFtZV0gPSBhdHRyaWJ1dGVzW2F0dHJOYW1lXTtcbiAgICAgIH1cblxuICAgICAgYXR0cmlidXRlcyA9IHNvcnRlZEF0dHJpYnV0ZXM7XG4gICAgfVxuXG4gICAgbGV0IGlzRW1wdHkgPSBCb29sZWFuKHNjYW5uZXIuY29uc3VtZVN0cmluZ0Zhc3QoJy8+JykpO1xuICAgIGxldCBlbGVtZW50ID0gbmV3IFhtbEVsZW1lbnQobmFtZSwgYXR0cmlidXRlcyk7XG5cbiAgICBlbGVtZW50LnBhcmVudCA9IHRoaXMuY3VycmVudE5vZGU7XG5cbiAgICBpZiAoIWlzRW1wdHkpIHtcbiAgICAgIGlmICghc2Nhbm5lci5jb25zdW1lU3RyaW5nRmFzdCgnPicpKSB7XG4gICAgICAgIHRoaXMuZXJyb3IoYFVuY2xvc2VkIHN0YXJ0IHRhZyBmb3IgZWxlbWVudCBcXGAke25hbWV9XFxgYCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBlbGVtZW50O1xuICAgICAgdGhpcy5jb25zdW1lQ2hhckRhdGEoKTtcblxuICAgICAgd2hpbGUgKFxuICAgICAgICB0aGlzLmNvbnN1bWVFbGVtZW50KClcbiAgICAgICAgICB8fCB0aGlzLmNvbnN1bWVDb250ZW50UmVmZXJlbmNlKClcbiAgICAgICAgICB8fCB0aGlzLmNvbnN1bWVDZGF0YVNlY3Rpb24oKVxuICAgICAgICAgIHx8IHRoaXMuY29uc3VtZVByb2Nlc3NpbmdJbnN0cnVjdGlvbigpXG4gICAgICAgICAgfHwgdGhpcy5jb25zdW1lQ29tbWVudCgpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5jb25zdW1lQ2hhckRhdGEoKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGVuZFRhZ01hcmsgPSBzY2FubmVyLmNoYXJJbmRleDtcbiAgICAgIGxldCBlbmRUYWdOYW1lO1xuXG4gICAgICBpZiAoIXNjYW5uZXIuY29uc3VtZVN0cmluZ0Zhc3QoJzwvJylcbiAgICAgICAgICB8fCAhKGVuZFRhZ05hbWUgPSB0aGlzLmNvbnN1bWVOYW1lKCkpXG4gICAgICAgICAgfHwgZW5kVGFnTmFtZSAhPT0gbmFtZSkge1xuXG4gICAgICAgIHNjYW5uZXIucmVzZXQoZW5kVGFnTWFyayk7XG4gICAgICAgIHRoaXMuZXJyb3IoYE1pc3NpbmcgZW5kIHRhZyBmb3IgZWxlbWVudCAke25hbWV9YCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29uc3VtZVdoaXRlc3BhY2UoKTtcblxuICAgICAgaWYgKCFzY2FubmVyLmNvbnN1bWVTdHJpbmdGYXN0KCc+JykpIHtcbiAgICAgICAgdGhpcy5lcnJvcihgVW5jbG9zZWQgZW5kIHRhZyBmb3IgZWxlbWVudCAke25hbWV9YCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBlbGVtZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICB0aGlzLmFkZE5vZGUoZWxlbWVudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgQ29uc3VtZXMgYW4gYEVxYCBwcm9kdWN0aW9uIGlmIHBvc3NpYmxlLlxuXG4gIEByZXR1cm5zIHtib29sZWFufVxuICAgIFdoZXRoZXIgYW4gYEVxYCBwcm9kdWN0aW9uIHdhcyBjb25zdW1lZC5cblxuICBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy14bWwtMjAwODExMjYvI05ULUVxXG4gICovXG4gIGNvbnN1bWVFcXVhbCgpIHtcbiAgICB0aGlzLmNvbnN1bWVXaGl0ZXNwYWNlKCk7XG5cbiAgICBpZiAodGhpcy5zY2FubmVyLmNvbnN1bWVTdHJpbmdGYXN0KCc9JykpIHtcbiAgICAgIHRoaXMuY29uc3VtZVdoaXRlc3BhY2UoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICBDb25zdW1lcyBgTWlzY2AgY29udGVudCBpZiBwb3NzaWJsZS5cblxuICBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICBXaGV0aGVyIGFueXRoaW5nIHdhcyBjb25zdW1lZC5cblxuICBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy14bWwtMjAwODExMjYvI05ULU1pc2NcbiAgKi9cbiAgY29uc3VtZU1pc2MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3VtZUNvbW1lbnQoKVxuICAgICAgfHwgdGhpcy5jb25zdW1lUHJvY2Vzc2luZ0luc3RydWN0aW9uKClcbiAgICAgIHx8IHRoaXMuY29uc3VtZVdoaXRlc3BhY2UoKTtcbiAgfVxuXG4gIC8qKlxuICBDb25zdW1lcyBvbmUgb3IgbW9yZSBgTmFtZWAgY2hhcmFjdGVycyBpZiBwb3NzaWJsZS5cblxuICBAcmV0dXJucyB7c3RyaW5nfVxuICAgIGBOYW1lYCBjaGFyYWN0ZXJzLCBvciBhbiBlbXB0eSBzdHJpbmcgaWYgbm9uZSB3ZXJlIGNvbnN1bWVkLlxuXG4gIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLXhtbC0yMDA4MTEyNi8jTlQtTmFtZVxuICAqL1xuICBjb25zdW1lTmFtZSgpIHtcbiAgICByZXR1cm4gc3ludGF4LmlzTmFtZVN0YXJ0Q2hhcih0aGlzLnNjYW5uZXIucGVlaygpKVxuICAgICAgPyB0aGlzLnNjYW5uZXIuY29uc3VtZU1hdGNoRm4oc3ludGF4LmlzTmFtZUNoYXIpXG4gICAgICA6IGVtcHR5U3RyaW5nO1xuICB9XG5cbiAgLyoqXG4gIENvbnN1bWVzIGEgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBpZiBwb3NzaWJsZS5cblxuICBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICBXaGV0aGVyIGEgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiB3YXMgY29uc3VtZWQuXG5cbiAgQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvMjAwOC9SRUMteG1sLTIwMDgxMTI2LyNzZWMtcGlcbiAgKi9cbiAgY29uc3VtZVByb2Nlc3NpbmdJbnN0cnVjdGlvbigpIHtcbiAgICBsZXQgeyBzY2FubmVyIH0gPSB0aGlzO1xuICAgIGxldCBtYXJrID0gc2Nhbm5lci5jaGFySW5kZXg7XG5cbiAgICBpZiAoIXNjYW5uZXIuY29uc3VtZVN0cmluZ0Zhc3QoJzw/JykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgbmFtZSA9IHRoaXMuY29uc3VtZU5hbWUoKTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICBpZiAobmFtZS50b0xvd2VyQ2FzZSgpID09PSAneG1sJykge1xuICAgICAgICBzY2FubmVyLnJlc2V0KG1hcmspO1xuICAgICAgICB0aGlzLmVycm9yKFwiWE1MIGRlY2xhcmF0aW9uIGlzbid0IGFsbG93ZWQgaGVyZVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lcnJvcignSW52YWxpZCBwcm9jZXNzaW5nIGluc3RydWN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmNvbnN1bWVXaGl0ZXNwYWNlKCkpIHtcbiAgICAgIGlmIChzY2FubmVyLmNvbnN1bWVTdHJpbmdGYXN0KCc/PicpKSB7XG4gICAgICAgIHRoaXMuYWRkTm9kZShuZXcgWG1sUHJvY2Vzc2luZ0luc3RydWN0aW9uKG5hbWUpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXJyb3IoJ1doaXRlc3BhY2UgaXMgcmVxdWlyZWQgYWZ0ZXIgYSBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5hbWUnKTtcbiAgICB9XG5cbiAgICBsZXQgY29udGVudCA9IHNjYW5uZXIuY29uc3VtZVVudGlsU3RyaW5nKCc/PicpO1xuICAgIHRoaXMudmFsaWRhdGVDaGFycyhjb250ZW50KTtcblxuICAgIGlmICghc2Nhbm5lci5jb25zdW1lU3RyaW5nRmFzdCgnPz4nKSkge1xuICAgICAgdGhpcy5lcnJvcignVW50ZXJtaW5hdGVkIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24nKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZE5vZGUobmV3IFhtbFByb2Nlc3NpbmdJbnN0cnVjdGlvbihuYW1lLCBjb250ZW50KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgQ29uc3VtZXMgYSBwcm9sb2cgaWYgcG9zc2libGUuXG5cbiAgQHJldHVybnMge2Jvb2xlYW59XG4gICAgV2hldGhlciBhIHByb2xvZyB3YXMgY29uc3VtZWQuXG5cbiAgQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvMjAwOC9SRUMteG1sLTIwMDgxMTI2LyNzZWMtcHJvbG9nLWR0ZFxuICAqL1xuICBjb25zdW1lUHJvbG9nKCkge1xuICAgIGxldCB7IHNjYW5uZXIgfSA9IHRoaXM7XG4gICAgbGV0IG1hcmsgPSBzY2FubmVyLmNoYXJJbmRleDtcblxuICAgIHRoaXMuY29uc3VtZVhtbERlY2xhcmF0aW9uKCk7XG5cbiAgICB3aGlsZSAodGhpcy5jb25zdW1lTWlzYygpKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG5cbiAgICBpZiAodGhpcy5jb25zdW1lRG9jdHlwZURlY2xhcmF0aW9uKCkpIHtcbiAgICAgIHdoaWxlICh0aGlzLmNvbnN1bWVNaXNjKCkpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbiAgICB9XG5cbiAgICByZXR1cm4gbWFyayA8IHNjYW5uZXIuY2hhckluZGV4O1xuICB9XG5cbiAgLyoqXG4gIENvbnN1bWVzIGEgcmVmZXJlbmNlIGlmIHBvc3NpYmxlLlxuXG4gIFRoaXMgZGlmZmVycyBmcm9tIGBjb25zdW1lQ29udGVudFJlZmVyZW5jZSgpYCBpbiB0aGF0IGEgY29uc3VtZWQgcmVmZXJlbmNlXG4gIHdpbGwgYmUgcmV0dXJuZWQgcmF0aGVyIHRoYW4gYWRkZWQgdG8gdGhlIGRvY3VtZW50LlxuXG4gIEByZXR1cm5zIHtzdHJpbmd8ZmFsc2V9XG4gICAgUGFyc2VkIHJlZmVyZW5jZSB2YWx1ZSwgb3IgYGZhbHNlYCBpZiBub3RoaW5nIHdhcyBjb25zdW1lZCAodG8gZGlzdGluZ3Vpc2hcbiAgICBmcm9tIGEgcmVmZXJlbmNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gZW1wdHkgc3RyaW5nKS5cblxuICBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy14bWwtMjAwODExMjYvI05ULVJlZmVyZW5jZVxuICAqL1xuICBjb25zdW1lUmVmZXJlbmNlKCkge1xuICAgIGxldCB7IHNjYW5uZXIgfSA9IHRoaXM7XG5cbiAgICBpZiAoc2Nhbm5lci5wZWVrKCkgIT09ICcmJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNjYW5uZXIuYWR2YW5jZSgpO1xuXG4gICAgbGV0IHJlZiA9IHNjYW5uZXIuY29uc3VtZU1hdGNoRm4oc3ludGF4LmlzUmVmZXJlbmNlQ2hhcik7XG5cbiAgICBpZiAoc2Nhbm5lci5jb25zdW1lKCkgIT09ICc7Jykge1xuICAgICAgdGhpcy5lcnJvcignVW50ZXJtaW5hdGVkIHJlZmVyZW5jZSAoYSByZWZlcmVuY2UgbXVzdCBlbmQgd2l0aCBgO2ApJyk7XG4gICAgfVxuXG4gICAgbGV0IHBhcnNlZFZhbHVlO1xuXG4gICAgaWYgKHJlZlswXSA9PT0gJyMnKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgY2hhcmFjdGVyIHJlZmVyZW5jZS5cbiAgICAgIGxldCBjb2RlUG9pbnQgPSByZWZbMV0gPT09ICd4J1xuICAgICAgICA/IHBhcnNlSW50KHJlZi5zbGljZSgyKSwgMTYpIC8vIEhleCBjb2RlcG9pbnQuXG4gICAgICAgIDogcGFyc2VJbnQocmVmLnNsaWNlKDEpLCAxMCk7IC8vIERlY2ltYWwgY29kZXBvaW50LlxuXG4gICAgICBpZiAoaXNOYU4oY29kZVBvaW50KSkge1xuICAgICAgICB0aGlzLmVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciByZWZlcmVuY2UnKTtcbiAgICAgIH1cblxuICAgICAgcGFyc2VkVmFsdWUgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlUG9pbnQpO1xuXG4gICAgICBpZiAoIXN5bnRheC5pc1htbENoYXIocGFyc2VkVmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZXJyb3IoJ0NoYXJhY3RlciByZWZlcmVuY2UgcmVzb2x2ZXMgdG8gYW4gaW52YWxpZCBjaGFyYWN0ZXInKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhbiBlbnRpdHkgcmVmZXJlbmNlLlxuICAgICAgcGFyc2VkVmFsdWUgPSBzeW50YXgucHJlZGVmaW5lZEVudGl0aWVzW3JlZl07XG5cbiAgICAgIGlmIChwYXJzZWRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgaWdub3JlVW5kZWZpbmVkRW50aXRpZXMsXG4gICAgICAgICAgcmVzb2x2ZVVuZGVmaW5lZEVudGl0eVxuICAgICAgICB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgIGxldCB3cmFwcGVkUmVmID0gYCYke3JlZn07YDsgLy8gZm9yIGJhY2tjb21wYXQgd2l0aCA8PSAyLnhcblxuICAgICAgICBpZiAocmVzb2x2ZVVuZGVmaW5lZEVudGl0eSkge1xuICAgICAgICAgIGxldCByZXNvbHZlZFZhbHVlID0gcmVzb2x2ZVVuZGVmaW5lZEVudGl0eSh3cmFwcGVkUmVmKTtcblxuICAgICAgICAgIGlmIChyZXNvbHZlZFZhbHVlICE9PSBudWxsICYmIHJlc29sdmVkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0eXBlb2YgcmVzb2x2ZWRWYWx1ZTtcblxuICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFxcYHJlc29sdmVVbmRlZmluZWRFbnRpdHkoKVxcYCBtdXN0IHJldHVybiBhIHN0cmluZywgXFxgbnVsbFxcYCwgb3IgXFxgdW5kZWZpbmVkXFxgLCBidXQgcmV0dXJuZWQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZX1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlnbm9yZVVuZGVmaW5lZEVudGl0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIHdyYXBwZWRSZWY7XG4gICAgICAgIH1cblxuICAgICAgICBzY2FubmVyLnJlc2V0KC13cmFwcGVkUmVmLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuZXJyb3IoYE5hbWVkIGVudGl0eSBpc24ndCBkZWZpbmVkOiAke3dyYXBwZWRSZWZ9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZFZhbHVlO1xuICB9XG5cbiAgLyoqXG4gIENvbnN1bWVzIGEgYFN5c3RlbUxpdGVyYWxgIGlmIHBvc3NpYmxlLlxuXG4gIEEgYFN5c3RlbUxpdGVyYWxgIGlzIHNpbWlsYXIgdG8gYW4gYXR0cmlidXRlIHZhbHVlLCBidXQgYWxsb3dzIHRoZSBjaGFyYWN0ZXJzXG4gIGA8YCBhbmQgYCZgIGFuZCBkb2Vzbid0IHJlcGxhY2UgcmVmZXJlbmNlcy5cblxuICBAcmV0dXJucyB7c3RyaW5nfGZhbHNlfVxuICAgIFZhbHVlIG9mIHRoZSBgU3lzdGVtTGl0ZXJhbGAgbWludXMgcXVvdGVzLCBvciBgZmFsc2VgIGlmIG5vdGhpbmcgd2FzXG4gICAgY29uc3VtZWQuIEFuIGVtcHR5IHN0cmluZyBpbmRpY2F0ZXMgdGhhdCBhIGBTeXN0ZW1MaXRlcmFsYCB3YXMgY29uc3VtZWQgYnV0XG4gICAgd2FzIGVtcHR5LlxuXG4gIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLXhtbC0yMDA4MTEyNi8jTlQtU3lzdGVtTGl0ZXJhbFxuICAqL1xuICBjb25zdW1lU3lzdGVtTGl0ZXJhbCgpIHtcbiAgICBsZXQgeyBzY2FubmVyIH0gPSB0aGlzO1xuICAgIGxldCBxdW90ZSA9IHNjYW5uZXIuY29uc3VtZVN0cmluZ0Zhc3QoJ1wiJykgfHwgc2Nhbm5lci5jb25zdW1lU3RyaW5nRmFzdChcIidcIik7XG5cbiAgICBpZiAoIXF1b3RlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHZhbHVlID0gc2Nhbm5lci5jb25zdW1lVW50aWxTdHJpbmcocXVvdGUpO1xuICAgIHRoaXMudmFsaWRhdGVDaGFycyh2YWx1ZSk7XG5cbiAgICBpZiAoIXNjYW5uZXIuY29uc3VtZVN0cmluZ0Zhc3QocXVvdGUpKSB7XG4gICAgICB0aGlzLmVycm9yKCdNaXNzaW5nIGVuZCBxdW90ZScpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICBDb25zdW1lcyBvbmUgb3IgbW9yZSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgaWYgcG9zc2libGUuXG5cbiAgQHJldHVybnMge2Jvb2xlYW59XG4gICAgV2hldGhlciBhbnkgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHdlcmUgY29uc3VtZWQuXG5cbiAgQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvMjAwOC9SRUMteG1sLTIwMDgxMTI2LyN3aGl0ZVxuICAqL1xuICBjb25zdW1lV2hpdGVzcGFjZSgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLnNjYW5uZXIuY29uc3VtZU1hdGNoRm4oc3ludGF4LmlzV2hpdGVzcGFjZSkpO1xuICB9XG5cbiAgLyoqXG4gIENvbnN1bWVzIGFuIFhNTCBkZWNsYXJhdGlvbiBpZiBwb3NzaWJsZS5cblxuICBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICBXaGV0aGVyIGFuIFhNTCBkZWNsYXJhdGlvbiB3YXMgY29uc3VtZWQuXG5cbiAgQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvMjAwOC9SRUMteG1sLTIwMDgxMTI2LyNOVC1YTUxEZWNsXG4gICovXG4gIGNvbnN1bWVYbWxEZWNsYXJhdGlvbigpIHtcbiAgICBsZXQgeyBzY2FubmVyIH0gPSB0aGlzO1xuXG4gICAgaWYgKCFzY2FubmVyLmNvbnN1bWVTdHJpbmdGYXN0KCc8P3htbCcpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmNvbnN1bWVXaGl0ZXNwYWNlKCkpIHtcbiAgICAgIHRoaXMuZXJyb3IoJ0ludmFsaWQgWE1MIGRlY2xhcmF0aW9uJyk7XG4gICAgfVxuXG4gICAgbGV0IHZlcnNpb24gPSBCb29sZWFuKHNjYW5uZXIuY29uc3VtZVN0cmluZ0Zhc3QoJ3ZlcnNpb24nKSlcbiAgICAgICYmIHRoaXMuY29uc3VtZUVxdWFsKClcbiAgICAgICYmIHRoaXMuY29uc3VtZVN5c3RlbUxpdGVyYWwoKTtcblxuICAgIGlmICh2ZXJzaW9uID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5lcnJvcignWE1MIHZlcnNpb24gaXMgbWlzc2luZyBvciBpbnZhbGlkJyk7XG4gICAgfSBlbHNlIGlmICghL14xXFwuWzAtOV0rJC8udGVzdCh2ZXJzaW9uKSkge1xuICAgICAgdGhpcy5lcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gdmVyc2lvbiBudW1iZXInKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb25zdW1lV2hpdGVzcGFjZSgpKSB7XG4gICAgICBsZXQgZW5jb2RpbmcgPSBCb29sZWFuKHNjYW5uZXIuY29uc3VtZVN0cmluZ0Zhc3QoJ2VuY29kaW5nJykpXG4gICAgICAgICYmIHRoaXMuY29uc3VtZUVxdWFsKClcbiAgICAgICAgJiYgdGhpcy5jb25zdW1lU3lzdGVtTGl0ZXJhbCgpO1xuXG4gICAgICBpZiAoZW5jb2RpbmcpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lV2hpdGVzcGFjZSgpO1xuICAgICAgfVxuXG4gICAgICBsZXQgc3RhbmRhbG9uZSA9IEJvb2xlYW4oc2Nhbm5lci5jb25zdW1lU3RyaW5nRmFzdCgnc3RhbmRhbG9uZScpKVxuICAgICAgICAmJiB0aGlzLmNvbnN1bWVFcXVhbCgpXG4gICAgICAgICYmIHRoaXMuY29uc3VtZVN5c3RlbUxpdGVyYWwoKTtcblxuICAgICAgaWYgKHN0YW5kYWxvbmUpIHtcbiAgICAgICAgaWYgKHN0YW5kYWxvbmUgIT09ICd5ZXMnICYmIHN0YW5kYWxvbmUgIT09ICdubycpIHtcbiAgICAgICAgICB0aGlzLmVycm9yKCdPbmx5IFwieWVzXCIgYW5kIFwibm9cIiBhcmUgcGVybWl0dGVkIGFzIHZhbHVlcyBvZiBgc3RhbmRhbG9uZWAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29uc3VtZVdoaXRlc3BhY2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXNjYW5uZXIuY29uc3VtZVN0cmluZ0Zhc3QoJz8+JykpIHtcbiAgICAgIHRoaXMuZXJyb3IoJ0ludmFsaWQgb3IgdW5jbG9zZWQgWE1MIGRlY2xhcmF0aW9uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgVGhyb3dzIGFuIGVycm9yIGF0IHRoZSBjdXJyZW50IHNjYW5uZXIgcG9zaXRpb24uXG5cbiAgQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAgKi9cbiAgZXJyb3IobWVzc2FnZSkge1xuICAgIGxldCB7IGNoYXJJbmRleCwgc3RyaW5nOiB4bWwgfSA9IHRoaXMuc2Nhbm5lcjtcbiAgICBsZXQgY29sdW1uID0gMTtcbiAgICBsZXQgZXhjZXJwdCA9ICcnO1xuICAgIGxldCBsaW5lID0gMTtcblxuICAgIC8vIEZpbmQgdGhlIGxpbmUgYW5kIGNvbHVtbiB3aGVyZSB0aGUgZXJyb3Igb2NjdXJyZWQuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFySW5kZXg7ICsraSkge1xuICAgICAgbGV0IGNoYXIgPSB4bWxbaV07XG5cbiAgICAgIGlmIChjaGFyID09PSAnXFxuJykge1xuICAgICAgICBjb2x1bW4gPSAxO1xuICAgICAgICBleGNlcnB0ID0gJyc7XG4gICAgICAgIGxpbmUgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbHVtbiArPSAxO1xuICAgICAgICBleGNlcnB0ICs9IGNoYXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGVvbCA9IHhtbC5pbmRleE9mKCdcXG4nLCBjaGFySW5kZXgpO1xuXG4gICAgZXhjZXJwdCArPSBlb2wgPT09IC0xXG4gICAgICA/IHhtbC5zbGljZShjaGFySW5kZXgpXG4gICAgICA6IHhtbC5zbGljZShjaGFySW5kZXgsIGVvbCk7XG5cbiAgICBsZXQgZXhjZXJwdFN0YXJ0ID0gMDtcblxuICAgIC8vIEtlZXAgdGhlIGV4Y2VycHQgYmVsb3cgNTAgY2hhcnMsIGJ1dCBhbHdheXMga2VlcCB0aGUgZXJyb3IgcG9zaXRpb24gaW5cbiAgICAvLyB2aWV3LlxuICAgIGlmIChleGNlcnB0Lmxlbmd0aCA+IDUwKSB7XG4gICAgICBpZiAoY29sdW1uIDwgNDApIHtcbiAgICAgICAgZXhjZXJwdCA9IGV4Y2VycHQuc2xpY2UoMCwgNTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhjZXJwdFN0YXJ0ID0gY29sdW1uIC0gMjA7XG4gICAgICAgIGV4Y2VycHQgPSBleGNlcnB0LnNsaWNlKGV4Y2VycHRTdGFydCwgY29sdW1uICsgMzApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICBgJHttZXNzYWdlfSAobGluZSAke2xpbmV9LCBjb2x1bW4gJHtjb2x1bW59KVxcbmBcbiAgICAgICAgKyBgICAke2V4Y2VycHR9XFxuYFxuICAgICAgICArICcgJy5yZXBlYXQoY29sdW1uIC0gZXhjZXJwdFN0YXJ0ICsgMSkgKyAnXlxcbidcbiAgICApO1xuXG4gICAgT2JqZWN0LmFzc2lnbihlcnIsIHtcbiAgICAgIGNvbHVtbixcbiAgICAgIGV4Y2VycHQsXG4gICAgICBsaW5lLFxuICAgICAgcG9zOiBjaGFySW5kZXhcbiAgICB9KTtcblxuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIC8qKlxuICBUaHJvd3MgYW4gaW52YWxpZCBjaGFyYWN0ZXIgZXJyb3IgaWYgYW55IGNoYXJhY3RlciBpbiB0aGUgZ2l2ZW4gX3N0cmluZ18gaXNuJ3RcbiAgYSB2YWxpZCBYTUwgY2hhcmFjdGVyLlxuXG4gIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgKi9cbiAgdmFsaWRhdGVDaGFycyhzdHJpbmcpIHtcbiAgICBsZXQgY2hhckluZGV4ID0gMDtcblxuICAgIGZvciAobGV0IGNoYXIgb2Ygc3RyaW5nKSB7XG4gICAgICBpZiAoc3ludGF4LmlzTm90WG1sQ2hhcihjaGFyKSkge1xuICAgICAgICB0aGlzLnNjYW5uZXIucmVzZXQoLShbIC4uLnN0cmluZyBdLmxlbmd0aCAtIGNoYXJJbmRleCkpO1xuICAgICAgICB0aGlzLmVycm9yKCdJbnZhbGlkIGNoYXJhY3RlcicpO1xuICAgICAgfVxuXG4gICAgICBjaGFySW5kZXggKz0gMTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXI7XG5cbi8vIC0tIFByaXZhdGUgRnVuY3Rpb25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuTm9ybWFsaXplcyB0aGUgZ2l2ZW4gWE1MIHN0cmluZyBieSBzdHJpcHBpbmcgYSBieXRlIG9yZGVyIG1hcmsgKGlmIHByZXNlbnQpIGFuZFxucmVwbGFjaW5nIENSTEYgc2VxdWVuY2VzIGFuZCBsb25lIENSIGNoYXJhY3RlcnMgd2l0aCBMRiBjaGFyYWN0ZXJzLlxuXG5AcGFyYW0ge3N0cmluZ30geG1sXG5AcmV0dXJucyB7c3RyaW5nfVxuKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVhtbFN0cmluZyh4bWwpIHtcbiAgaWYgKHhtbFswXSA9PT0gJ1xcdUZFRkYnKSB7XG4gICAgeG1sID0geG1sLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIHhtbC5yZXBsYWNlKC9cXHJcXG4/L2csICdcXG4nKTtcbn1cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vWG1sTm9kZScpfSBYbWxOb2RlICovXG4iXSwibmFtZXMiOlsiU3RyaW5nU2Nhbm5lciIsInJlcXVpcmUiLCJzeW50YXgiLCJYbWxDZGF0YSIsIlhtbENvbW1lbnQiLCJYbWxEb2N1bWVudCIsIlhtbEVsZW1lbnQiLCJYbWxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24iLCJYbWxUZXh0IiwiZW1wdHlTdHJpbmciLCJQYXJzZXIiLCJjb25zdHJ1Y3RvciIsInhtbCIsIm9wdGlvbnMiLCJkb2N1bWVudCIsImN1cnJlbnROb2RlIiwic2Nhbm5lciIsIm5vcm1hbGl6ZVhtbFN0cmluZyIsImNvbnN1bWVQcm9sb2ciLCJjb25zdW1lRWxlbWVudCIsImVycm9yIiwiY29uc3VtZU1pc2MiLCJpc0VuZCIsImFkZE5vZGUiLCJub2RlIiwicGFyZW50IiwiY2hpbGRyZW4iLCJwdXNoIiwiYWRkVGV4dCIsInRleHQiLCJsZW5ndGgiLCJwcmV2Tm9kZSIsImNvbnN1bWVBdHRyaWJ1dGVWYWx1ZSIsInF1b3RlIiwicGVlayIsImFkdmFuY2UiLCJjaGFycyIsImlzQ2xvc2VkIiwidmFsdWUiLCJyZWdleCIsIm1hdGNoTG9vcCIsImNvbnN1bWVNYXRjaCIsInZhbGlkYXRlQ2hhcnMiLCJyZXBsYWNlIiwibmV4dENoYXIiLCJjb25zdW1lUmVmZXJlbmNlIiwiY29uc3VtZUNkYXRhU2VjdGlvbiIsImNvbnN1bWVTdHJpbmdGYXN0IiwiY29uc3VtZVVudGlsU3RyaW5nIiwicHJlc2VydmVDZGF0YSIsImNvbnN1bWVDaGFyRGF0YSIsImNoYXJEYXRhIiwiY29uc3VtZVVudGlsTWF0Y2giLCJjb25zdW1lQ29tbWVudCIsImNvbnRlbnQiLCJwcmVzZXJ2ZUNvbW1lbnRzIiwidHJpbSIsImNvbnN1bWVDb250ZW50UmVmZXJlbmNlIiwicmVmIiwiY29uc3VtZURvY3R5cGVEZWNsYXJhdGlvbiIsImNvbnN1bWVXaGl0ZXNwYWNlIiwibWFyayIsImNoYXJJbmRleCIsIm5hbWUiLCJjb25zdW1lTmFtZSIsInJlc2V0IiwiYXR0cmlidXRlcyIsIk9iamVjdCIsImNyZWF0ZSIsImF0dHJOYW1lIiwiYXR0clZhbHVlIiwiY29uc3VtZUVxdWFsIiwic29ydEF0dHJpYnV0ZXMiLCJhdHRyTmFtZXMiLCJrZXlzIiwic29ydCIsInNvcnRlZEF0dHJpYnV0ZXMiLCJpIiwiaXNFbXB0eSIsIkJvb2xlYW4iLCJlbGVtZW50IiwiY29uc3VtZVByb2Nlc3NpbmdJbnN0cnVjdGlvbiIsImVuZFRhZ01hcmsiLCJlbmRUYWdOYW1lIiwiaXNOYW1lU3RhcnRDaGFyIiwiY29uc3VtZU1hdGNoRm4iLCJpc05hbWVDaGFyIiwidG9Mb3dlckNhc2UiLCJjb25zdW1lWG1sRGVjbGFyYXRpb24iLCJpc1JlZmVyZW5jZUNoYXIiLCJjb25zdW1lIiwicGFyc2VkVmFsdWUiLCJjb2RlUG9pbnQiLCJwYXJzZUludCIsInNsaWNlIiwiaXNOYU4iLCJTdHJpbmciLCJmcm9tQ29kZVBvaW50IiwiaXNYbWxDaGFyIiwicHJlZGVmaW5lZEVudGl0aWVzIiwidW5kZWZpbmVkIiwiaWdub3JlVW5kZWZpbmVkRW50aXRpZXMiLCJyZXNvbHZlVW5kZWZpbmVkRW50aXR5Iiwid3JhcHBlZFJlZiIsInJlc29sdmVkVmFsdWUiLCJ0eXBlIiwiVHlwZUVycm9yIiwiY29uc3VtZVN5c3RlbUxpdGVyYWwiLCJpc1doaXRlc3BhY2UiLCJ2ZXJzaW9uIiwidGVzdCIsImVuY29kaW5nIiwic3RhbmRhbG9uZSIsIm1lc3NhZ2UiLCJzdHJpbmciLCJjb2x1bW4iLCJleGNlcnB0IiwibGluZSIsImNoYXIiLCJlb2wiLCJpbmRleE9mIiwiZXhjZXJwdFN0YXJ0IiwiZXJyIiwiRXJyb3IiLCJyZXBlYXQiLCJhc3NpZ24iLCJwb3MiLCJpc05vdFhtbENoYXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@rgrove/parse-xml/src/lib/Parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@rgrove/parse-xml/src/lib/StringScanner.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@rgrove/parse-xml/src/lib/StringScanner.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("\nconst emptyString = \"\";\n/**\n@private\n*/ class StringScanner {\n    /**\n  @param {string} string\n  */ constructor(string){\n        /** @type {string[]} */ this.chars = [\n            ...string\n        ];\n        /** @type {number} */ this.charCount = this.chars.length;\n        /** @type {number} */ this.charIndex = 0;\n        /** @type {number[]} */ this.charsToBytes = new Array(this.charCount);\n        /** @type {boolean} */ this.multiByteMode = false;\n        /** @type {string} */ this.string = string;\n        let { chars, charCount, charsToBytes } = this;\n        if (charCount === string.length) {\n            // There are no multibyte characters in the input string, so char indexes\n            // and byte indexes are the same.\n            for(let i = 0; i < charCount; ++i){\n                charsToBytes[i] = i;\n            }\n        } else {\n            // Create a mapping of character indexes to byte indexes. When the string\n            // contains multibyte characters, a byte index may not necessarily align\n            // with a character index.\n            for(let byteIndex = 0, charIndex = 0; charIndex < charCount; ++charIndex){\n                charsToBytes[charIndex] = byteIndex;\n                byteIndex += chars[charIndex].length;\n            }\n            this.multiByteMode = true;\n        }\n    }\n    /**\n  Whether the current character index is at the end of the input string.\n\n  @type {boolean}\n  */ get isEnd() {\n        return this.charIndex >= this.charCount;\n    }\n    // -- Protected Methods ------------------------------------------------------\n    /**\n  Returns the number of characters in the given _string_, which may differ from\n  the byte length if the string contains multibyte characters.\n\n  @param {string} string\n  @returns {number}\n  */ _charLength(string) {\n        let { length } = string;\n        if (length < 2 || !this.multiByteMode) {\n            return length;\n        }\n        // We could get the char length with `[ ...string ].length`, but that's\n        // actually slower than this approach, which replaces surrogate pairs with\n        // single-byte characters.\n        return string.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, \"_\").length;\n    }\n    // -- Public Methods ---------------------------------------------------------\n    /**\n  Advances the scanner by the given number of characters, stopping if the end of\n  the string is reached.\n\n  @param {number} [count]\n  */ advance(count = 1) {\n        this.charIndex = Math.min(this.charCount, this.charIndex + count);\n    }\n    /**\n  Consumes and returns the given number of characters if possible, advancing the\n  scanner and stopping if the end of the string is reached.\n\n  If no characters could be consumed, an empty string will be returned.\n\n  @param {number} [count]\n  @returns {string}\n  */ consume(count = 1) {\n        let chars = this.peek(count);\n        this.advance(count);\n        return chars;\n    }\n    /**\n  Consumes a match for the given sticky regex, advances the scanner, updates the\n  `lastIndex` property of the regex, and returns the matching string.\n\n  The regex must have a sticky flag (\"y\") so that its `lastIndex` prop can be\n  used to anchor the match at the current scanner position.\n\n  Returns the consumed string, or an empty string if nothing was consumed.\n\n  @param {RegExp} regex\n  @returns {string}\n  */ consumeMatch(regex) {\n        if (!regex.sticky) {\n            throw new Error('`regex` must have a sticky flag (\"y\")');\n        }\n        regex.lastIndex = this.charsToBytes[this.charIndex];\n        let result = regex.exec(this.string);\n        if (result === null) {\n            return emptyString;\n        }\n        let match = result[0];\n        this.advance(this._charLength(match));\n        return match;\n    }\n    /**\n  Consumes and returns all characters for which the given function returns a\n  truthy value, stopping on the first falsy return value or if the end of the\n  input is reached.\n\n  @param {(char: string) => boolean} fn\n  @returns {string}\n  */ consumeMatchFn(fn) {\n        let startIndex = this.charIndex;\n        while(!this.isEnd && fn(this.peek())){\n            this.advance();\n        }\n        return this.charIndex > startIndex ? this.string.slice(this.charsToBytes[startIndex], this.charsToBytes[this.charIndex]) : emptyString;\n    }\n    /**\n  Consumes the given string if it exists at the current character index, and\n  advances the scanner.\n\n  If the given string doesn't exist at the current character index, an empty\n  string will be returned and the scanner will not be advanced.\n\n  @param {string} stringToConsume\n  @returns {string}\n  */ consumeString(stringToConsume) {\n        if (this.consumeStringFast(stringToConsume)) {\n            return stringToConsume;\n        }\n        if (!this.multiByteMode) {\n            return emptyString;\n        }\n        let { length } = stringToConsume;\n        let charLengthToMatch = this._charLength(stringToConsume);\n        if (charLengthToMatch !== length && stringToConsume === this.peek(charLengthToMatch)) {\n            this.advance(charLengthToMatch);\n            return stringToConsume;\n        }\n        return emptyString;\n    }\n    /**\n   * Does the same thing as `consumeString()`, but doesn't support consuming\n   * multibyte characters. This can be much faster if you only need to match\n   * single byte characters.\n   *\n   * @param {string} stringToConsume\n   * @returns {string}\n   */ consumeStringFast(stringToConsume) {\n        if (this.peek() === stringToConsume[0]) {\n            let { length } = stringToConsume;\n            if (length === 1) {\n                this.advance();\n                return stringToConsume;\n            }\n            if (this.peek(length) === stringToConsume) {\n                this.advance(length);\n                return stringToConsume;\n            }\n        }\n        return emptyString;\n    }\n    /**\n  Consumes characters until the given global regex is matched, advancing the\n  scanner up to (but not beyond) the beginning of the match and updating the\n  `lastIndex` property of the regex.\n\n  The regex must have a global flag (\"g\") so that its `lastIndex` prop can be\n  used to begin the search at the current scanner position.\n\n  Returns the consumed string, or an empty string if nothing was consumed.\n\n  @param {RegExp} regex\n  @returns {string}\n  */ consumeUntilMatch(regex) {\n        if (!regex.global) {\n            throw new Error('`regex` must have a global flag (\"g\")');\n        }\n        let byteIndex = this.charsToBytes[this.charIndex];\n        regex.lastIndex = byteIndex;\n        let match = regex.exec(this.string);\n        if (match === null || match.index === byteIndex) {\n            return emptyString;\n        }\n        let result = this.string.slice(byteIndex, match.index);\n        this.advance(this._charLength(result));\n        return result;\n    }\n    /**\n  Consumes characters until the given string is found, advancing the scanner up\n  to (but not beyond) that point.\n\n  Returns the consumed string, or an empty string if nothing was consumed.\n\n  @param {string} searchString\n  @returns {string}\n  */ consumeUntilString(searchString) {\n        let { charIndex, charsToBytes, string } = this;\n        let byteIndex = charsToBytes[charIndex];\n        let matchByteIndex = string.indexOf(searchString, byteIndex);\n        if (matchByteIndex <= 0) {\n            return emptyString;\n        }\n        let result = string.slice(byteIndex, matchByteIndex);\n        this.advance(this._charLength(result));\n        return result;\n    }\n    /**\n  Returns the given number of characters starting at the current character\n  index, without advancing the scanner and without exceeding the end of the\n  input string.\n\n  @param {number} [count]\n  @returns {string}\n  */ peek(count = 1) {\n        // Inlining this comparison instead of checking `this.isEnd` improves perf\n        // slightly since `peek()` is called so frequently.\n        if (this.charIndex >= this.charCount) {\n            return emptyString;\n        }\n        if (count === 1) {\n            return this.chars[this.charIndex];\n        }\n        let { charsToBytes, charIndex } = this;\n        return this.string.slice(charsToBytes[charIndex], charsToBytes[charIndex + count]);\n    }\n    /**\n  Resets the scanner position to the given character _index_, or to the start of\n  the input string if no index is given.\n\n  If _index_ is negative, the scanner position will be moved backward by that\n  many characters, stopping if the beginning of the string is reached.\n\n  @param {number} [index]\n  */ reset(index = 0) {\n        this.charIndex = index >= 0 ? Math.min(this.charCount, index) : Math.max(0, this.charIndex + index);\n    }\n}\nmodule.exports = StringScanner;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJncm92ZS9wYXJzZS14bWwvc3JjL2xpYi9TdHJpbmdTY2FubmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsY0FBYztBQUVwQjs7QUFFQSxHQUNBLE1BQU1DO0lBQ0o7O0VBRUEsR0FDQUMsWUFBWUMsTUFBTSxDQUFFO1FBQ2xCLHFCQUFxQixHQUNyQixJQUFJLENBQUNDLEtBQUssR0FBRztlQUFLRDtTQUFRO1FBRTFCLG1CQUFtQixHQUNuQixJQUFJLENBQUNFLFNBQVMsR0FBRyxJQUFJLENBQUNELEtBQUssQ0FBQ0UsTUFBTTtRQUVsQyxtQkFBbUIsR0FDbkIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFFakIscUJBQXFCLEdBQ3JCLElBQUksQ0FBQ0MsWUFBWSxHQUFHLElBQUlDLE1BQU0sSUFBSSxDQUFDSixTQUFTO1FBRTVDLG9CQUFvQixHQUNwQixJQUFJLENBQUNLLGFBQWEsR0FBRztRQUVyQixtQkFBbUIsR0FDbkIsSUFBSSxDQUFDUCxNQUFNLEdBQUdBO1FBRWQsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLFNBQVMsRUFBRUcsWUFBWSxFQUFFLEdBQUcsSUFBSTtRQUU3QyxJQUFJSCxjQUFjRixPQUFPRyxNQUFNLEVBQUU7WUFDL0IseUVBQXlFO1lBQ3pFLGlDQUFpQztZQUNqQyxJQUFLLElBQUlLLElBQUksR0FBR0EsSUFBSU4sV0FBVyxFQUFFTSxFQUFHO2dCQUNsQ0gsWUFBWSxDQUFDRyxFQUFFLEdBQUdBO1lBQ3BCO1FBQ0YsT0FBTztZQUNMLHlFQUF5RTtZQUN6RSx3RUFBd0U7WUFDeEUsMEJBQTBCO1lBQzFCLElBQUssSUFBSUMsWUFBWSxHQUFHTCxZQUFZLEdBQUdBLFlBQVlGLFdBQVcsRUFBRUUsVUFBVztnQkFDekVDLFlBQVksQ0FBQ0QsVUFBVSxHQUFHSztnQkFDMUJBLGFBQWFSLEtBQUssQ0FBQ0csVUFBVSxDQUFDRCxNQUFNO1lBQ3RDO1lBRUEsSUFBSSxDQUFDSSxhQUFhLEdBQUc7UUFD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LElBQUksQ0FBQ0YsV0FBVyxDQUFDYTtRQUM5QixPQUFPQTtJQUNUO0lBRUE7Ozs7Ozs7RUFPQSxHQUNBTixLQUFLSixRQUFRLENBQUMsRUFBRTtRQUNkLDBFQUEwRTtRQUMxRSxtREFBbUQ7UUFDbkQsSUFBSSxJQUFJLENBQUNWLFNBQVMsSUFBSSxJQUFJLENBQUNGLFNBQVMsRUFBRTtZQUNwQyxPQUFPTDtRQUNUO1FBRUEsSUFBSWlCLFVBQVUsR0FBRztZQUNmLE9BQU8sSUFBSSxDQUFDYixLQUFLLENBQUMsSUFBSSxDQUFDRyxTQUFTLENBQUM7UUFDbkM7UUFFQSxJQUFJLEVBQUVDLFlBQVksRUFBRUQsU0FBUyxFQUFFLEdBQUcsSUFBSTtRQUN0QyxPQUFPLElBQUksQ0FBQ0osTUFBTSxDQUFDOEIsS0FBSyxDQUFDekIsWUFBWSxDQUFDRCxVQUFVLEVBQUVDLFlBQVksQ0FBQ0QsWUFBWVUsTUFBTTtJQUNuRjtJQUVBOzs7Ozs7OztFQVFBLEdBQ0E0QixNQUFNTCxRQUFRLENBQUMsRUFBRTtRQUNmLElBQUksQ0FBQ2pDLFNBQVMsR0FBR2lDLFNBQVMsSUFDdEJ0QixLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDZCxTQUFTLEVBQUVtQyxTQUN6QnRCLEtBQUs0QixHQUFHLENBQUMsR0FBRyxJQUFJLENBQUN2QyxTQUFTLEdBQUdpQztJQUNuQztBQUNGO0FBRUFPLE9BQU9DLE9BQU8sR0FBRy9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGljdGFjdG9lLy4vbm9kZV9tb2R1bGVzL0ByZ3JvdmUvcGFyc2UteG1sL3NyYy9saWIvU3RyaW5nU2Nhbm5lci5qcz9mM2E0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZW1wdHlTdHJpbmcgPSAnJztcblxuLyoqXG5AcHJpdmF0ZVxuKi9cbmNsYXNzIFN0cmluZ1NjYW5uZXIge1xuICAvKipcbiAgQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAqL1xuICBjb25zdHJ1Y3RvcihzdHJpbmcpIHtcbiAgICAvKiogQHR5cGUge3N0cmluZ1tdfSAqL1xuICAgIHRoaXMuY2hhcnMgPSBbIC4uLnN0cmluZyBdO1xuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5jaGFyQ291bnQgPSB0aGlzLmNoYXJzLmxlbmd0aDtcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuY2hhckluZGV4ID0gMDtcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyW119ICovXG4gICAgdGhpcy5jaGFyc1RvQnl0ZXMgPSBuZXcgQXJyYXkodGhpcy5jaGFyQ291bnQpO1xuXG4gICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgIHRoaXMubXVsdGlCeXRlTW9kZSA9IGZhbHNlO1xuXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG5cbiAgICBsZXQgeyBjaGFycywgY2hhckNvdW50LCBjaGFyc1RvQnl0ZXMgfSA9IHRoaXM7XG5cbiAgICBpZiAoY2hhckNvdW50ID09PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAvLyBUaGVyZSBhcmUgbm8gbXVsdGlieXRlIGNoYXJhY3RlcnMgaW4gdGhlIGlucHV0IHN0cmluZywgc28gY2hhciBpbmRleGVzXG4gICAgICAvLyBhbmQgYnl0ZSBpbmRleGVzIGFyZSB0aGUgc2FtZS5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhckNvdW50OyArK2kpIHtcbiAgICAgICAgY2hhcnNUb0J5dGVzW2ldID0gaTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ3JlYXRlIGEgbWFwcGluZyBvZiBjaGFyYWN0ZXIgaW5kZXhlcyB0byBieXRlIGluZGV4ZXMuIFdoZW4gdGhlIHN0cmluZ1xuICAgICAgLy8gY29udGFpbnMgbXVsdGlieXRlIGNoYXJhY3RlcnMsIGEgYnl0ZSBpbmRleCBtYXkgbm90IG5lY2Vzc2FyaWx5IGFsaWduXG4gICAgICAvLyB3aXRoIGEgY2hhcmFjdGVyIGluZGV4LlxuICAgICAgZm9yIChsZXQgYnl0ZUluZGV4ID0gMCwgY2hhckluZGV4ID0gMDsgY2hhckluZGV4IDwgY2hhckNvdW50OyArK2NoYXJJbmRleCkge1xuICAgICAgICBjaGFyc1RvQnl0ZXNbY2hhckluZGV4XSA9IGJ5dGVJbmRleDtcbiAgICAgICAgYnl0ZUluZGV4ICs9IGNoYXJzW2NoYXJJbmRleF0ubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm11bHRpQnl0ZU1vZGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICBXaGV0aGVyIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpbmRleCBpcyBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBzdHJpbmcuXG5cbiAgQHR5cGUge2Jvb2xlYW59XG4gICovXG4gIGdldCBpc0VuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFySW5kZXggPj0gdGhpcy5jaGFyQ291bnQ7XG4gIH1cblxuICAvLyAtLSBQcm90ZWN0ZWQgTWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIF9zdHJpbmdfLCB3aGljaCBtYXkgZGlmZmVyIGZyb21cbiAgdGhlIGJ5dGUgbGVuZ3RoIGlmIHRoZSBzdHJpbmcgY29udGFpbnMgbXVsdGlieXRlIGNoYXJhY3RlcnMuXG5cbiAgQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICBAcmV0dXJucyB7bnVtYmVyfVxuICAqL1xuICBfY2hhckxlbmd0aChzdHJpbmcpIHtcbiAgICBsZXQgeyBsZW5ndGggfSA9IHN0cmluZztcblxuICAgIGlmIChsZW5ndGggPCAyIHx8ICF0aGlzLm11bHRpQnl0ZU1vZGUpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gV2UgY291bGQgZ2V0IHRoZSBjaGFyIGxlbmd0aCB3aXRoIGBbIC4uLnN0cmluZyBdLmxlbmd0aGAsIGJ1dCB0aGF0J3NcbiAgICAvLyBhY3R1YWxseSBzbG93ZXIgdGhhbiB0aGlzIGFwcHJvYWNoLCB3aGljaCByZXBsYWNlcyBzdXJyb2dhdGUgcGFpcnMgd2l0aFxuICAgIC8vIHNpbmdsZS1ieXRlIGNoYXJhY3RlcnMuXG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2csICdfJykubGVuZ3RoO1xuICB9XG5cbiAgLy8gLS0gUHVibGljIE1ldGhvZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gIEFkdmFuY2VzIHRoZSBzY2FubmVyIGJ5IHRoZSBnaXZlbiBudW1iZXIgb2YgY2hhcmFjdGVycywgc3RvcHBpbmcgaWYgdGhlIGVuZCBvZlxuICB0aGUgc3RyaW5nIGlzIHJlYWNoZWQuXG5cbiAgQHBhcmFtIHtudW1iZXJ9IFtjb3VudF1cbiAgKi9cbiAgYWR2YW5jZShjb3VudCA9IDEpIHtcbiAgICB0aGlzLmNoYXJJbmRleCA9IE1hdGgubWluKHRoaXMuY2hhckNvdW50LCB0aGlzLmNoYXJJbmRleCArIGNvdW50KTtcbiAgfVxuXG4gIC8qKlxuICBDb25zdW1lcyBhbmQgcmV0dXJucyB0aGUgZ2l2ZW4gbnVtYmVyIG9mIGNoYXJhY3RlcnMgaWYgcG9zc2libGUsIGFkdmFuY2luZyB0aGVcbiAgc2Nhbm5lciBhbmQgc3RvcHBpbmcgaWYgdGhlIGVuZCBvZiB0aGUgc3RyaW5nIGlzIHJlYWNoZWQuXG5cbiAgSWYgbm8gY2hhcmFjdGVycyBjb3VsZCBiZSBjb25zdW1lZCwgYW4gZW1wdHkgc3RyaW5nIHdpbGwgYmUgcmV0dXJuZWQuXG5cbiAgQHBhcmFtIHtudW1iZXJ9IFtjb3VudF1cbiAgQHJldHVybnMge3N0cmluZ31cbiAgKi9cbiAgY29uc3VtZShjb3VudCA9IDEpIHtcbiAgICBsZXQgY2hhcnMgPSB0aGlzLnBlZWsoY291bnQpO1xuICAgIHRoaXMuYWR2YW5jZShjb3VudCk7XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9XG5cbiAgLyoqXG4gIENvbnN1bWVzIGEgbWF0Y2ggZm9yIHRoZSBnaXZlbiBzdGlja3kgcmVnZXgsIGFkdmFuY2VzIHRoZSBzY2FubmVyLCB1cGRhdGVzIHRoZVxuICBgbGFzdEluZGV4YCBwcm9wZXJ0eSBvZiB0aGUgcmVnZXgsIGFuZCByZXR1cm5zIHRoZSBtYXRjaGluZyBzdHJpbmcuXG5cbiAgVGhlIHJlZ2V4IG11c3QgaGF2ZSBhIHN0aWNreSBmbGFnIChcInlcIikgc28gdGhhdCBpdHMgYGxhc3RJbmRleGAgcHJvcCBjYW4gYmVcbiAgdXNlZCB0byBhbmNob3IgdGhlIG1hdGNoIGF0IHRoZSBjdXJyZW50IHNjYW5uZXIgcG9zaXRpb24uXG5cbiAgUmV0dXJucyB0aGUgY29uc3VtZWQgc3RyaW5nLCBvciBhbiBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgY29uc3VtZWQuXG5cbiAgQHBhcmFtIHtSZWdFeHB9IHJlZ2V4XG4gIEByZXR1cm5zIHtzdHJpbmd9XG4gICovXG4gIGNvbnN1bWVNYXRjaChyZWdleCkge1xuICAgIGlmICghcmVnZXguc3RpY2t5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ByZWdleGAgbXVzdCBoYXZlIGEgc3RpY2t5IGZsYWcgKFwieVwiKScpO1xuICAgIH1cblxuICAgIHJlZ2V4Lmxhc3RJbmRleCA9IHRoaXMuY2hhcnNUb0J5dGVzW3RoaXMuY2hhckluZGV4XTtcblxuICAgIGxldCByZXN1bHQgPSByZWdleC5leGVjKHRoaXMuc3RyaW5nKTtcblxuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbXB0eVN0cmluZztcbiAgICB9XG5cbiAgICBsZXQgbWF0Y2ggPSByZXN1bHRbMF07XG4gICAgdGhpcy5hZHZhbmNlKHRoaXMuX2NoYXJMZW5ndGgobWF0Y2gpKTtcbiAgICByZXR1cm4gbWF0Y2g7XG4gIH1cblxuICAvKipcbiAgQ29uc3VtZXMgYW5kIHJldHVybnMgYWxsIGNoYXJhY3RlcnMgZm9yIHdoaWNoIHRoZSBnaXZlbiBmdW5jdGlvbiByZXR1cm5zIGFcbiAgdHJ1dGh5IHZhbHVlLCBzdG9wcGluZyBvbiB0aGUgZmlyc3QgZmFsc3kgcmV0dXJuIHZhbHVlIG9yIGlmIHRoZSBlbmQgb2YgdGhlXG4gIGlucHV0IGlzIHJlYWNoZWQuXG5cbiAgQHBhcmFtIHsoY2hhcjogc3RyaW5nKSA9PiBib29sZWFufSBmblxuICBAcmV0dXJucyB7c3RyaW5nfVxuICAqL1xuICBjb25zdW1lTWF0Y2hGbihmbikge1xuICAgIGxldCBzdGFydEluZGV4ID0gdGhpcy5jaGFySW5kZXg7XG5cbiAgICB3aGlsZSAoIXRoaXMuaXNFbmQgJiYgZm4odGhpcy5wZWVrKCkpKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGFySW5kZXggPiBzdGFydEluZGV4XG4gICAgICA/IHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMuY2hhcnNUb0J5dGVzW3N0YXJ0SW5kZXhdLCB0aGlzLmNoYXJzVG9CeXRlc1t0aGlzLmNoYXJJbmRleF0pXG4gICAgICA6IGVtcHR5U3RyaW5nO1xuICB9XG5cbiAgLyoqXG4gIENvbnN1bWVzIHRoZSBnaXZlbiBzdHJpbmcgaWYgaXQgZXhpc3RzIGF0IHRoZSBjdXJyZW50IGNoYXJhY3RlciBpbmRleCwgYW5kXG4gIGFkdmFuY2VzIHRoZSBzY2FubmVyLlxuXG4gIElmIHRoZSBnaXZlbiBzdHJpbmcgZG9lc24ndCBleGlzdCBhdCB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaW5kZXgsIGFuIGVtcHR5XG4gIHN0cmluZyB3aWxsIGJlIHJldHVybmVkIGFuZCB0aGUgc2Nhbm5lciB3aWxsIG5vdCBiZSBhZHZhbmNlZC5cblxuICBAcGFyYW0ge3N0cmluZ30gc3RyaW5nVG9Db25zdW1lXG4gIEByZXR1cm5zIHtzdHJpbmd9XG4gICovXG4gIGNvbnN1bWVTdHJpbmcoc3RyaW5nVG9Db25zdW1lKSB7XG4gICAgaWYgKHRoaXMuY29uc3VtZVN0cmluZ0Zhc3Qoc3RyaW5nVG9Db25zdW1lKSkge1xuICAgICAgcmV0dXJuIHN0cmluZ1RvQ29uc3VtZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubXVsdGlCeXRlTW9kZSkge1xuICAgICAgcmV0dXJuIGVtcHR5U3RyaW5nO1xuICAgIH1cblxuICAgIGxldCB7IGxlbmd0aCB9ID0gc3RyaW5nVG9Db25zdW1lO1xuICAgIGxldCBjaGFyTGVuZ3RoVG9NYXRjaCA9IHRoaXMuX2NoYXJMZW5ndGgoc3RyaW5nVG9Db25zdW1lKTtcblxuICAgIGlmIChjaGFyTGVuZ3RoVG9NYXRjaCAhPT0gbGVuZ3RoXG4gICAgICAgICYmIHN0cmluZ1RvQ29uc3VtZSA9PT0gdGhpcy5wZWVrKGNoYXJMZW5ndGhUb01hdGNoKSkge1xuXG4gICAgICB0aGlzLmFkdmFuY2UoY2hhckxlbmd0aFRvTWF0Y2gpO1xuICAgICAgcmV0dXJuIHN0cmluZ1RvQ29uc3VtZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW1wdHlTdHJpbmc7XG4gIH1cblxuICAvKipcbiAgICogRG9lcyB0aGUgc2FtZSB0aGluZyBhcyBgY29uc3VtZVN0cmluZygpYCwgYnV0IGRvZXNuJ3Qgc3VwcG9ydCBjb25zdW1pbmdcbiAgICogbXVsdGlieXRlIGNoYXJhY3RlcnMuIFRoaXMgY2FuIGJlIG11Y2ggZmFzdGVyIGlmIHlvdSBvbmx5IG5lZWQgdG8gbWF0Y2hcbiAgICogc2luZ2xlIGJ5dGUgY2hhcmFjdGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1RvQ29uc3VtZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgY29uc3VtZVN0cmluZ0Zhc3Qoc3RyaW5nVG9Db25zdW1lKSB7XG4gICAgaWYgKHRoaXMucGVlaygpID09PSBzdHJpbmdUb0NvbnN1bWVbMF0pIHtcbiAgICAgIGxldCB7IGxlbmd0aCB9ID0gc3RyaW5nVG9Db25zdW1lO1xuXG4gICAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9Db25zdW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wZWVrKGxlbmd0aCkgPT09IHN0cmluZ1RvQ29uc3VtZSkge1xuICAgICAgICB0aGlzLmFkdmFuY2UobGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1RvQ29uc3VtZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZW1wdHlTdHJpbmc7XG4gIH1cblxuICAvKipcbiAgQ29uc3VtZXMgY2hhcmFjdGVycyB1bnRpbCB0aGUgZ2l2ZW4gZ2xvYmFsIHJlZ2V4IGlzIG1hdGNoZWQsIGFkdmFuY2luZyB0aGVcbiAgc2Nhbm5lciB1cCB0byAoYnV0IG5vdCBiZXlvbmQpIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG1hdGNoIGFuZCB1cGRhdGluZyB0aGVcbiAgYGxhc3RJbmRleGAgcHJvcGVydHkgb2YgdGhlIHJlZ2V4LlxuXG4gIFRoZSByZWdleCBtdXN0IGhhdmUgYSBnbG9iYWwgZmxhZyAoXCJnXCIpIHNvIHRoYXQgaXRzIGBsYXN0SW5kZXhgIHByb3AgY2FuIGJlXG4gIHVzZWQgdG8gYmVnaW4gdGhlIHNlYXJjaCBhdCB0aGUgY3VycmVudCBzY2FubmVyIHBvc2l0aW9uLlxuXG4gIFJldHVybnMgdGhlIGNvbnN1bWVkIHN0cmluZywgb3IgYW4gZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIGNvbnN1bWVkLlxuXG4gIEBwYXJhbSB7UmVnRXhwfSByZWdleFxuICBAcmV0dXJucyB7c3RyaW5nfVxuICAqL1xuICBjb25zdW1lVW50aWxNYXRjaChyZWdleCkge1xuICAgIGlmICghcmVnZXguZ2xvYmFsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ByZWdleGAgbXVzdCBoYXZlIGEgZ2xvYmFsIGZsYWcgKFwiZ1wiKScpO1xuICAgIH1cblxuICAgIGxldCBieXRlSW5kZXggPSB0aGlzLmNoYXJzVG9CeXRlc1t0aGlzLmNoYXJJbmRleF07XG4gICAgcmVnZXgubGFzdEluZGV4ID0gYnl0ZUluZGV4O1xuXG4gICAgbGV0IG1hdGNoID0gcmVnZXguZXhlYyh0aGlzLnN0cmluZyk7XG5cbiAgICBpZiAobWF0Y2ggPT09IG51bGwgfHwgbWF0Y2guaW5kZXggPT09IGJ5dGVJbmRleCkge1xuICAgICAgcmV0dXJuIGVtcHR5U3RyaW5nO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSB0aGlzLnN0cmluZy5zbGljZShieXRlSW5kZXgsIG1hdGNoLmluZGV4KTtcbiAgICB0aGlzLmFkdmFuY2UodGhpcy5fY2hhckxlbmd0aChyZXN1bHQpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gIENvbnN1bWVzIGNoYXJhY3RlcnMgdW50aWwgdGhlIGdpdmVuIHN0cmluZyBpcyBmb3VuZCwgYWR2YW5jaW5nIHRoZSBzY2FubmVyIHVwXG4gIHRvIChidXQgbm90IGJleW9uZCkgdGhhdCBwb2ludC5cblxuICBSZXR1cm5zIHRoZSBjb25zdW1lZCBzdHJpbmcsIG9yIGFuIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBjb25zdW1lZC5cblxuICBAcGFyYW0ge3N0cmluZ30gc2VhcmNoU3RyaW5nXG4gIEByZXR1cm5zIHtzdHJpbmd9XG4gICovXG4gIGNvbnN1bWVVbnRpbFN0cmluZyhzZWFyY2hTdHJpbmcpIHtcbiAgICBsZXQgeyBjaGFySW5kZXgsIGNoYXJzVG9CeXRlcywgc3RyaW5nIH0gPSB0aGlzO1xuICAgIGxldCBieXRlSW5kZXggPSBjaGFyc1RvQnl0ZXNbY2hhckluZGV4XTtcbiAgICBsZXQgbWF0Y2hCeXRlSW5kZXggPSBzdHJpbmcuaW5kZXhPZihzZWFyY2hTdHJpbmcsIGJ5dGVJbmRleCk7XG5cbiAgICBpZiAobWF0Y2hCeXRlSW5kZXggPD0gMCkge1xuICAgICAgcmV0dXJuIGVtcHR5U3RyaW5nO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSBzdHJpbmcuc2xpY2UoYnl0ZUluZGV4LCBtYXRjaEJ5dGVJbmRleCk7XG4gICAgdGhpcy5hZHZhbmNlKHRoaXMuX2NoYXJMZW5ndGgocmVzdWx0KSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICBSZXR1cm5zIHRoZSBnaXZlbiBudW1iZXIgb2YgY2hhcmFjdGVycyBzdGFydGluZyBhdCB0aGUgY3VycmVudCBjaGFyYWN0ZXJcbiAgaW5kZXgsIHdpdGhvdXQgYWR2YW5jaW5nIHRoZSBzY2FubmVyIGFuZCB3aXRob3V0IGV4Y2VlZGluZyB0aGUgZW5kIG9mIHRoZVxuICBpbnB1dCBzdHJpbmcuXG5cbiAgQHBhcmFtIHtudW1iZXJ9IFtjb3VudF1cbiAgQHJldHVybnMge3N0cmluZ31cbiAgKi9cbiAgcGVlayhjb3VudCA9IDEpIHtcbiAgICAvLyBJbmxpbmluZyB0aGlzIGNvbXBhcmlzb24gaW5zdGVhZCBvZiBjaGVja2luZyBgdGhpcy5pc0VuZGAgaW1wcm92ZXMgcGVyZlxuICAgIC8vIHNsaWdodGx5IHNpbmNlIGBwZWVrKClgIGlzIGNhbGxlZCBzbyBmcmVxdWVudGx5LlxuICAgIGlmICh0aGlzLmNoYXJJbmRleCA+PSB0aGlzLmNoYXJDb3VudCkge1xuICAgICAgcmV0dXJuIGVtcHR5U3RyaW5nO1xuICAgIH1cblxuICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hhcnNbdGhpcy5jaGFySW5kZXhdO1xuICAgIH1cblxuICAgIGxldCB7IGNoYXJzVG9CeXRlcywgY2hhckluZGV4IH0gPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLnN0cmluZy5zbGljZShjaGFyc1RvQnl0ZXNbY2hhckluZGV4XSwgY2hhcnNUb0J5dGVzW2NoYXJJbmRleCArIGNvdW50XSk7XG4gIH1cblxuICAvKipcbiAgUmVzZXRzIHRoZSBzY2FubmVyIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiBjaGFyYWN0ZXIgX2luZGV4Xywgb3IgdG8gdGhlIHN0YXJ0IG9mXG4gIHRoZSBpbnB1dCBzdHJpbmcgaWYgbm8gaW5kZXggaXMgZ2l2ZW4uXG5cbiAgSWYgX2luZGV4XyBpcyBuZWdhdGl2ZSwgdGhlIHNjYW5uZXIgcG9zaXRpb24gd2lsbCBiZSBtb3ZlZCBiYWNrd2FyZCBieSB0aGF0XG4gIG1hbnkgY2hhcmFjdGVycywgc3RvcHBpbmcgaWYgdGhlIGJlZ2lubmluZyBvZiB0aGUgc3RyaW5nIGlzIHJlYWNoZWQuXG5cbiAgQHBhcmFtIHtudW1iZXJ9IFtpbmRleF1cbiAgKi9cbiAgcmVzZXQoaW5kZXggPSAwKSB7XG4gICAgdGhpcy5jaGFySW5kZXggPSBpbmRleCA+PSAwXG4gICAgICA/IE1hdGgubWluKHRoaXMuY2hhckNvdW50LCBpbmRleClcbiAgICAgIDogTWF0aC5tYXgoMCwgdGhpcy5jaGFySW5kZXggKyBpbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJpbmdTY2FubmVyO1xuIl0sIm5hbWVzIjpbImVtcHR5U3RyaW5nIiwiU3RyaW5nU2Nhbm5lciIsImNvbnN0cnVjdG9yIiwic3RyaW5nIiwiY2hhcnMiLCJjaGFyQ291bnQiLCJsZW5ndGgiLCJjaGFySW5kZXgiLCJjaGFyc1RvQnl0ZXMiLCJBcnJheSIsIm11bHRpQnl0ZU1vZGUiLCJpIiwiYnl0ZUluZGV4IiwiaXNFbmQiLCJfY2hhckxlbmd0aCIsInJlcGxhY2UiLCJhZHZhbmNlIiwiY291bnQiLCJNYXRoIiwibWluIiwiY29uc3VtZSIsInBlZWsiLCJjb25zdW1lTWF0Y2giLCJyZWdleCIsInN0aWNreSIsIkVycm9yIiwibGFzdEluZGV4IiwicmVzdWx0IiwiZXhlYyIsIm1hdGNoIiwiY29uc3VtZU1hdGNoRm4iLCJmbiIsInN0YXJ0SW5kZXgiLCJzbGljZSIsImNvbnN1bWVTdHJpbmciLCJzdHJpbmdUb0NvbnN1bWUiLCJjb25zdW1lU3RyaW5nRmFzdCIsImNoYXJMZW5ndGhUb01hdGNoIiwiY29uc3VtZVVudGlsTWF0Y2giLCJnbG9iYWwiLCJpbmRleCIsImNvbnN1bWVVbnRpbFN0cmluZyIsInNlYXJjaFN0cmluZyIsIm1hdGNoQnl0ZUluZGV4IiwiaW5kZXhPZiIsInJlc2V0IiwibWF4IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@rgrove/parse-xml/src/lib/StringScanner.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlCdata.js":
/*!************************************************************!*\
  !*** ./node_modules/@rgrove/parse-xml/src/lib/XmlCdata.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst XmlNode = __webpack_require__(/*! ./XmlNode */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlNode.js\");\nconst XmlText = __webpack_require__(/*! ./XmlText */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlText.js\");\n/**\nA CDATA section within an XML document.\n\n@public\n*/ class XmlCdata extends XmlText {\n    get type() {\n        return XmlNode.TYPE_CDATA;\n    }\n}\nmodule.exports = XmlCdata;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJncm92ZS9wYXJzZS14bWwvc3JjL2xpYi9YbWxDZGF0YS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFVBQVVDLG1CQUFPQSxDQUFDO0FBQ3hCLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDO0FBRXhCOzs7O0FBSUEsR0FDQSxNQUFNRSxpQkFBaUJEO0lBQ3JCLElBQUlFLE9BQU87UUFDVCxPQUFPSixRQUFRSyxVQUFVO0lBQzNCO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHSiIsInNvdXJjZXMiOlsid2VicGFjazovL3RpY3RhY3RvZS8uL25vZGVfbW9kdWxlcy9Acmdyb3ZlL3BhcnNlLXhtbC9zcmMvbGliL1htbENkYXRhLmpzPzQ0ODMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBYbWxOb2RlID0gcmVxdWlyZSgnLi9YbWxOb2RlJyk7XG5jb25zdCBYbWxUZXh0ID0gcmVxdWlyZSgnLi9YbWxUZXh0Jyk7XG5cbi8qKlxuQSBDREFUQSBzZWN0aW9uIHdpdGhpbiBhbiBYTUwgZG9jdW1lbnQuXG5cbkBwdWJsaWNcbiovXG5jbGFzcyBYbWxDZGF0YSBleHRlbmRzIFhtbFRleHQge1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gWG1sTm9kZS5UWVBFX0NEQVRBO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWG1sQ2RhdGE7XG4iXSwibmFtZXMiOlsiWG1sTm9kZSIsInJlcXVpcmUiLCJYbWxUZXh0IiwiWG1sQ2RhdGEiLCJ0eXBlIiwiVFlQRV9DREFUQSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlCdata.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlComment.js":
/*!**************************************************************!*\
  !*** ./node_modules/@rgrove/parse-xml/src/lib/XmlComment.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst XmlNode = __webpack_require__(/*! ./XmlNode */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlNode.js\");\n/**\nA comment within an XML document.\n\n@public\n*/ class XmlComment extends XmlNode {\n    /**\n  @param {string} [content]\n  */ constructor(content = \"\"){\n        super();\n        /**\n    Content of this comment.\n\n    @type {string}\n    @public\n    */ this.content = content;\n    }\n    get type() {\n        return XmlNode.TYPE_COMMENT;\n    }\n    toJSON() {\n        return Object.assign(XmlNode.prototype.toJSON.call(this), {\n            content: this.content\n        });\n    }\n}\nmodule.exports = XmlComment;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJncm92ZS9wYXJzZS14bWwvc3JjL2xpYi9YbWxDb21tZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsVUFBVUMsbUJBQU9BLENBQUM7QUFFeEI7Ozs7QUFJQSxHQUNBLE1BQU1DLG1CQUFtQkY7SUFDdkI7O0VBRUEsR0FDQUcsWUFBWUMsVUFBVSxFQUFFLENBQUU7UUFDeEIsS0FBSztRQUVMOzs7OztJQUtBLEdBQ0EsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ2pCO0lBRUEsSUFBSUMsT0FBTztRQUNULE9BQU9MLFFBQVFNLFlBQVk7SUFDN0I7SUFFQUMsU0FBUztRQUNQLE9BQU9DLE9BQU9DLE1BQU0sQ0FBQ1QsUUFBUVUsU0FBUyxDQUFDSCxNQUFNLENBQUNJLElBQUksQ0FBQyxJQUFJLEdBQUc7WUFDeERQLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1FBQ3ZCO0lBQ0Y7QUFDRjtBQUVBUSxPQUFPQyxPQUFPLEdBQUdYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGljdGFjdG9lLy4vbm9kZV9tb2R1bGVzL0ByZ3JvdmUvcGFyc2UteG1sL3NyYy9saWIvWG1sQ29tbWVudC5qcz9kNWNhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgWG1sTm9kZSA9IHJlcXVpcmUoJy4vWG1sTm9kZScpO1xuXG4vKipcbkEgY29tbWVudCB3aXRoaW4gYW4gWE1MIGRvY3VtZW50LlxuXG5AcHVibGljXG4qL1xuY2xhc3MgWG1sQ29tbWVudCBleHRlbmRzIFhtbE5vZGUge1xuICAvKipcbiAgQHBhcmFtIHtzdHJpbmd9IFtjb250ZW50XVxuICAqL1xuICBjb25zdHJ1Y3Rvcihjb250ZW50ID0gJycpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgQ29udGVudCBvZiB0aGlzIGNvbW1lbnQuXG5cbiAgICBAdHlwZSB7c3RyaW5nfVxuICAgIEBwdWJsaWNcbiAgICAqL1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gWG1sTm9kZS5UWVBFX0NPTU1FTlQ7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oWG1sTm9kZS5wcm90b3R5cGUudG9KU09OLmNhbGwodGhpcyksIHtcbiAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudFxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWG1sQ29tbWVudDtcbiJdLCJuYW1lcyI6WyJYbWxOb2RlIiwicmVxdWlyZSIsIlhtbENvbW1lbnQiLCJjb25zdHJ1Y3RvciIsImNvbnRlbnQiLCJ0eXBlIiwiVFlQRV9DT01NRU5UIiwidG9KU09OIiwiT2JqZWN0IiwiYXNzaWduIiwicHJvdG90eXBlIiwiY2FsbCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlComment.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlDocument.js":
/*!***************************************************************!*\
  !*** ./node_modules/@rgrove/parse-xml/src/lib/XmlDocument.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst XmlElement = __webpack_require__(/*! ./XmlElement */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlElement.js\");\nconst XmlNode = __webpack_require__(/*! ./XmlNode */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlNode.js\");\n/**\nRepresents an XML document. All elements within the document are descendants of\nthis node.\n\n@public\n*/ class XmlDocument extends XmlNode {\n    /**\n  @param {Array<XmlComment|XmlElement|XmlProcessingInstruction>} [children]\n  */ constructor(children = []){\n        super();\n        /**\n    Child nodes of this document.\n\n    @type {Array<XmlComment|XmlElement|XmlProcessingInstruction>}\n    @public\n    */ this.children = children;\n    }\n    get document() {\n        return this;\n    }\n    /**\n  Root element of this document, or `null` if this document is empty.\n\n  @type {XmlElement?}\n  @public\n  */ get root() {\n        // @ts-ignore\n        return this.children.find((child)=>child instanceof XmlElement) || null;\n    }\n    /**\n  Text content of this document and all its descendants.\n\n  @type {string}\n  @public\n  */ get text() {\n        return this.children.map((child)=>\"text\" in child ? child.text : \"\").join(\"\");\n    }\n    get type() {\n        return XmlNode.TYPE_DOCUMENT;\n    }\n    toJSON() {\n        return Object.assign(XmlNode.prototype.toJSON.call(this), {\n            children: this.children.map((child)=>child.toJSON())\n        });\n    }\n}\nmodule.exports = XmlDocument; /** @typedef {import('./XmlComment')} XmlComment */  /** @typedef {import('./XmlProcessingInstruction')} XmlProcessingInstruction */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJncm92ZS9wYXJzZS14bWwvc3JjL2xpYi9YbWxEb2N1bWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLGFBQWFDLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDO0FBRXhCOzs7OztBQUtBLEdBQ0EsTUFBTUUsb0JBQW9CRDtJQUN4Qjs7RUFFQSxHQUNBRSxZQUFZQyxXQUFXLEVBQUUsQ0FBRTtRQUN6QixLQUFLO1FBRUw7Ozs7O0lBS0EsR0FDQSxJQUFJLENBQUNBLFFBQVEsR0FBR0E7SUFDbEI7SUFFQSxJQUFJQyxXQUFXO1FBQ2IsT0FBTyxJQUFJO0lBQ2I7SUFFQTs7Ozs7RUFLQSxHQUNBLElBQUlDLE9BQU87UUFDVCxhQUFhO1FBQ2IsT0FBTyxJQUFJLENBQUNGLFFBQVEsQ0FBQ0csSUFBSSxDQUFDLENBQUNDLFFBQVVBLGlCQUFpQlQsZUFBZTtJQUN2RTtJQUVBOzs7OztFQUtBLEdBQ0EsSUFBSVUsT0FBTztRQUNULE9BQU8sSUFBSSxDQUFDTCxRQUFRLENBQ2pCTSxHQUFHLENBQUNGLENBQUFBLFFBQVMsVUFBVUEsUUFBUUEsTUFBTUMsSUFBSSxHQUFHLElBQzVDRSxJQUFJLENBQUM7SUFDVjtJQUVBLElBQUlDLE9BQU87UUFDVCxPQUFPWCxRQUFRWSxhQUFhO0lBQzlCO0lBRUFDLFNBQVM7UUFDUCxPQUFPQyxPQUFPQyxNQUFNLENBQUNmLFFBQVFnQixTQUFTLENBQUNILE1BQU0sQ0FBQ0ksSUFBSSxDQUFDLElBQUksR0FBRztZQUN4RGQsVUFBVSxJQUFJLENBQUNBLFFBQVEsQ0FBQ00sR0FBRyxDQUFDRixDQUFBQSxRQUFTQSxNQUFNTSxNQUFNO1FBQ25EO0lBQ0Y7QUFDRjtBQUVBSyxPQUFPQyxPQUFPLEdBQUdsQixhQUVqQixpREFBaUQsSUFDakQsNkVBQTZFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGljdGFjdG9lLy4vbm9kZV9tb2R1bGVzL0ByZ3JvdmUvcGFyc2UteG1sL3NyYy9saWIvWG1sRG9jdW1lbnQuanM/ZDVjNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFhtbEVsZW1lbnQgPSByZXF1aXJlKCcuL1htbEVsZW1lbnQnKTtcbmNvbnN0IFhtbE5vZGUgPSByZXF1aXJlKCcuL1htbE5vZGUnKTtcblxuLyoqXG5SZXByZXNlbnRzIGFuIFhNTCBkb2N1bWVudC4gQWxsIGVsZW1lbnRzIHdpdGhpbiB0aGUgZG9jdW1lbnQgYXJlIGRlc2NlbmRhbnRzIG9mXG50aGlzIG5vZGUuXG5cbkBwdWJsaWNcbiovXG5jbGFzcyBYbWxEb2N1bWVudCBleHRlbmRzIFhtbE5vZGUge1xuICAvKipcbiAgQHBhcmFtIHtBcnJheTxYbWxDb21tZW50fFhtbEVsZW1lbnR8WG1sUHJvY2Vzc2luZ0luc3RydWN0aW9uPn0gW2NoaWxkcmVuXVxuICAqL1xuICBjb25zdHJ1Y3RvcihjaGlsZHJlbiA9IFtdKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgIENoaWxkIG5vZGVzIG9mIHRoaXMgZG9jdW1lbnQuXG5cbiAgICBAdHlwZSB7QXJyYXk8WG1sQ29tbWVudHxYbWxFbGVtZW50fFhtbFByb2Nlc3NpbmdJbnN0cnVjdGlvbj59XG4gICAgQHB1YmxpY1xuICAgICovXG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9XG5cbiAgZ2V0IGRvY3VtZW50KCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gIFJvb3QgZWxlbWVudCBvZiB0aGlzIGRvY3VtZW50LCBvciBgbnVsbGAgaWYgdGhpcyBkb2N1bWVudCBpcyBlbXB0eS5cblxuICBAdHlwZSB7WG1sRWxlbWVudD99XG4gIEBwdWJsaWNcbiAgKi9cbiAgZ2V0IHJvb3QoKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmZpbmQoKGNoaWxkKSA9PiBjaGlsZCBpbnN0YW5jZW9mIFhtbEVsZW1lbnQpIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgVGV4dCBjb250ZW50IG9mIHRoaXMgZG9jdW1lbnQgYW5kIGFsbCBpdHMgZGVzY2VuZGFudHMuXG5cbiAgQHR5cGUge3N0cmluZ31cbiAgQHB1YmxpY1xuICAqL1xuICBnZXQgdGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlblxuICAgICAgLm1hcChjaGlsZCA9PiAndGV4dCcgaW4gY2hpbGQgPyBjaGlsZC50ZXh0IDogJycpXG4gICAgICAuam9pbignJyk7XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gWG1sTm9kZS5UWVBFX0RPQ1VNRU5UO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKFhtbE5vZGUucHJvdG90eXBlLnRvSlNPTi5jYWxsKHRoaXMpLCB7XG4gICAgICBjaGlsZHJlbjogdGhpcy5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gY2hpbGQudG9KU09OKCkpLFxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWG1sRG9jdW1lbnQ7XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL1htbENvbW1lbnQnKX0gWG1sQ29tbWVudCAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vWG1sUHJvY2Vzc2luZ0luc3RydWN0aW9uJyl9IFhtbFByb2Nlc3NpbmdJbnN0cnVjdGlvbiAqL1xuIl0sIm5hbWVzIjpbIlhtbEVsZW1lbnQiLCJyZXF1aXJlIiwiWG1sTm9kZSIsIlhtbERvY3VtZW50IiwiY29uc3RydWN0b3IiLCJjaGlsZHJlbiIsImRvY3VtZW50Iiwicm9vdCIsImZpbmQiLCJjaGlsZCIsInRleHQiLCJtYXAiLCJqb2luIiwidHlwZSIsIlRZUEVfRE9DVU1FTlQiLCJ0b0pTT04iLCJPYmplY3QiLCJhc3NpZ24iLCJwcm90b3R5cGUiLCJjYWxsIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlDocument.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlElement.js":
/*!**************************************************************!*\
  !*** ./node_modules/@rgrove/parse-xml/src/lib/XmlElement.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst XmlNode = __webpack_require__(/*! ./XmlNode */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlNode.js\");\n/**\nElement in an XML document.\n\n@public\n*/ class XmlElement extends XmlNode {\n    /**\n  @param {string} name\n  @param {{[attrName: string]: string}} [attributes]\n  @param {Array<XmlCdata|XmlComment|XmlElement|XmlProcessingInstruction|XmlText>} [children]\n  */ constructor(name, attributes = Object.create(null), children = []){\n        super();\n        /**\n    Name of this element.\n\n    @type {string}\n    @public\n    */ this.name = name;\n        /**\n    Attributes on this element.\n\n    @type {{[attrName: string]: string}}\n    @public\n    */ this.attributes = attributes;\n        /**\n    Child nodes of this element.\n\n    @type {Array<XmlCdata|XmlComment|XmlElement|XmlProcessingInstruction|XmlText>}\n    @public\n    */ this.children = children;\n    }\n    /**\n  Whether this node is empty (meaning it has no children).\n\n  @type {boolean}\n  @public\n  */ get isEmpty() {\n        return this.children.length === 0;\n    }\n    /** @type {boolean} */ get preserveWhitespace() {\n        /** @type {XmlNode?} */ let node = this;\n        while(node instanceof XmlElement){\n            if (\"xml:space\" in node.attributes) {\n                return node.attributes[\"xml:space\"] === \"preserve\";\n            }\n            node = node.parent;\n        }\n        return false;\n    }\n    /**\n  Text content of this element and all its descendants.\n\n  @type {string}\n  @public\n  */ get text() {\n        return this.children.map((child)=>\"text\" in child ? child.text : \"\").join(\"\");\n    }\n    get type() {\n        return XmlNode.TYPE_ELEMENT;\n    }\n    /** @returns {{[key: string]: any}} */ toJSON() {\n        return Object.assign(XmlNode.prototype.toJSON.call(this), {\n            name: this.name,\n            attributes: this.attributes,\n            children: this.children.map((child)=>child.toJSON())\n        });\n    }\n}\nmodule.exports = XmlElement; /** @typedef {import('./XmlCdata')} XmlCdata */  /** @typedef {import('./XmlComment')} XmlComment */  /** @typedef {import('./XmlProcessingInstruction')} XmlProcessingInstruction */  /** @typedef {import('./XmlText')} XmlText */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJncm92ZS9wYXJzZS14bWwvc3JjL2xpYi9YbWxFbGVtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsVUFBVUMsbUJBQU9BLENBQUM7QUFFeEI7Ozs7QUFJQSxHQUNBLE1BQU1DLG1CQUFtQkY7SUFDdkI7Ozs7RUFJQSxHQUNBRyxZQUFZQyxJQUFJLEVBQUVDLGFBQWFDLE9BQU9DLE1BQU0sQ0FBQyxLQUFLLEVBQUVDLFdBQVcsRUFBRSxDQUFFO1FBQ2pFLEtBQUs7UUFFTDs7Ozs7SUFLQSxHQUNBLElBQUksQ0FBQ0osSUFBSSxHQUFHQTtRQUVaOzs7OztJQUtBLEdBQ0EsSUFBSSxDQUFDQyxVQUFVLEdBQUdBO1FBRWxCOzs7OztJQUtBLEdBQ0EsSUFBSSxDQUFDRyxRQUFRLEdBQUdBO0lBQ2xCO0lBRUE7Ozs7O0VBS0EsR0FDQSxJQUFJQyxVQUFVO1FBQ1osT0FBTyxJQUFJLENBQUNELFFBQVEsQ0FBQ0UsTUFBTSxLQUFLO0lBQ2xDO0lBRUEsb0JBQW9CLEdBQ3BCLElBQUlDLHFCQUFxQjtRQUN2QixxQkFBcUIsR0FDckIsSUFBSUMsT0FBTyxJQUFJO1FBRWYsTUFBT0EsZ0JBQWdCVixXQUFZO1lBQ2pDLElBQUksZUFBZVUsS0FBS1AsVUFBVSxFQUFFO2dCQUNsQyxPQUFPTyxLQUFLUCxVQUFVLENBQUMsWUFBWSxLQUFLO1lBQzFDO1lBRUFPLE9BQU9BLEtBQUtDLE1BQU07UUFDcEI7UUFFQSxPQUFPO0lBQ1Q7SUFFQTs7Ozs7RUFLQSxHQUNBLElBQUlDLE9BQU87UUFDVCxPQUFPLElBQUksQ0FBQ04sUUFBUSxDQUNqQk8sR0FBRyxDQUFDQyxDQUFBQSxRQUFTLFVBQVVBLFFBQVFBLE1BQU1GLElBQUksR0FBRyxJQUM1Q0csSUFBSSxDQUFDO0lBQ1Y7SUFFQSxJQUFJQyxPQUFPO1FBQ1QsT0FBT2xCLFFBQVFtQixZQUFZO0lBQzdCO0lBRUEsb0NBQW9DLEdBQ3BDQyxTQUFTO1FBQ1AsT0FBT2QsT0FBT2UsTUFBTSxDQUFDckIsUUFBUXNCLFNBQVMsQ0FBQ0YsTUFBTSxDQUFDRyxJQUFJLENBQUMsSUFBSSxHQUFHO1lBQ3hEbkIsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDZkMsWUFBWSxJQUFJLENBQUNBLFVBQVU7WUFDM0JHLFVBQVUsSUFBSSxDQUFDQSxRQUFRLENBQUNPLEdBQUcsQ0FBQ0MsQ0FBQUEsUUFBU0EsTUFBTUksTUFBTTtRQUNuRDtJQUNGO0FBQ0Y7QUFFQUksT0FBT0MsT0FBTyxHQUFHdkIsWUFFakIsNkNBQTZDLElBQzdDLGlEQUFpRCxJQUNqRCw2RUFBNkUsSUFDN0UsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGljdGFjdG9lLy4vbm9kZV9tb2R1bGVzL0ByZ3JvdmUvcGFyc2UteG1sL3NyYy9saWIvWG1sRWxlbWVudC5qcz8yNmQ2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgWG1sTm9kZSA9IHJlcXVpcmUoJy4vWG1sTm9kZScpO1xuXG4vKipcbkVsZW1lbnQgaW4gYW4gWE1MIGRvY3VtZW50LlxuXG5AcHVibGljXG4qL1xuY2xhc3MgWG1sRWxlbWVudCBleHRlbmRzIFhtbE5vZGUge1xuICAvKipcbiAgQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgQHBhcmFtIHt7W2F0dHJOYW1lOiBzdHJpbmddOiBzdHJpbmd9fSBbYXR0cmlidXRlc11cbiAgQHBhcmFtIHtBcnJheTxYbWxDZGF0YXxYbWxDb21tZW50fFhtbEVsZW1lbnR8WG1sUHJvY2Vzc2luZ0luc3RydWN0aW9ufFhtbFRleHQ+fSBbY2hpbGRyZW5dXG4gICovXG4gIGNvbnN0cnVjdG9yKG5hbWUsIGF0dHJpYnV0ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpLCBjaGlsZHJlbiA9IFtdKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgIE5hbWUgb2YgdGhpcyBlbGVtZW50LlxuXG4gICAgQHR5cGUge3N0cmluZ31cbiAgICBAcHVibGljXG4gICAgKi9cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgLyoqXG4gICAgQXR0cmlidXRlcyBvbiB0aGlzIGVsZW1lbnQuXG5cbiAgICBAdHlwZSB7e1thdHRyTmFtZTogc3RyaW5nXTogc3RyaW5nfX1cbiAgICBAcHVibGljXG4gICAgKi9cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuXG4gICAgLyoqXG4gICAgQ2hpbGQgbm9kZXMgb2YgdGhpcyBlbGVtZW50LlxuXG4gICAgQHR5cGUge0FycmF5PFhtbENkYXRhfFhtbENvbW1lbnR8WG1sRWxlbWVudHxYbWxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb258WG1sVGV4dD59XG4gICAgQHB1YmxpY1xuICAgICovXG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9XG5cbiAgLyoqXG4gIFdoZXRoZXIgdGhpcyBub2RlIGlzIGVtcHR5IChtZWFuaW5nIGl0IGhhcyBubyBjaGlsZHJlbikuXG5cbiAgQHR5cGUge2Jvb2xlYW59XG4gIEBwdWJsaWNcbiAgKi9cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICBnZXQgcHJlc2VydmVXaGl0ZXNwYWNlKCkge1xuICAgIC8qKiBAdHlwZSB7WG1sTm9kZT99ICovXG4gICAgbGV0IG5vZGUgPSB0aGlzO1xuXG4gICAgd2hpbGUgKG5vZGUgaW5zdGFuY2VvZiBYbWxFbGVtZW50KSB7XG4gICAgICBpZiAoJ3htbDpzcGFjZScgaW4gbm9kZS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldHVybiBub2RlLmF0dHJpYnV0ZXNbJ3htbDpzcGFjZSddID09PSAncHJlc2VydmUnO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gIFRleHQgY29udGVudCBvZiB0aGlzIGVsZW1lbnQgYW5kIGFsbCBpdHMgZGVzY2VuZGFudHMuXG5cbiAgQHR5cGUge3N0cmluZ31cbiAgQHB1YmxpY1xuICAqL1xuICBnZXQgdGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlblxuICAgICAgLm1hcChjaGlsZCA9PiAndGV4dCcgaW4gY2hpbGQgPyBjaGlsZC50ZXh0IDogJycpXG4gICAgICAuam9pbignJyk7XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gWG1sTm9kZS5UWVBFX0VMRU1FTlQ7XG4gIH1cblxuICAvKiogQHJldHVybnMge3tba2V5OiBzdHJpbmddOiBhbnl9fSAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oWG1sTm9kZS5wcm90b3R5cGUudG9KU09OLmNhbGwodGhpcyksIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuYXR0cmlidXRlcyxcbiAgICAgIGNoaWxkcmVuOiB0aGlzLmNoaWxkcmVuLm1hcChjaGlsZCA9PiBjaGlsZC50b0pTT04oKSksXG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBYbWxFbGVtZW50O1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9YbWxDZGF0YScpfSBYbWxDZGF0YSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vWG1sQ29tbWVudCcpfSBYbWxDb21tZW50ICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9YbWxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24nKX0gWG1sUHJvY2Vzc2luZ0luc3RydWN0aW9uICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9YbWxUZXh0Jyl9IFhtbFRleHQgKi9cbiJdLCJuYW1lcyI6WyJYbWxOb2RlIiwicmVxdWlyZSIsIlhtbEVsZW1lbnQiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJhdHRyaWJ1dGVzIiwiT2JqZWN0IiwiY3JlYXRlIiwiY2hpbGRyZW4iLCJpc0VtcHR5IiwibGVuZ3RoIiwicHJlc2VydmVXaGl0ZXNwYWNlIiwibm9kZSIsInBhcmVudCIsInRleHQiLCJtYXAiLCJjaGlsZCIsImpvaW4iLCJ0eXBlIiwiVFlQRV9FTEVNRU5UIiwidG9KU09OIiwiYXNzaWduIiwicHJvdG90eXBlIiwiY2FsbCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlElement.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlNode.js":
/*!***********************************************************!*\
  !*** ./node_modules/@rgrove/parse-xml/src/lib/XmlNode.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("\n/**\nBase interface for a node in an XML document.\n\n@public\n*/ class XmlNode {\n    constructor(){\n        /**\n    Parent node of this node, or `null` if this node has no parent.\n\n    @type {XmlDocument|XmlElement|null}\n    @public\n    */ this.parent = null;\n    }\n    /**\n  Document that contains this node, or `null` if this node is not associated\n  with a document.\n\n  @type {XmlDocument?}\n  @public\n  */ get document() {\n        return this.parent ? this.parent.document : null;\n    }\n    /**\n  Whether this node is the root node of the document.\n\n  @returns {boolean}\n  @public\n  */ get isRootNode() {\n        return this.parent ? this.parent === this.document : false;\n    }\n    /**\n  Whether whitespace should be preserved in the content of this element and\n  its children.\n\n  This is influenced by the value of the special `xml:space` attribute, and\n  will be `true` for any node whose `xml:space` attribute is set to\n  \"preserve\". If a node has no such attribute, it will inherit the value of\n  the nearest ancestor that does (if any).\n\n  @type {boolean}\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-white-space\n  @public\n  */ get preserveWhitespace() {\n        return Boolean(this.parent && this.parent.preserveWhitespace);\n    }\n    /**\n  Type of this node.\n\n  The value of this property is a string that matches one of the static `TYPE_*`\n  properties on the `XmlNode` class (e.g. `TYPE_ELEMENT`, `TYPE_TEXT`, etc.).\n\n  The `XmlNode` class itself is a base class and doesn't have its own type name.\n\n  @type {string}\n  @public\n  */ get type() {\n        return \"\";\n    }\n    /**\n  Returns a JSON-serializable object representing this node, minus properties\n  that could result in circular references.\n\n  @returns {{[key: string]: any}}\n  @public\n  */ toJSON() {\n        /** @type {{[key: string]: any}} */ let json = {\n            type: this.type\n        };\n        if (this.isRootNode) {\n            json.isRootNode = true;\n        }\n        if (this.preserveWhitespace) {\n            json.preserveWhitespace = true;\n        }\n        return json;\n    }\n}\n/**\nType value for an `XmlCdata` node.\n\n@type {string}\n@public\n*/ XmlNode.TYPE_CDATA = \"cdata\";\n/**\nType value for an `XmlComment` node.\n\n@type {string}\n@public\n*/ XmlNode.TYPE_COMMENT = \"comment\";\n/**\nType value for an `XmlDocument` node.\n\n@type {string}\n@public\n*/ XmlNode.TYPE_DOCUMENT = \"document\";\n/**\nType value for an `XmlElement` node.\n\n@type {string}\n@public\n*/ XmlNode.TYPE_ELEMENT = \"element\";\n/**\nType value for an `XmlProcessingInstruction` node.\n\n@type {string}\n@public\n*/ XmlNode.TYPE_PROCESSING_INSTRUCTION = \"pi\";\n/**\nType value for an `XmlText` node.\n\n@type {string}\n@public\n*/ XmlNode.TYPE_TEXT = \"text\";\nmodule.exports = XmlNode; /** @typedef {import('./XmlDocument')} XmlDocument */  /** @typedef {import('./XmlElement')} XmlElement */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJncm92ZS9wYXJzZS14bWwvc3JjL2xpYi9YbWxOb2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUE7Ozs7QUFJQSxHQUNBLE1BQU1BO0lBQ0pDLGFBQWM7UUFDWjs7Ozs7SUFLQSxHQUNBLElBQUksQ0FBQ0MsTUFBTSxHQUFHO0lBQ2hCO0lBRUE7Ozs7OztFQU1BLEdBQ0EsSUFBSUMsV0FBVztRQUNiLE9BQU8sSUFBSSxDQUFDRCxNQUFNLEdBQ2QsSUFBSSxDQUFDQSxNQUFNLENBQUNDLFFBQVEsR0FDcEI7SUFDTjtJQUVBOzs7OztFQUtBLEdBQ0EsSUFBSUMsYUFBYTtRQUNmLE9BQU8sSUFBSSxDQUFDRixNQUFNLEdBQ2QsSUFBSSxDQUFDQSxNQUFNLEtBQUssSUFBSSxDQUFDQyxRQUFRLEdBQzdCO0lBQ047SUFFQTs7Ozs7Ozs7Ozs7O0VBWUEsR0FDQSxJQUFJRSxxQkFBcUI7UUFDdkIsT0FBT0MsUUFBUSxJQUFJLENBQUNKLE1BQU0sSUFBSSxJQUFJLENBQUNBLE1BQU0sQ0FBQ0csa0JBQWtCO0lBQzlEO0lBRUE7Ozs7Ozs7Ozs7RUFVQSxHQUNBLElBQUlFLE9BQU87UUFDVCxPQUFPO0lBQ1Q7SUFFQTs7Ozs7O0VBTUEsR0FDQUMsU0FBUztRQUNQLGlDQUFpQyxHQUNqQyxJQUFJQyxPQUFPO1lBQ1RGLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1FBQ2pCO1FBRUEsSUFBSSxJQUFJLENBQUNILFVBQVUsRUFBRTtZQUNuQkssS0FBS0wsVUFBVSxHQUFHO1FBQ3BCO1FBRUEsSUFBSSxJQUFJLENBQUNDLGtCQUFrQixFQUFFO1lBQzNCSSxLQUFLSixrQkFBa0IsR0FBRztRQUM1QjtRQUVBLE9BQU9JO0lBQ1Q7QUFDRjtBQUVBOzs7OztBQUtBLEdBQ0FULFFBQVFVLFVBQVUsR0FBRztBQUVyQjs7Ozs7QUFLQSxHQUNBVixRQUFRVyxZQUFZLEdBQUc7QUFFdkI7Ozs7O0FBS0EsR0FDQVgsUUFBUVksYUFBYSxHQUFHO0FBRXhCOzs7OztBQUtBLEdBQ0FaLFFBQVFhLFlBQVksR0FBRztBQUV2Qjs7Ozs7QUFLQSxHQUNBYixRQUFRYywyQkFBMkIsR0FBRztBQUV0Qzs7Ozs7QUFLQSxHQUNBZCxRQUFRZSxTQUFTLEdBQUc7QUFFcEJDLE9BQU9DLE9BQU8sR0FBR2pCLFNBRWpCLG1EQUFtRCxJQUNuRCxpREFBaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aWN0YWN0b2UvLi9ub2RlX21vZHVsZXMvQHJncm92ZS9wYXJzZS14bWwvc3JjL2xpYi9YbWxOb2RlLmpzPzFjN2YiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbkJhc2UgaW50ZXJmYWNlIGZvciBhIG5vZGUgaW4gYW4gWE1MIGRvY3VtZW50LlxuXG5AcHVibGljXG4qL1xuY2xhc3MgWG1sTm9kZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgIFBhcmVudCBub2RlIG9mIHRoaXMgbm9kZSwgb3IgYG51bGxgIGlmIHRoaXMgbm9kZSBoYXMgbm8gcGFyZW50LlxuXG4gICAgQHR5cGUge1htbERvY3VtZW50fFhtbEVsZW1lbnR8bnVsbH1cbiAgICBAcHVibGljXG4gICAgKi9cbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgRG9jdW1lbnQgdGhhdCBjb250YWlucyB0aGlzIG5vZGUsIG9yIGBudWxsYCBpZiB0aGlzIG5vZGUgaXMgbm90IGFzc29jaWF0ZWRcbiAgd2l0aCBhIGRvY3VtZW50LlxuXG4gIEB0eXBlIHtYbWxEb2N1bWVudD99XG4gIEBwdWJsaWNcbiAgKi9cbiAgZ2V0IGRvY3VtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudFxuICAgICAgPyB0aGlzLnBhcmVudC5kb2N1bWVudFxuICAgICAgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gIFdoZXRoZXIgdGhpcyBub2RlIGlzIHRoZSByb290IG5vZGUgb2YgdGhlIGRvY3VtZW50LlxuXG4gIEByZXR1cm5zIHtib29sZWFufVxuICBAcHVibGljXG4gICovXG4gIGdldCBpc1Jvb3ROb2RlKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudFxuICAgICAgPyB0aGlzLnBhcmVudCA9PT0gdGhpcy5kb2N1bWVudFxuICAgICAgOiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICBXaGV0aGVyIHdoaXRlc3BhY2Ugc2hvdWxkIGJlIHByZXNlcnZlZCBpbiB0aGUgY29udGVudCBvZiB0aGlzIGVsZW1lbnQgYW5kXG4gIGl0cyBjaGlsZHJlbi5cblxuICBUaGlzIGlzIGluZmx1ZW5jZWQgYnkgdGhlIHZhbHVlIG9mIHRoZSBzcGVjaWFsIGB4bWw6c3BhY2VgIGF0dHJpYnV0ZSwgYW5kXG4gIHdpbGwgYmUgYHRydWVgIGZvciBhbnkgbm9kZSB3aG9zZSBgeG1sOnNwYWNlYCBhdHRyaWJ1dGUgaXMgc2V0IHRvXG4gIFwicHJlc2VydmVcIi4gSWYgYSBub2RlIGhhcyBubyBzdWNoIGF0dHJpYnV0ZSwgaXQgd2lsbCBpbmhlcml0IHRoZSB2YWx1ZSBvZlxuICB0aGUgbmVhcmVzdCBhbmNlc3RvciB0aGF0IGRvZXMgKGlmIGFueSkuXG5cbiAgQHR5cGUge2Jvb2xlYW59XG4gIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLXhtbC0yMDA4MTEyNi8jc2VjLXdoaXRlLXNwYWNlXG4gIEBwdWJsaWNcbiAgKi9cbiAgZ2V0IHByZXNlcnZlV2hpdGVzcGFjZSgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5wcmVzZXJ2ZVdoaXRlc3BhY2UpO1xuICB9XG5cbiAgLyoqXG4gIFR5cGUgb2YgdGhpcyBub2RlLlxuXG4gIFRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5IGlzIGEgc3RyaW5nIHRoYXQgbWF0Y2hlcyBvbmUgb2YgdGhlIHN0YXRpYyBgVFlQRV8qYFxuICBwcm9wZXJ0aWVzIG9uIHRoZSBgWG1sTm9kZWAgY2xhc3MgKGUuZy4gYFRZUEVfRUxFTUVOVGAsIGBUWVBFX1RFWFRgLCBldGMuKS5cblxuICBUaGUgYFhtbE5vZGVgIGNsYXNzIGl0c2VsZiBpcyBhIGJhc2UgY2xhc3MgYW5kIGRvZXNuJ3QgaGF2ZSBpdHMgb3duIHR5cGUgbmFtZS5cblxuICBAdHlwZSB7c3RyaW5nfVxuICBAcHVibGljXG4gICovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8qKlxuICBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGlzIG5vZGUsIG1pbnVzIHByb3BlcnRpZXNcbiAgdGhhdCBjb3VsZCByZXN1bHQgaW4gY2lyY3VsYXIgcmVmZXJlbmNlcy5cblxuICBAcmV0dXJucyB7e1trZXk6IHN0cmluZ106IGFueX19XG4gIEBwdWJsaWNcbiAgKi9cbiAgdG9KU09OKCkge1xuICAgIC8qKiBAdHlwZSB7e1trZXk6IHN0cmluZ106IGFueX19ICovXG4gICAgbGV0IGpzb24gPSB7XG4gICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuaXNSb290Tm9kZSkge1xuICAgICAganNvbi5pc1Jvb3ROb2RlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcmVzZXJ2ZVdoaXRlc3BhY2UpIHtcbiAgICAgIGpzb24ucHJlc2VydmVXaGl0ZXNwYWNlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxufVxuXG4vKipcblR5cGUgdmFsdWUgZm9yIGFuIGBYbWxDZGF0YWAgbm9kZS5cblxuQHR5cGUge3N0cmluZ31cbkBwdWJsaWNcbiovXG5YbWxOb2RlLlRZUEVfQ0RBVEEgPSAnY2RhdGEnO1xuXG4vKipcblR5cGUgdmFsdWUgZm9yIGFuIGBYbWxDb21tZW50YCBub2RlLlxuXG5AdHlwZSB7c3RyaW5nfVxuQHB1YmxpY1xuKi9cblhtbE5vZGUuVFlQRV9DT01NRU5UID0gJ2NvbW1lbnQnO1xuXG4vKipcblR5cGUgdmFsdWUgZm9yIGFuIGBYbWxEb2N1bWVudGAgbm9kZS5cblxuQHR5cGUge3N0cmluZ31cbkBwdWJsaWNcbiovXG5YbWxOb2RlLlRZUEVfRE9DVU1FTlQgPSAnZG9jdW1lbnQnO1xuXG4vKipcblR5cGUgdmFsdWUgZm9yIGFuIGBYbWxFbGVtZW50YCBub2RlLlxuXG5AdHlwZSB7c3RyaW5nfVxuQHB1YmxpY1xuKi9cblhtbE5vZGUuVFlQRV9FTEVNRU5UID0gJ2VsZW1lbnQnO1xuXG4vKipcblR5cGUgdmFsdWUgZm9yIGFuIGBYbWxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb25gIG5vZGUuXG5cbkB0eXBlIHtzdHJpbmd9XG5AcHVibGljXG4qL1xuWG1sTm9kZS5UWVBFX1BST0NFU1NJTkdfSU5TVFJVQ1RJT04gPSAncGknO1xuXG4vKipcblR5cGUgdmFsdWUgZm9yIGFuIGBYbWxUZXh0YCBub2RlLlxuXG5AdHlwZSB7c3RyaW5nfVxuQHB1YmxpY1xuKi9cblhtbE5vZGUuVFlQRV9URVhUID0gJ3RleHQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhtbE5vZGU7XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL1htbERvY3VtZW50Jyl9IFhtbERvY3VtZW50ICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9YbWxFbGVtZW50Jyl9IFhtbEVsZW1lbnQgKi9cbiJdLCJuYW1lcyI6WyJYbWxOb2RlIiwiY29uc3RydWN0b3IiLCJwYXJlbnQiLCJkb2N1bWVudCIsImlzUm9vdE5vZGUiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJCb29sZWFuIiwidHlwZSIsInRvSlNPTiIsImpzb24iLCJUWVBFX0NEQVRBIiwiVFlQRV9DT01NRU5UIiwiVFlQRV9ET0NVTUVOVCIsIlRZUEVfRUxFTUVOVCIsIlRZUEVfUFJPQ0VTU0lOR19JTlNUUlVDVElPTiIsIlRZUEVfVEVYVCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlProcessingInstruction.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@rgrove/parse-xml/src/lib/XmlProcessingInstruction.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst XmlNode = __webpack_require__(/*! ./XmlNode */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlNode.js\");\n/**\nA processing instruction within an XML document.\n\n@public\n*/ class XmlProcessingInstruction extends XmlNode {\n    /**\n  @param {string} name\n  @param {string} [content]\n  */ constructor(name, content = \"\"){\n        super();\n        /**\n    Name of this processing instruction. Also sometimes referred to as the\n    processing instruction \"target\".\n\n    @type {string}\n    @public\n    */ this.name = name;\n        /**\n    Content of this processing instruction.\n\n    @type {string}\n    @public\n    */ this.content = content;\n    }\n    get type() {\n        return XmlNode.TYPE_PROCESSING_INSTRUCTION;\n    }\n    toJSON() {\n        return Object.assign(XmlNode.prototype.toJSON.call(this), {\n            name: this.name,\n            content: this.content\n        });\n    }\n}\nmodule.exports = XmlProcessingInstruction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJncm92ZS9wYXJzZS14bWwvc3JjL2xpYi9YbWxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxVQUFVQyxtQkFBT0EsQ0FBQztBQUV4Qjs7OztBQUlBLEdBQ0EsTUFBTUMsaUNBQWlDRjtJQUNyQzs7O0VBR0EsR0FDQUcsWUFBWUMsSUFBSSxFQUFFQyxVQUFVLEVBQUUsQ0FBRTtRQUM5QixLQUFLO1FBRUw7Ozs7OztJQU1BLEdBQ0EsSUFBSSxDQUFDRCxJQUFJLEdBQUdBO1FBRVo7Ozs7O0lBS0EsR0FDQSxJQUFJLENBQUNDLE9BQU8sR0FBR0E7SUFDakI7SUFFQSxJQUFJQyxPQUFPO1FBQ1QsT0FBT04sUUFBUU8sMkJBQTJCO0lBQzVDO0lBRUFDLFNBQVM7UUFDUCxPQUFPQyxPQUFPQyxNQUFNLENBQUNWLFFBQVFXLFNBQVMsQ0FBQ0gsTUFBTSxDQUFDSSxJQUFJLENBQUMsSUFBSSxHQUFHO1lBQ3hEUixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNmQyxTQUFTLElBQUksQ0FBQ0EsT0FBTztRQUN2QjtJQUNGO0FBQ0Y7QUFFQVEsT0FBT0MsT0FBTyxHQUFHWiIsInNvdXJjZXMiOlsid2VicGFjazovL3RpY3RhY3RvZS8uL25vZGVfbW9kdWxlcy9Acmdyb3ZlL3BhcnNlLXhtbC9zcmMvbGliL1htbFByb2Nlc3NpbmdJbnN0cnVjdGlvbi5qcz82YjA1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgWG1sTm9kZSA9IHJlcXVpcmUoJy4vWG1sTm9kZScpO1xuXG4vKipcbkEgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiB3aXRoaW4gYW4gWE1MIGRvY3VtZW50LlxuXG5AcHVibGljXG4qL1xuY2xhc3MgWG1sUHJvY2Vzc2luZ0luc3RydWN0aW9uIGV4dGVuZHMgWG1sTm9kZSB7XG4gIC8qKlxuICBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICBAcGFyYW0ge3N0cmluZ30gW2NvbnRlbnRdXG4gICovXG4gIGNvbnN0cnVjdG9yKG5hbWUsIGNvbnRlbnQgPSAnJykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICBOYW1lIG9mIHRoaXMgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbi4gQWxzbyBzb21ldGltZXMgcmVmZXJyZWQgdG8gYXMgdGhlXG4gICAgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBcInRhcmdldFwiLlxuXG4gICAgQHR5cGUge3N0cmluZ31cbiAgICBAcHVibGljXG4gICAgKi9cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgLyoqXG4gICAgQ29udGVudCBvZiB0aGlzIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24uXG5cbiAgICBAdHlwZSB7c3RyaW5nfVxuICAgIEBwdWJsaWNcbiAgICAqL1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gWG1sTm9kZS5UWVBFX1BST0NFU1NJTkdfSU5TVFJVQ1RJT047XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oWG1sTm9kZS5wcm90b3R5cGUudG9KU09OLmNhbGwodGhpcyksIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudFxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWG1sUHJvY2Vzc2luZ0luc3RydWN0aW9uO1xuIl0sIm5hbWVzIjpbIlhtbE5vZGUiLCJyZXF1aXJlIiwiWG1sUHJvY2Vzc2luZ0luc3RydWN0aW9uIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiY29udGVudCIsInR5cGUiLCJUWVBFX1BST0NFU1NJTkdfSU5TVFJVQ1RJT04iLCJ0b0pTT04iLCJPYmplY3QiLCJhc3NpZ24iLCJwcm90b3R5cGUiLCJjYWxsIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlProcessingInstruction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlText.js":
/*!***********************************************************!*\
  !*** ./node_modules/@rgrove/parse-xml/src/lib/XmlText.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst XmlNode = __webpack_require__(/*! ./XmlNode */ \"(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlNode.js\");\n/**\nText content within an XML document.\n\n@public\n*/ class XmlText extends XmlNode {\n    /**\n  @param {string} [text]\n  */ constructor(text = \"\"){\n        super();\n        /**\n    Text content of this node.\n\n    @type {string}\n    @public\n    */ this.text = text;\n    }\n    get type() {\n        return XmlNode.TYPE_TEXT;\n    }\n    toJSON() {\n        return Object.assign(XmlNode.prototype.toJSON.call(this), {\n            text: this.text\n        });\n    }\n}\nmodule.exports = XmlText;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJncm92ZS9wYXJzZS14bWwvc3JjL2xpYi9YbWxUZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsVUFBVUMsbUJBQU9BLENBQUM7QUFFeEI7Ozs7QUFJQSxHQUNBLE1BQU1DLGdCQUFnQkY7SUFDcEI7O0VBRUEsR0FDQUcsWUFBWUMsT0FBTyxFQUFFLENBQUU7UUFDckIsS0FBSztRQUVMOzs7OztJQUtBLEdBQ0EsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO0lBQ2Q7SUFFQSxJQUFJQyxPQUFPO1FBQ1QsT0FBT0wsUUFBUU0sU0FBUztJQUMxQjtJQUVBQyxTQUFTO1FBQ1AsT0FBT0MsT0FBT0MsTUFBTSxDQUFDVCxRQUFRVSxTQUFTLENBQUNILE1BQU0sQ0FBQ0ksSUFBSSxDQUFDLElBQUksR0FBRztZQUN4RFAsTUFBTSxJQUFJLENBQUNBLElBQUk7UUFDakI7SUFDRjtBQUNGO0FBRUFRLE9BQU9DLE9BQU8sR0FBR1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aWN0YWN0b2UvLi9ub2RlX21vZHVsZXMvQHJncm92ZS9wYXJzZS14bWwvc3JjL2xpYi9YbWxUZXh0LmpzP2YwN2EiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBYbWxOb2RlID0gcmVxdWlyZSgnLi9YbWxOb2RlJyk7XG5cbi8qKlxuVGV4dCBjb250ZW50IHdpdGhpbiBhbiBYTUwgZG9jdW1lbnQuXG5cbkBwdWJsaWNcbiovXG5jbGFzcyBYbWxUZXh0IGV4dGVuZHMgWG1sTm9kZSB7XG4gIC8qKlxuICBAcGFyYW0ge3N0cmluZ30gW3RleHRdXG4gICovXG4gIGNvbnN0cnVjdG9yKHRleHQgPSAnJykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICBUZXh0IGNvbnRlbnQgb2YgdGhpcyBub2RlLlxuXG4gICAgQHR5cGUge3N0cmluZ31cbiAgICBAcHVibGljXG4gICAgKi9cbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFhtbE5vZGUuVFlQRV9URVhUO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKFhtbE5vZGUucHJvdG90eXBlLnRvSlNPTi5jYWxsKHRoaXMpLCB7XG4gICAgICB0ZXh0OiB0aGlzLnRleHRcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFhtbFRleHQ7XG4iXSwibmFtZXMiOlsiWG1sTm9kZSIsInJlcXVpcmUiLCJYbWxUZXh0IiwiY29uc3RydWN0b3IiLCJ0ZXh0IiwidHlwZSIsIlRZUEVfVEVYVCIsInRvSlNPTiIsIk9iamVjdCIsImFzc2lnbiIsInByb3RvdHlwZSIsImNhbGwiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@rgrove/parse-xml/src/lib/XmlText.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@rgrove/parse-xml/src/lib/syntax.js":
/*!**********************************************************!*\
  !*** ./node_modules/@rgrove/parse-xml/src/lib/syntax.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// -- Exported Constants -------------------------------------------------------\n/**\nMapping of predefined entity names to their replacement values.\n\n@type {Readonly<{[name: string]: string}>}\n@see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-predefined-ent\n*/ const predefinedEntities = Object.freeze(Object.assign(Object.create(null), {\n    amp: \"&\",\n    apos: \"'\",\n    gt: \">\",\n    lt: \"<\",\n    quot: '\"'\n}));\nexports.predefinedEntities = predefinedEntities;\n// -- Exported Functions -------------------------------------------------------\n/**\nReturns `true` if _char_ is an XML `NameChar`, `false` if it isn't.\n\n@param {string} char\n@returns {boolean}\n@see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-NameChar\n*/ function isNameChar(char) {\n    if (isNameStartChar(char)) {\n        return true;\n    }\n    let cp = getCodePoint(char);\n    return cp === 0x2D // -\n     || cp === 0x2E // .\n     || cp >= 0x30 && cp <= 0x39 // 0-9\n     || cp === 0xB7 || cp >= 0x300 && cp <= 0x36F || cp >= 0x203F && cp <= 0x2040;\n}\nexports.isNameChar = isNameChar;\n/**\nReturns `true` if _char_ is an XML `NameStartChar`, `false` if it isn't.\n\n@param {string} char\n@returns {boolean}\n@see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-NameStartChar\n*/ function isNameStartChar(char) {\n    let cp = getCodePoint(char);\n    return cp === 0x3A // :\n     || cp === 0x5F // _\n     || cp >= 0x41 && cp <= 0x5A // A-Z\n     || cp >= 0x61 && cp <= 0x7A // a-z\n     || cp >= 0xC0 && cp <= 0xD6 || cp >= 0xD8 && cp <= 0xF6 || cp >= 0xF8 && cp <= 0x2FF || cp >= 0x370 && cp <= 0x37D || cp >= 0x37F && cp <= 0x1FFF || cp >= 0x200C && cp <= 0x200D || cp >= 0x2070 && cp <= 0x218F || cp >= 0x2C00 && cp <= 0x2FEF || cp >= 0x3001 && cp <= 0xD7FF || cp >= 0xF900 && cp <= 0xFDCF || cp >= 0xFDF0 && cp <= 0xFFFD || cp >= 0x10000 && cp <= 0xEFFFF;\n}\nexports.isNameStartChar = isNameStartChar;\n/**\nReturns `true` if _char_ is not a valid XML `Char`, `false` otherwise.\n\n@param {string} char\n@returns {boolean}\n@see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Char\n*/ function isNotXmlChar(char) {\n    return !isXmlChar(char);\n}\nexports.isNotXmlChar = isNotXmlChar;\n/**\nReturns `true` if _char_ is a valid reference character (which may appear\nbetween `&` and `;` in a reference), `false` otherwise.\n\n@param {string} char\n@returns {boolean}\n@see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-references\n*/ function isReferenceChar(char) {\n    return char === \"#\" || isNameChar(char);\n}\nexports.isReferenceChar = isReferenceChar;\n/**\nReturns `true` if _char_ is an XML whitespace character, `false` otherwise.\n\n@param {string} char\n@returns {boolean}\n@see https://www.w3.org/TR/2008/REC-xml-20081126/#white\n*/ function isWhitespace(char) {\n    let cp = getCodePoint(char);\n    return cp === 0x20 || cp === 0x9 || cp === 0xA || cp === 0xD;\n}\nexports.isWhitespace = isWhitespace;\n/**\nReturns `true` if _char_ is a valid XML `Char`, `false` otherwise.\n\n@param {string} char\n@returns {boolean}\n@see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Char\n*/ function isXmlChar(char) {\n    let cp = getCodePoint(char);\n    return cp === 0x9 || cp === 0xA || cp === 0xD || cp >= 0x20 && cp <= 0xD7FF || cp >= 0xE000 && cp <= 0xFFFD || cp >= 0x10000 && cp <= 0x10FFFF;\n}\nexports.isXmlChar = isXmlChar;\n// -- Private Functions --------------------------------------------------------\n/**\nReturns the Unicode code point value of the given character, or `-1` if _char_\nis empty.\n\n@param {string} char\n@returns {number}\n*/ function getCodePoint(char) {\n    return char.codePointAt(0) || -1;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJncm92ZS9wYXJzZS14bWwvc3JjL2xpYi9zeW50YXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxnRkFBZ0Y7QUFFaEY7Ozs7O0FBS0EsR0FDQSxNQUFNQSxxQkFBcUJDLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0UsTUFBTSxDQUFDRixPQUFPRyxNQUFNLENBQUMsT0FBTztJQUMxRUMsS0FBSztJQUNMQyxNQUFNO0lBQ05DLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxNQUFNO0FBQ1I7QUFFQUMsMEJBQTBCLEdBQUdWO0FBRTdCLGdGQUFnRjtBQUVoRjs7Ozs7O0FBTUEsR0FDQSxTQUFTVyxXQUFXQyxJQUFJO0lBQ3RCLElBQUlDLGdCQUFnQkQsT0FBTztRQUN6QixPQUFPO0lBQ1Q7SUFFQSxJQUFJRSxLQUFLQyxhQUFhSDtJQUV0QixPQUFPRSxPQUFPLEtBQUssSUFBSTtRQUNsQkEsT0FBTyxLQUFLLElBQUk7UUFDZkEsTUFBTSxRQUFRQSxNQUFNLEtBQU0sTUFBTTtRQUNqQ0EsT0FBTyxRQUNOQSxNQUFNLFNBQVNBLE1BQU0sU0FDckJBLE1BQU0sVUFBVUEsTUFBTTtBQUM5QjtBQUVBSixrQkFBa0IsR0FBR0M7QUFFckI7Ozs7OztBQU1BLEdBQ0EsU0FBU0UsZ0JBQWdCRCxJQUFJO0lBQzNCLElBQUlFLEtBQUtDLGFBQWFIO0lBRXRCLE9BQU9FLE9BQU8sS0FBSyxJQUFJO1FBQ2xCQSxPQUFPLEtBQUssSUFBSTtRQUNmQSxNQUFNLFFBQVFBLE1BQU0sS0FBTSxNQUFNO1FBQ2hDQSxNQUFNLFFBQVFBLE1BQU0sS0FBTSxNQUFNO1FBQ2hDQSxNQUFNLFFBQVFBLE1BQU0sUUFDcEJBLE1BQU0sUUFBUUEsTUFBTSxRQUNwQkEsTUFBTSxRQUFRQSxNQUFNLFNBQ3BCQSxNQUFNLFNBQVNBLE1BQU0sU0FDckJBLE1BQU0sU0FBU0EsTUFBTSxVQUNyQkEsTUFBTSxVQUFVQSxNQUFNLFVBQ3RCQSxNQUFNLFVBQVVBLE1BQU0sVUFDdEJBLE1BQU0sVUFBVUEsTUFBTSxVQUN0QkEsTUFBTSxVQUFVQSxNQUFNLFVBQ3RCQSxNQUFNLFVBQVVBLE1BQU0sVUFDdEJBLE1BQU0sVUFBVUEsTUFBTSxVQUN0QkEsTUFBTSxXQUFXQSxNQUFNO0FBQy9CO0FBRUFKLHVCQUF1QixHQUFHRztBQUUxQjs7Ozs7O0FBTUEsR0FDQSxTQUFTRyxhQUFhSixJQUFJO0lBQ3hCLE9BQU8sQ0FBQ0ssVUFBVUw7QUFDcEI7QUFFQUYsb0JBQW9CLEdBQUdNO0FBRXZCOzs7Ozs7O0FBT0EsR0FDQSxTQUFTRSxnQkFBZ0JOLElBQUk7SUFDM0IsT0FBT0EsU0FBUyxPQUFPRCxXQUFXQztBQUNwQztBQUVBRix1QkFBdUIsR0FBR1E7QUFFMUI7Ozs7OztBQU1BLEdBQ0EsU0FBU0MsYUFBYVAsSUFBSTtJQUN4QixJQUFJRSxLQUFLQyxhQUFhSDtJQUV0QixPQUFPRSxPQUFPLFFBQ1RBLE9BQU8sT0FDUEEsT0FBTyxPQUNQQSxPQUFPO0FBQ2Q7QUFFQUosb0JBQW9CLEdBQUdTO0FBRXZCOzs7Ozs7QUFNQSxHQUNBLFNBQVNGLFVBQVVMLElBQUk7SUFDckIsSUFBSUUsS0FBS0MsYUFBYUg7SUFFdEIsT0FBT0UsT0FBTyxPQUNUQSxPQUFPLE9BQ1BBLE9BQU8sT0FDTkEsTUFBTSxRQUFRQSxNQUFNLFVBQ3BCQSxNQUFNLFVBQVVBLE1BQU0sVUFDdEJBLE1BQU0sV0FBV0EsTUFBTTtBQUMvQjtBQUVBSixpQkFBaUIsR0FBR087QUFFcEIsZ0ZBQWdGO0FBRWhGOzs7Ozs7QUFNQSxHQUNBLFNBQVNGLGFBQWFILElBQUk7SUFDeEIsT0FBT0EsS0FBS1EsV0FBVyxDQUFDLE1BQU0sQ0FBQztBQUNqQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RpY3RhY3RvZS8uL25vZGVfbW9kdWxlcy9Acmdyb3ZlL3BhcnNlLXhtbC9zcmMvbGliL3N5bnRheC5qcz81ZDZhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gLS0gRXhwb3J0ZWQgQ29uc3RhbnRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG5NYXBwaW5nIG9mIHByZWRlZmluZWQgZW50aXR5IG5hbWVzIHRvIHRoZWlyIHJlcGxhY2VtZW50IHZhbHVlcy5cblxuQHR5cGUge1JlYWRvbmx5PHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfT59XG5Ac2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy14bWwtMjAwODExMjYvI3NlYy1wcmVkZWZpbmVkLWVudFxuKi9cbmNvbnN0IHByZWRlZmluZWRFbnRpdGllcyA9IE9iamVjdC5mcmVlemUoT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gIGFtcDogJyYnLFxuICBhcG9zOiBcIidcIixcbiAgZ3Q6ICc+JyxcbiAgbHQ6ICc8JyxcbiAgcXVvdDogJ1wiJ1xufSkpO1xuXG5leHBvcnRzLnByZWRlZmluZWRFbnRpdGllcyA9IHByZWRlZmluZWRFbnRpdGllcztcblxuLy8gLS0gRXhwb3J0ZWQgRnVuY3Rpb25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG5SZXR1cm5zIGB0cnVlYCBpZiBfY2hhcl8gaXMgYW4gWE1MIGBOYW1lQ2hhcmAsIGBmYWxzZWAgaWYgaXQgaXNuJ3QuXG5cbkBwYXJhbSB7c3RyaW5nfSBjaGFyXG5AcmV0dXJucyB7Ym9vbGVhbn1cbkBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLXhtbC0yMDA4MTEyNi8jTlQtTmFtZUNoYXJcbiovXG5mdW5jdGlvbiBpc05hbWVDaGFyKGNoYXIpIHtcbiAgaWYgKGlzTmFtZVN0YXJ0Q2hhcihjaGFyKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgbGV0IGNwID0gZ2V0Q29kZVBvaW50KGNoYXIpO1xuXG4gIHJldHVybiBjcCA9PT0gMHgyRCAvLyAtXG4gICAgfHwgY3AgPT09IDB4MkUgLy8gLlxuICAgIHx8IChjcCA+PSAweDMwICYmIGNwIDw9IDB4MzkpIC8vIDAtOVxuICAgIHx8IGNwID09PSAweEI3XG4gICAgfHwgKGNwID49IDB4MzAwICYmIGNwIDw9IDB4MzZGKVxuICAgIHx8IChjcCA+PSAweDIwM0YgJiYgY3AgPD0gMHgyMDQwKTtcbn1cblxuZXhwb3J0cy5pc05hbWVDaGFyID0gaXNOYW1lQ2hhcjtcblxuLyoqXG5SZXR1cm5zIGB0cnVlYCBpZiBfY2hhcl8gaXMgYW4gWE1MIGBOYW1lU3RhcnRDaGFyYCwgYGZhbHNlYCBpZiBpdCBpc24ndC5cblxuQHBhcmFtIHtzdHJpbmd9IGNoYXJcbkByZXR1cm5zIHtib29sZWFufVxuQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvMjAwOC9SRUMteG1sLTIwMDgxMTI2LyNOVC1OYW1lU3RhcnRDaGFyXG4qL1xuZnVuY3Rpb24gaXNOYW1lU3RhcnRDaGFyKGNoYXIpIHtcbiAgbGV0IGNwID0gZ2V0Q29kZVBvaW50KGNoYXIpO1xuXG4gIHJldHVybiBjcCA9PT0gMHgzQSAvLyA6XG4gICAgfHwgY3AgPT09IDB4NUYgLy8gX1xuICAgIHx8IChjcCA+PSAweDQxICYmIGNwIDw9IDB4NUEpIC8vIEEtWlxuICAgIHx8IChjcCA+PSAweDYxICYmIGNwIDw9IDB4N0EpIC8vIGEtelxuICAgIHx8IChjcCA+PSAweEMwICYmIGNwIDw9IDB4RDYpXG4gICAgfHwgKGNwID49IDB4RDggJiYgY3AgPD0gMHhGNilcbiAgICB8fCAoY3AgPj0gMHhGOCAmJiBjcCA8PSAweDJGRilcbiAgICB8fCAoY3AgPj0gMHgzNzAgJiYgY3AgPD0gMHgzN0QpXG4gICAgfHwgKGNwID49IDB4MzdGICYmIGNwIDw9IDB4MUZGRilcbiAgICB8fCAoY3AgPj0gMHgyMDBDICYmIGNwIDw9IDB4MjAwRClcbiAgICB8fCAoY3AgPj0gMHgyMDcwICYmIGNwIDw9IDB4MjE4RilcbiAgICB8fCAoY3AgPj0gMHgyQzAwICYmIGNwIDw9IDB4MkZFRilcbiAgICB8fCAoY3AgPj0gMHgzMDAxICYmIGNwIDw9IDB4RDdGRilcbiAgICB8fCAoY3AgPj0gMHhGOTAwICYmIGNwIDw9IDB4RkRDRilcbiAgICB8fCAoY3AgPj0gMHhGREYwICYmIGNwIDw9IDB4RkZGRClcbiAgICB8fCAoY3AgPj0gMHgxMDAwMCAmJiBjcCA8PSAweEVGRkZGKTtcbn1cblxuZXhwb3J0cy5pc05hbWVTdGFydENoYXIgPSBpc05hbWVTdGFydENoYXI7XG5cbi8qKlxuUmV0dXJucyBgdHJ1ZWAgaWYgX2NoYXJfIGlzIG5vdCBhIHZhbGlkIFhNTCBgQ2hhcmAsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuXG5AcGFyYW0ge3N0cmluZ30gY2hhclxuQHJldHVybnMge2Jvb2xlYW59XG5Ac2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy14bWwtMjAwODExMjYvI05ULUNoYXJcbiovXG5mdW5jdGlvbiBpc05vdFhtbENoYXIoY2hhcikge1xuICByZXR1cm4gIWlzWG1sQ2hhcihjaGFyKTtcbn1cblxuZXhwb3J0cy5pc05vdFhtbENoYXIgPSBpc05vdFhtbENoYXI7XG5cbi8qKlxuUmV0dXJucyBgdHJ1ZWAgaWYgX2NoYXJfIGlzIGEgdmFsaWQgcmVmZXJlbmNlIGNoYXJhY3RlciAod2hpY2ggbWF5IGFwcGVhclxuYmV0d2VlbiBgJmAgYW5kIGA7YCBpbiBhIHJlZmVyZW5jZSksIGBmYWxzZWAgb3RoZXJ3aXNlLlxuXG5AcGFyYW0ge3N0cmluZ30gY2hhclxuQHJldHVybnMge2Jvb2xlYW59XG5Ac2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy14bWwtMjAwODExMjYvI3NlYy1yZWZlcmVuY2VzXG4qL1xuZnVuY3Rpb24gaXNSZWZlcmVuY2VDaGFyKGNoYXIpIHtcbiAgcmV0dXJuIGNoYXIgPT09ICcjJyB8fCBpc05hbWVDaGFyKGNoYXIpO1xufVxuXG5leHBvcnRzLmlzUmVmZXJlbmNlQ2hhciA9IGlzUmVmZXJlbmNlQ2hhcjtcblxuLyoqXG5SZXR1cm5zIGB0cnVlYCBpZiBfY2hhcl8gaXMgYW4gWE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyLCBgZmFsc2VgIG90aGVyd2lzZS5cblxuQHBhcmFtIHtzdHJpbmd9IGNoYXJcbkByZXR1cm5zIHtib29sZWFufVxuQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvMjAwOC9SRUMteG1sLTIwMDgxMTI2LyN3aGl0ZVxuKi9cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjaGFyKSB7XG4gIGxldCBjcCA9IGdldENvZGVQb2ludChjaGFyKTtcblxuICByZXR1cm4gY3AgPT09IDB4MjBcbiAgICB8fCBjcCA9PT0gMHg5XG4gICAgfHwgY3AgPT09IDB4QVxuICAgIHx8IGNwID09PSAweEQ7XG59XG5cbmV4cG9ydHMuaXNXaGl0ZXNwYWNlID0gaXNXaGl0ZXNwYWNlO1xuXG4vKipcblJldHVybnMgYHRydWVgIGlmIF9jaGFyXyBpcyBhIHZhbGlkIFhNTCBgQ2hhcmAsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuXG5AcGFyYW0ge3N0cmluZ30gY2hhclxuQHJldHVybnMge2Jvb2xlYW59XG5Ac2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy14bWwtMjAwODExMjYvI05ULUNoYXJcbiovXG5mdW5jdGlvbiBpc1htbENoYXIoY2hhcikge1xuICBsZXQgY3AgPSBnZXRDb2RlUG9pbnQoY2hhcik7XG5cbiAgcmV0dXJuIGNwID09PSAweDlcbiAgICB8fCBjcCA9PT0gMHhBXG4gICAgfHwgY3AgPT09IDB4RFxuICAgIHx8IChjcCA+PSAweDIwICYmIGNwIDw9IDB4RDdGRilcbiAgICB8fCAoY3AgPj0gMHhFMDAwICYmIGNwIDw9IDB4RkZGRClcbiAgICB8fCAoY3AgPj0gMHgxMDAwMCAmJiBjcCA8PSAweDEwRkZGRik7XG59XG5cbmV4cG9ydHMuaXNYbWxDaGFyID0gaXNYbWxDaGFyO1xuXG4vLyAtLSBQcml2YXRlIEZ1bmN0aW9ucyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcblJldHVybnMgdGhlIFVuaWNvZGUgY29kZSBwb2ludCB2YWx1ZSBvZiB0aGUgZ2l2ZW4gY2hhcmFjdGVyLCBvciBgLTFgIGlmIF9jaGFyX1xuaXMgZW1wdHkuXG5cbkBwYXJhbSB7c3RyaW5nfSBjaGFyXG5AcmV0dXJucyB7bnVtYmVyfVxuKi9cbmZ1bmN0aW9uIGdldENvZGVQb2ludChjaGFyKSB7XG4gIHJldHVybiBjaGFyLmNvZGVQb2ludEF0KDApIHx8IC0xO1xufVxuIl0sIm5hbWVzIjpbInByZWRlZmluZWRFbnRpdGllcyIsIk9iamVjdCIsImZyZWV6ZSIsImFzc2lnbiIsImNyZWF0ZSIsImFtcCIsImFwb3MiLCJndCIsImx0IiwicXVvdCIsImV4cG9ydHMiLCJpc05hbWVDaGFyIiwiY2hhciIsImlzTmFtZVN0YXJ0Q2hhciIsImNwIiwiZ2V0Q29kZVBvaW50IiwiaXNOb3RYbWxDaGFyIiwiaXNYbWxDaGFyIiwiaXNSZWZlcmVuY2VDaGFyIiwiaXNXaGl0ZXNwYWNlIiwiY29kZVBvaW50QXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@rgrove/parse-xml/src/lib/syntax.js\n");

/***/ })

};
;