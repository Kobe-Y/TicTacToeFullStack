/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ical.js";
exports.ids = ["vendor-chunks/ical.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/ical.js/build/ical.js":
/*!********************************************!*\
  !*** ./node_modules/ical.js/build/ical.js ***!
  \********************************************/
/***/ ((module) => {

eval("/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2021 */ /* jshint ignore:start */ var ICAL;\n(function() {\n    /* istanbul ignore next */ if (true) {\n        // CommonJS, where exports may be different each time.\n        ICAL = module.exports;\n    } else {}\n})();\n/* jshint ignore:end */ /* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */ /**\n * The number of characters before iCalendar line folding should occur\n * @type {Number}\n * @default 75\n */ ICAL.foldLength = 75;\n/**\n * The character(s) to be used for a newline. The default value is provided by\n * rfc5545.\n * @type {String}\n * @default \"\\r\\n\"\n */ ICAL.newLineChar = \"\\r\\n\";\n/**\n * Helper functions used in various places within ical.js\n * @namespace\n */ ICAL.helpers = {\n    /**\n   * Compiles a list of all referenced TZIDs in all subcomponents and\n   * removes any extra VTIMEZONE subcomponents. In addition, if any TZIDs\n   * are referenced by a component, but a VTIMEZONE does not exist,\n   * an attempt will be made to generate a VTIMEZONE using ICAL.TimezoneService.\n   *\n   * @param {ICAL.Component} vcal     The top-level VCALENDAR component.\n   * @return {ICAL.Component}         The ICAL.Component that was passed in.\n   */ updateTimezones: function(vcal) {\n        var allsubs, properties, vtimezones, reqTzid, i, tzid;\n        if (!vcal || vcal.name !== \"vcalendar\") {\n            //not a top-level vcalendar component\n            return vcal;\n        }\n        //Store vtimezone subcomponents in an object reference by tzid.\n        //Store properties from everything else in another array\n        allsubs = vcal.getAllSubcomponents();\n        properties = [];\n        vtimezones = {};\n        for(i = 0; i < allsubs.length; i++){\n            if (allsubs[i].name === \"vtimezone\") {\n                tzid = allsubs[i].getFirstProperty(\"tzid\").getFirstValue();\n                vtimezones[tzid] = allsubs[i];\n            } else {\n                properties = properties.concat(allsubs[i].getAllProperties());\n            }\n        }\n        //create an object with one entry for each required tz\n        reqTzid = {};\n        for(i = 0; i < properties.length; i++){\n            if (tzid = properties[i].getParameter(\"tzid\")) {\n                reqTzid[tzid] = true;\n            }\n        }\n        //delete any vtimezones that are not on the reqTzid list.\n        for(i in vtimezones){\n            if (vtimezones.hasOwnProperty(i) && !reqTzid[i]) {\n                vcal.removeSubcomponent(vtimezones[i]);\n            }\n        }\n        //create any missing, but registered timezones\n        for(i in reqTzid){\n            if (reqTzid.hasOwnProperty(i) && !vtimezones[i] && ICAL.TimezoneService.has(i)) {\n                vcal.addSubcomponent(ICAL.TimezoneService.get(i).component);\n            }\n        }\n        return vcal;\n    },\n    /**\n   * Checks if the given type is of the number type and also NaN.\n   *\n   * @param {Number} number     The number to check\n   * @return {Boolean}          True, if the number is strictly NaN\n   */ isStrictlyNaN: function(number) {\n        return typeof number === \"number\" && isNaN(number);\n    },\n    /**\n   * Parses a string value that is expected to be an integer, when the valid is\n   * not an integer throws a decoration error.\n   *\n   * @param {String} string     Raw string input\n   * @return {Number}           Parsed integer\n   */ strictParseInt: function(string) {\n        var result = parseInt(string, 10);\n        if (ICAL.helpers.isStrictlyNaN(result)) {\n            throw new Error('Could not extract integer from \"' + string + '\"');\n        }\n        return result;\n    },\n    /**\n   * Creates or returns a class instance of a given type with the initialization\n   * data if the data is not already an instance of the given type.\n   *\n   * @example\n   * var time = new ICAL.Time(...);\n   * var result = ICAL.helpers.formatClassType(time, ICAL.Time);\n   *\n   * (result instanceof ICAL.Time)\n   * // => true\n   *\n   * result = ICAL.helpers.formatClassType({}, ICAL.Time);\n   * (result isntanceof ICAL.Time)\n   * // => true\n   *\n   *\n   * @param {Object} data       object initialization data\n   * @param {Object} type       object type (like ICAL.Time)\n   * @return {?}                An instance of the found type.\n   */ formatClassType: function formatClassType(data, type) {\n        if (typeof data === \"undefined\") {\n            return undefined;\n        }\n        if (data instanceof type) {\n            return data;\n        }\n        return new type(data);\n    },\n    /**\n   * Identical to indexOf but will only match values when they are not preceded\n   * by a backslash character.\n   *\n   * @param {String} buffer         String to search\n   * @param {String} search         Value to look for\n   * @param {Number} pos            Start position\n   * @return {Number}               The position, or -1 if not found\n   */ unescapedIndexOf: function(buffer, search, pos) {\n        while((pos = buffer.indexOf(search, pos)) !== -1){\n            if (pos > 0 && buffer[pos - 1] === \"\\\\\") {\n                pos += 1;\n            } else {\n                return pos;\n            }\n        }\n        return -1;\n    },\n    /**\n   * Find the index for insertion using binary search.\n   *\n   * @param {Array} list            The list to search\n   * @param {?} seekVal             The value to insert\n   * @param {function(?,?)} cmpfunc The comparison func, that can\n   *                                  compare two seekVals\n   * @return {Number}               The insert position\n   */ binsearchInsert: function(list, seekVal, cmpfunc) {\n        if (!list.length) return 0;\n        var low = 0, high = list.length - 1, mid, cmpval;\n        while(low <= high){\n            mid = low + Math.floor((high - low) / 2);\n            cmpval = cmpfunc(seekVal, list[mid]);\n            if (cmpval < 0) high = mid - 1;\n            else if (cmpval > 0) low = mid + 1;\n            else break;\n        }\n        if (cmpval < 0) return mid; // insertion is displacing, so use mid outright.\n        else if (cmpval > 0) return mid + 1;\n        else return mid;\n    },\n    /**\n   * Convenience function for debug output\n   * @private\n   */ dumpn: /* istanbul ignore next */ function() {\n        if (!ICAL.debug) {\n            return;\n        }\n        if (typeof console !== \"undefined\" && \"log\" in console) {\n            ICAL.helpers.dumpn = function consoleDumpn(input) {\n                console.log(input);\n            };\n        } else {\n            ICAL.helpers.dumpn = function geckoDumpn(input) {\n                dump(input + \"\\n\");\n            };\n        }\n        ICAL.helpers.dumpn(arguments[0]);\n    },\n    /**\n   * Clone the passed object or primitive. By default a shallow clone will be\n   * executed.\n   *\n   * @param {*} aSrc            The thing to clone\n   * @param {Boolean=} aDeep    If true, a deep clone will be performed\n   * @return {*}                The copy of the thing\n   */ clone: function(aSrc, aDeep) {\n        if (!aSrc || typeof aSrc != \"object\") {\n            return aSrc;\n        } else if (aSrc instanceof Date) {\n            return new Date(aSrc.getTime());\n        } else if (\"clone\" in aSrc) {\n            return aSrc.clone();\n        } else if (Array.isArray(aSrc)) {\n            var arr = [];\n            for(var i = 0; i < aSrc.length; i++){\n                arr.push(aDeep ? ICAL.helpers.clone(aSrc[i], true) : aSrc[i]);\n            }\n            return arr;\n        } else {\n            var obj = {};\n            for(var name in aSrc){\n                // uses prototype method to allow use of Object.create(null);\n                /* istanbul ignore else */ if (Object.prototype.hasOwnProperty.call(aSrc, name)) {\n                    if (aDeep) {\n                        obj[name] = ICAL.helpers.clone(aSrc[name], true);\n                    } else {\n                        obj[name] = aSrc[name];\n                    }\n                }\n            }\n            return obj;\n        }\n    },\n    /**\n   * Performs iCalendar line folding. A line ending character is inserted and\n   * the next line begins with a whitespace.\n   *\n   * @example\n   * SUMMARY:This line will be fold\n   *  ed right in the middle of a word.\n   *\n   * @param {String} aLine      The line to fold\n   * @return {String}           The folded line\n   */ foldline: function foldline(aLine) {\n        var result = \"\";\n        var line = aLine || \"\", pos = 0, line_length = 0;\n        //pos counts position in line for the UTF-16 presentation\n        //line_length counts the bytes for the UTF-8 presentation\n        while(line.length){\n            var cp = line.codePointAt(pos);\n            if (cp < 128) ++line_length;\n            else if (cp < 2048) line_length += 2; //needs 2 UTF-8 bytes\n            else if (cp < 65536) line_length += 3;\n            else line_length += 4; //cp is less than 1114112\n            if (line_length < ICAL.foldLength + 1) pos += cp > 65535 ? 2 : 1;\n            else {\n                result += ICAL.newLineChar + \" \" + line.substring(0, pos);\n                line = line.substring(pos);\n                pos = line_length = 0;\n            }\n        }\n        return result.substr(ICAL.newLineChar.length + 1);\n    },\n    /**\n   * Pads the given string or number with zeros so it will have at least two\n   * characters.\n   *\n   * @param {String|Number} data    The string or number to pad\n   * @return {String}               The number padded as a string\n   */ pad2: function pad(data) {\n        if (typeof data !== \"string\") {\n            // handle fractions.\n            if (typeof data === \"number\") {\n                data = parseInt(data);\n            }\n            data = String(data);\n        }\n        var len = data.length;\n        switch(len){\n            case 0:\n                return \"00\";\n            case 1:\n                return \"0\" + data;\n            default:\n                return data;\n        }\n    },\n    /**\n   * Truncates the given number, correctly handling negative numbers.\n   *\n   * @param {Number} number     The number to truncate\n   * @return {Number}           The truncated number\n   */ trunc: function trunc(number) {\n        return number < 0 ? Math.ceil(number) : Math.floor(number);\n    },\n    /**\n   * Poor-man's cross-browser inheritance for JavaScript. Doesn't support all\n   * the features, but enough for our usage.\n   *\n   * @param {Function} base     The base class constructor function.\n   * @param {Function} child    The child class constructor function.\n   * @param {Object} extra      Extends the prototype with extra properties\n   *                              and methods\n   */ inherits: function(base, child, extra) {\n        function F() {}\n        F.prototype = base.prototype;\n        child.prototype = new F();\n        if (extra) {\n            ICAL.helpers.extend(extra, child.prototype);\n        }\n    },\n    /**\n   * Poor-man's cross-browser object extension. Doesn't support all the\n   * features, but enough for our usage. Note that the target's properties are\n   * not overwritten with the source properties.\n   *\n   * @example\n   * var child = ICAL.helpers.extend(parent, {\n   *   \"bar\": 123\n   * });\n   *\n   * @param {Object} source     The object to extend\n   * @param {Object} target     The object to extend with\n   * @return {Object}           Returns the target.\n   */ extend: function(source, target) {\n        for(var key in source){\n            var descr = Object.getOwnPropertyDescriptor(source, key);\n            if (descr && !Object.getOwnPropertyDescriptor(target, key)) {\n                Object.defineProperty(target, key, descr);\n            }\n        }\n        return target;\n    }\n};\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */ /** @namespace ICAL */ /**\n * This symbol is further described later on\n * @ignore\n */ ICAL.design = function() {\n    \"use strict\";\n    var FROM_ICAL_NEWLINE = /\\\\\\\\|\\\\;|\\\\,|\\\\[Nn]/g;\n    var TO_ICAL_NEWLINE = /\\\\|;|,|\\n/g;\n    var FROM_VCARD_NEWLINE = /\\\\\\\\|\\\\,|\\\\[Nn]/g;\n    var TO_VCARD_NEWLINE = /\\\\|,|\\n/g;\n    function createTextType(fromNewline, toNewline) {\n        var result = {\n            matches: /.*/,\n            fromICAL: function(aValue, structuredEscape) {\n                return replaceNewline(aValue, fromNewline, structuredEscape);\n            },\n            toICAL: function(aValue, structuredEscape) {\n                var regEx = toNewline;\n                if (structuredEscape) regEx = new RegExp(regEx.source + \"|\" + structuredEscape);\n                return aValue.replace(regEx, function(str) {\n                    switch(str){\n                        case \"\\\\\":\n                            return \"\\\\\\\\\";\n                        case \";\":\n                            return \"\\\\;\";\n                        case \",\":\n                            return \"\\\\,\";\n                        case \"\\n\":\n                            return \"\\\\n\";\n                        /* istanbul ignore next */ default:\n                            return str;\n                    }\n                });\n            }\n        };\n        return result;\n    }\n    // default types used multiple times\n    var DEFAULT_TYPE_TEXT = {\n        defaultType: \"text\"\n    };\n    var DEFAULT_TYPE_TEXT_MULTI = {\n        defaultType: \"text\",\n        multiValue: \",\"\n    };\n    var DEFAULT_TYPE_TEXT_STRUCTURED = {\n        defaultType: \"text\",\n        structuredValue: \";\"\n    };\n    var DEFAULT_TYPE_INTEGER = {\n        defaultType: \"integer\"\n    };\n    var DEFAULT_TYPE_DATETIME_DATE = {\n        defaultType: \"date-time\",\n        allowedTypes: [\n            \"date-time\",\n            \"date\"\n        ]\n    };\n    var DEFAULT_TYPE_DATETIME = {\n        defaultType: \"date-time\"\n    };\n    var DEFAULT_TYPE_URI = {\n        defaultType: \"uri\"\n    };\n    var DEFAULT_TYPE_UTCOFFSET = {\n        defaultType: \"utc-offset\"\n    };\n    var DEFAULT_TYPE_RECUR = {\n        defaultType: \"recur\"\n    };\n    var DEFAULT_TYPE_DATE_ANDOR_TIME = {\n        defaultType: \"date-and-or-time\",\n        allowedTypes: [\n            \"date-time\",\n            \"date\",\n            \"text\"\n        ]\n    };\n    function replaceNewlineReplace(string) {\n        switch(string){\n            case \"\\\\\\\\\":\n                return \"\\\\\";\n            case \"\\\\;\":\n                return \";\";\n            case \"\\\\,\":\n                return \",\";\n            case \"\\\\n\":\n            case \"\\\\N\":\n                return \"\\n\";\n            /* istanbul ignore next */ default:\n                return string;\n        }\n    }\n    function replaceNewline(value1, newline, structuredEscape) {\n        // avoid regex when possible.\n        if (value1.indexOf(\"\\\\\") === -1) {\n            return value1;\n        }\n        if (structuredEscape) newline = new RegExp(newline.source + \"|\\\\\\\\\" + structuredEscape);\n        return value1.replace(newline, replaceNewlineReplace);\n    }\n    var commonProperties = {\n        \"categories\": DEFAULT_TYPE_TEXT_MULTI,\n        \"url\": DEFAULT_TYPE_URI,\n        \"version\": DEFAULT_TYPE_TEXT,\n        \"uid\": DEFAULT_TYPE_TEXT\n    };\n    var commonValues = {\n        \"boolean\": {\n            values: [\n                \"TRUE\",\n                \"FALSE\"\n            ],\n            fromICAL: function(aValue) {\n                switch(aValue){\n                    case \"TRUE\":\n                        return true;\n                    case \"FALSE\":\n                        return false;\n                    default:\n                        //TODO: parser warning\n                        return false;\n                }\n            },\n            toICAL: function(aValue) {\n                if (aValue) {\n                    return \"TRUE\";\n                }\n                return \"FALSE\";\n            }\n        },\n        float: {\n            matches: /^[+-]?\\d+\\.\\d+$/,\n            fromICAL: function(aValue) {\n                var parsed = parseFloat(aValue);\n                if (ICAL.helpers.isStrictlyNaN(parsed)) {\n                    // TODO: parser warning\n                    return 0.0;\n                }\n                return parsed;\n            },\n            toICAL: function(aValue) {\n                return String(aValue);\n            }\n        },\n        integer: {\n            fromICAL: function(aValue) {\n                var parsed = parseInt(aValue);\n                if (ICAL.helpers.isStrictlyNaN(parsed)) {\n                    return 0;\n                }\n                return parsed;\n            },\n            toICAL: function(aValue) {\n                return String(aValue);\n            }\n        },\n        \"utc-offset\": {\n            toICAL: function(aValue) {\n                if (aValue.length < 7) {\n                    // no seconds\n                    // -0500\n                    return aValue.substr(0, 3) + aValue.substr(4, 2);\n                } else {\n                    // seconds\n                    // -050000\n                    return aValue.substr(0, 3) + aValue.substr(4, 2) + aValue.substr(7, 2);\n                }\n            },\n            fromICAL: function(aValue) {\n                if (aValue.length < 6) {\n                    // no seconds\n                    // -05:00\n                    return aValue.substr(0, 3) + \":\" + aValue.substr(3, 2);\n                } else {\n                    // seconds\n                    // -05:00:00\n                    return aValue.substr(0, 3) + \":\" + aValue.substr(3, 2) + \":\" + aValue.substr(5, 2);\n                }\n            },\n            decorate: function(aValue) {\n                return ICAL.UtcOffset.fromString(aValue);\n            },\n            undecorate: function(aValue) {\n                return aValue.toString();\n            }\n        }\n    };\n    var icalParams = {\n        // Although the syntax is DQUOTE uri DQUOTE, I don't think we should\n        // enfoce anything aside from it being a valid content line.\n        //\n        // At least some params require - if multi values are used - DQUOTEs\n        // for each of its values - e.g. delegated-from=\"uri1\",\"uri2\"\n        // To indicate this, I introduced the new k/v pair\n        // multiValueSeparateDQuote: true\n        //\n        // \"ALTREP\": { ... },\n        // CN just wants a param-value\n        // \"CN\": { ... }\n        \"cutype\": {\n            values: [\n                \"INDIVIDUAL\",\n                \"GROUP\",\n                \"RESOURCE\",\n                \"ROOM\",\n                \"UNKNOWN\"\n            ],\n            allowXName: true,\n            allowIanaToken: true\n        },\n        \"delegated-from\": {\n            valueType: \"cal-address\",\n            multiValue: \",\",\n            multiValueSeparateDQuote: true\n        },\n        \"delegated-to\": {\n            valueType: \"cal-address\",\n            multiValue: \",\",\n            multiValueSeparateDQuote: true\n        },\n        // \"DIR\": { ... }, // See ALTREP\n        \"encoding\": {\n            values: [\n                \"8BIT\",\n                \"BASE64\"\n            ]\n        },\n        // \"FMTTYPE\": { ... }, // See ALTREP\n        \"fbtype\": {\n            values: [\n                \"FREE\",\n                \"BUSY\",\n                \"BUSY-UNAVAILABLE\",\n                \"BUSY-TENTATIVE\"\n            ],\n            allowXName: true,\n            allowIanaToken: true\n        },\n        // \"LANGUAGE\": { ... }, // See ALTREP\n        \"member\": {\n            valueType: \"cal-address\",\n            multiValue: \",\",\n            multiValueSeparateDQuote: true\n        },\n        \"partstat\": {\n            // TODO These values are actually different per-component\n            values: [\n                \"NEEDS-ACTION\",\n                \"ACCEPTED\",\n                \"DECLINED\",\n                \"TENTATIVE\",\n                \"DELEGATED\",\n                \"COMPLETED\",\n                \"IN-PROCESS\"\n            ],\n            allowXName: true,\n            allowIanaToken: true\n        },\n        \"range\": {\n            values: [\n                \"THISANDFUTURE\"\n            ]\n        },\n        \"related\": {\n            values: [\n                \"START\",\n                \"END\"\n            ]\n        },\n        \"reltype\": {\n            values: [\n                \"PARENT\",\n                \"CHILD\",\n                \"SIBLING\"\n            ],\n            allowXName: true,\n            allowIanaToken: true\n        },\n        \"role\": {\n            values: [\n                \"REQ-PARTICIPANT\",\n                \"CHAIR\",\n                \"OPT-PARTICIPANT\",\n                \"NON-PARTICIPANT\"\n            ],\n            allowXName: true,\n            allowIanaToken: true\n        },\n        \"rsvp\": {\n            values: [\n                \"TRUE\",\n                \"FALSE\"\n            ]\n        },\n        \"sent-by\": {\n            valueType: \"cal-address\"\n        },\n        \"tzid\": {\n            matches: /^\\//\n        },\n        \"value\": {\n            // since the value here is a 'type' lowercase is used.\n            values: [\n                \"binary\",\n                \"boolean\",\n                \"cal-address\",\n                \"date\",\n                \"date-time\",\n                \"duration\",\n                \"float\",\n                \"integer\",\n                \"period\",\n                \"recur\",\n                \"text\",\n                \"time\",\n                \"uri\",\n                \"utc-offset\"\n            ],\n            allowXName: true,\n            allowIanaToken: true\n        }\n    };\n    // When adding a value here, be sure to add it to the parameter types!\n    var icalValues = ICAL.helpers.extend(commonValues, {\n        text: createTextType(FROM_ICAL_NEWLINE, TO_ICAL_NEWLINE),\n        uri: {\n        },\n        \"binary\": {\n            decorate: function(aString) {\n                return ICAL.Binary.fromString(aString);\n            },\n            undecorate: function(aBinary) {\n                return aBinary.toString();\n            }\n        },\n        \"cal-address\": {\n        },\n        \"date\": {\n            decorate: function(aValue, aProp) {\n                if (design.strict) {\n                    return ICAL.Time.fromDateString(aValue, aProp);\n                } else {\n                    return ICAL.Time.fromString(aValue, aProp);\n                }\n            },\n            /**\n       * undecorates a time object.\n       */ undecorate: function(aValue) {\n                return aValue.toString();\n            },\n            fromICAL: function(aValue) {\n                // from: 20120901\n                // to: 2012-09-01\n                if (!design.strict && aValue.length >= 15) {\n                    // This is probably a date-time, e.g. 20120901T130000Z\n                    return icalValues[\"date-time\"].fromICAL(aValue);\n                } else {\n                    return aValue.substr(0, 4) + \"-\" + aValue.substr(4, 2) + \"-\" + aValue.substr(6, 2);\n                }\n            },\n            toICAL: function(aValue) {\n                // from: 2012-09-01\n                // to: 20120901\n                var len = aValue.length;\n                if (len == 10) {\n                    return aValue.substr(0, 4) + aValue.substr(5, 2) + aValue.substr(8, 2);\n                } else if (len >= 19) {\n                    return icalValues[\"date-time\"].toICAL(aValue);\n                } else {\n                    //TODO: serialize warning?\n                    return aValue;\n                }\n            }\n        },\n        \"date-time\": {\n            fromICAL: function(aValue) {\n                // from: 20120901T130000\n                // to: 2012-09-01T13:00:00\n                if (!design.strict && aValue.length == 8) {\n                    // This is probably a date, e.g. 20120901\n                    return icalValues.date.fromICAL(aValue);\n                } else {\n                    var result = aValue.substr(0, 4) + \"-\" + aValue.substr(4, 2) + \"-\" + aValue.substr(6, 2) + \"T\" + aValue.substr(9, 2) + \":\" + aValue.substr(11, 2) + \":\" + aValue.substr(13, 2);\n                    if (aValue[15] && aValue[15] === \"Z\") {\n                        result += \"Z\";\n                    }\n                    return result;\n                }\n            },\n            toICAL: function(aValue) {\n                // from: 2012-09-01T13:00:00\n                // to: 20120901T130000\n                var len = aValue.length;\n                if (len == 10 && !design.strict) {\n                    return icalValues.date.toICAL(aValue);\n                } else if (len >= 19) {\n                    var result = aValue.substr(0, 4) + aValue.substr(5, 2) + // grab the (DDTHH) segment\n                    aValue.substr(8, 5) + // MM\n                    aValue.substr(14, 2) + // SS\n                    aValue.substr(17, 2);\n                    if (aValue[19] && aValue[19] === \"Z\") {\n                        result += \"Z\";\n                    }\n                    return result;\n                } else {\n                    // TODO: error\n                    return aValue;\n                }\n            },\n            decorate: function(aValue, aProp) {\n                if (design.strict) {\n                    return ICAL.Time.fromDateTimeString(aValue, aProp);\n                } else {\n                    return ICAL.Time.fromString(aValue, aProp);\n                }\n            },\n            undecorate: function(aValue) {\n                return aValue.toString();\n            }\n        },\n        duration: {\n            decorate: function(aValue) {\n                return ICAL.Duration.fromString(aValue);\n            },\n            undecorate: function(aValue) {\n                return aValue.toString();\n            }\n        },\n        period: {\n            fromICAL: function(string) {\n                var parts = string.split(\"/\");\n                parts[0] = icalValues[\"date-time\"].fromICAL(parts[0]);\n                if (!ICAL.Duration.isValueString(parts[1])) {\n                    parts[1] = icalValues[\"date-time\"].fromICAL(parts[1]);\n                }\n                return parts;\n            },\n            toICAL: function(parts) {\n                if (!design.strict && parts[0].length == 10) {\n                    parts[0] = icalValues.date.toICAL(parts[0]);\n                } else {\n                    parts[0] = icalValues[\"date-time\"].toICAL(parts[0]);\n                }\n                if (!ICAL.Duration.isValueString(parts[1])) {\n                    if (!design.strict && parts[1].length == 10) {\n                        parts[1] = icalValues.date.toICAL(parts[1]);\n                    } else {\n                        parts[1] = icalValues[\"date-time\"].toICAL(parts[1]);\n                    }\n                }\n                return parts.join(\"/\");\n            },\n            decorate: function(aValue, aProp) {\n                return ICAL.Period.fromJSON(aValue, aProp, !design.strict);\n            },\n            undecorate: function(aValue) {\n                return aValue.toJSON();\n            }\n        },\n        recur: {\n            fromICAL: function(string) {\n                return ICAL.Recur._stringToData(string, true);\n            },\n            toICAL: function(data) {\n                var str = \"\";\n                for(var k in data){\n                    /* istanbul ignore if */ if (!Object.prototype.hasOwnProperty.call(data, k)) {\n                        continue;\n                    }\n                    var val = data[k];\n                    if (k == \"until\") {\n                        if (val.length > 10) {\n                            val = icalValues[\"date-time\"].toICAL(val);\n                        } else {\n                            val = icalValues.date.toICAL(val);\n                        }\n                    } else if (k == \"wkst\") {\n                        if (typeof val === \"number\") {\n                            val = ICAL.Recur.numericDayToIcalDay(val);\n                        }\n                    } else if (Array.isArray(val)) {\n                        val = val.join(\",\");\n                    }\n                    str += k.toUpperCase() + \"=\" + val + \";\";\n                }\n                return str.substr(0, str.length - 1);\n            },\n            decorate: function decorate(aValue) {\n                return ICAL.Recur.fromData(aValue);\n            },\n            undecorate: function(aRecur) {\n                return aRecur.toJSON();\n            }\n        },\n        time: {\n            fromICAL: function(aValue) {\n                // from: MMHHSS(Z)?\n                // to: HH:MM:SS(Z)?\n                if (aValue.length < 6) {\n                    // TODO: parser exception?\n                    return aValue;\n                }\n                // HH::MM::SSZ?\n                var result = aValue.substr(0, 2) + \":\" + aValue.substr(2, 2) + \":\" + aValue.substr(4, 2);\n                if (aValue[6] === \"Z\") {\n                    result += \"Z\";\n                }\n                return result;\n            },\n            toICAL: function(aValue) {\n                // from: HH:MM:SS(Z)?\n                // to: MMHHSS(Z)?\n                if (aValue.length < 8) {\n                    //TODO: error\n                    return aValue;\n                }\n                var result = aValue.substr(0, 2) + aValue.substr(3, 2) + aValue.substr(6, 2);\n                if (aValue[8] === \"Z\") {\n                    result += \"Z\";\n                }\n                return result;\n            }\n        }\n    });\n    var icalProperties = ICAL.helpers.extend(commonProperties, {\n        \"action\": DEFAULT_TYPE_TEXT,\n        \"attach\": {\n            defaultType: \"uri\"\n        },\n        \"attendee\": {\n            defaultType: \"cal-address\"\n        },\n        \"calscale\": DEFAULT_TYPE_TEXT,\n        \"class\": DEFAULT_TYPE_TEXT,\n        \"comment\": DEFAULT_TYPE_TEXT,\n        \"completed\": DEFAULT_TYPE_DATETIME,\n        \"contact\": DEFAULT_TYPE_TEXT,\n        \"created\": DEFAULT_TYPE_DATETIME,\n        \"description\": DEFAULT_TYPE_TEXT,\n        \"dtend\": DEFAULT_TYPE_DATETIME_DATE,\n        \"dtstamp\": DEFAULT_TYPE_DATETIME,\n        \"dtstart\": DEFAULT_TYPE_DATETIME_DATE,\n        \"due\": DEFAULT_TYPE_DATETIME_DATE,\n        \"duration\": {\n            defaultType: \"duration\"\n        },\n        \"exdate\": {\n            defaultType: \"date-time\",\n            allowedTypes: [\n                \"date-time\",\n                \"date\"\n            ],\n            multiValue: \",\"\n        },\n        \"exrule\": DEFAULT_TYPE_RECUR,\n        \"freebusy\": {\n            defaultType: \"period\",\n            multiValue: \",\"\n        },\n        \"geo\": {\n            defaultType: \"float\",\n            structuredValue: \";\"\n        },\n        \"last-modified\": DEFAULT_TYPE_DATETIME,\n        \"location\": DEFAULT_TYPE_TEXT,\n        \"method\": DEFAULT_TYPE_TEXT,\n        \"organizer\": {\n            defaultType: \"cal-address\"\n        },\n        \"percent-complete\": DEFAULT_TYPE_INTEGER,\n        \"priority\": DEFAULT_TYPE_INTEGER,\n        \"prodid\": DEFAULT_TYPE_TEXT,\n        \"related-to\": DEFAULT_TYPE_TEXT,\n        \"repeat\": DEFAULT_TYPE_INTEGER,\n        \"rdate\": {\n            defaultType: \"date-time\",\n            allowedTypes: [\n                \"date-time\",\n                \"date\",\n                \"period\"\n            ],\n            multiValue: \",\",\n            detectType: function(string) {\n                if (string.indexOf(\"/\") !== -1) {\n                    return \"period\";\n                }\n                return string.indexOf(\"T\") === -1 ? \"date\" : \"date-time\";\n            }\n        },\n        \"recurrence-id\": DEFAULT_TYPE_DATETIME_DATE,\n        \"resources\": DEFAULT_TYPE_TEXT_MULTI,\n        \"request-status\": DEFAULT_TYPE_TEXT_STRUCTURED,\n        \"rrule\": DEFAULT_TYPE_RECUR,\n        \"sequence\": DEFAULT_TYPE_INTEGER,\n        \"status\": DEFAULT_TYPE_TEXT,\n        \"summary\": DEFAULT_TYPE_TEXT,\n        \"transp\": DEFAULT_TYPE_TEXT,\n        \"trigger\": {\n            defaultType: \"duration\",\n            allowedTypes: [\n                \"duration\",\n                \"date-time\"\n            ]\n        },\n        \"tzoffsetfrom\": DEFAULT_TYPE_UTCOFFSET,\n        \"tzoffsetto\": DEFAULT_TYPE_UTCOFFSET,\n        \"tzurl\": DEFAULT_TYPE_URI,\n        \"tzid\": DEFAULT_TYPE_TEXT,\n        \"tzname\": DEFAULT_TYPE_TEXT\n    });\n    // When adding a value here, be sure to add it to the parameter types!\n    var vcardValues = ICAL.helpers.extend(commonValues, {\n        text: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n        uri: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n        date: {\n            decorate: function(aValue) {\n                return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date\");\n            },\n            undecorate: function(aValue) {\n                return aValue.toString();\n            },\n            fromICAL: function(aValue) {\n                if (aValue.length == 8) {\n                    return icalValues.date.fromICAL(aValue);\n                } else if (aValue[0] == \"-\" && aValue.length == 6) {\n                    return aValue.substr(0, 4) + \"-\" + aValue.substr(4);\n                } else {\n                    return aValue;\n                }\n            },\n            toICAL: function(aValue) {\n                if (aValue.length == 10) {\n                    return icalValues.date.toICAL(aValue);\n                } else if (aValue[0] == \"-\" && aValue.length == 7) {\n                    return aValue.substr(0, 4) + aValue.substr(5);\n                } else {\n                    return aValue;\n                }\n            }\n        },\n        time: {\n            decorate: function(aValue) {\n                return ICAL.VCardTime.fromDateAndOrTimeString(\"T\" + aValue, \"time\");\n            },\n            undecorate: function(aValue) {\n                return aValue.toString();\n            },\n            fromICAL: function(aValue) {\n                var splitzone = vcardValues.time._splitZone(aValue, true);\n                var zone = splitzone[0], value1 = splitzone[1];\n                //console.log(\"SPLIT: \",splitzone);\n                if (value1.length == 6) {\n                    value1 = value1.substr(0, 2) + \":\" + value1.substr(2, 2) + \":\" + value1.substr(4, 2);\n                } else if (value1.length == 4 && value1[0] != \"-\") {\n                    value1 = value1.substr(0, 2) + \":\" + value1.substr(2, 2);\n                } else if (value1.length == 5) {\n                    value1 = value1.substr(0, 3) + \":\" + value1.substr(3, 2);\n                }\n                if (zone.length == 5 && (zone[0] == \"-\" || zone[0] == \"+\")) {\n                    zone = zone.substr(0, 3) + \":\" + zone.substr(3);\n                }\n                return value1 + zone;\n            },\n            toICAL: function(aValue) {\n                var splitzone = vcardValues.time._splitZone(aValue);\n                var zone = splitzone[0], value1 = splitzone[1];\n                if (value1.length == 8) {\n                    value1 = value1.substr(0, 2) + value1.substr(3, 2) + value1.substr(6, 2);\n                } else if (value1.length == 5 && value1[0] != \"-\") {\n                    value1 = value1.substr(0, 2) + value1.substr(3, 2);\n                } else if (value1.length == 6) {\n                    value1 = value1.substr(0, 3) + value1.substr(4, 2);\n                }\n                if (zone.length == 6 && (zone[0] == \"-\" || zone[0] == \"+\")) {\n                    zone = zone.substr(0, 3) + zone.substr(4);\n                }\n                return value1 + zone;\n            },\n            _splitZone: function(aValue, isFromIcal) {\n                var lastChar = aValue.length - 1;\n                var signChar = aValue.length - (isFromIcal ? 5 : 6);\n                var sign = aValue[signChar];\n                var zone, value1;\n                if (aValue[lastChar] == \"Z\") {\n                    zone = aValue[lastChar];\n                    value1 = aValue.substr(0, lastChar);\n                } else if (aValue.length > 6 && (sign == \"-\" || sign == \"+\")) {\n                    zone = aValue.substr(signChar);\n                    value1 = aValue.substr(0, signChar);\n                } else {\n                    zone = \"\";\n                    value1 = aValue;\n                }\n                return [\n                    zone,\n                    value1\n                ];\n            }\n        },\n        \"date-time\": {\n            decorate: function(aValue) {\n                return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date-time\");\n            },\n            undecorate: function(aValue) {\n                return aValue.toString();\n            },\n            fromICAL: function(aValue) {\n                return vcardValues[\"date-and-or-time\"].fromICAL(aValue);\n            },\n            toICAL: function(aValue) {\n                return vcardValues[\"date-and-or-time\"].toICAL(aValue);\n            }\n        },\n        \"date-and-or-time\": {\n            decorate: function(aValue) {\n                return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date-and-or-time\");\n            },\n            undecorate: function(aValue) {\n                return aValue.toString();\n            },\n            fromICAL: function(aValue) {\n                var parts = aValue.split(\"T\");\n                return (parts[0] ? vcardValues.date.fromICAL(parts[0]) : \"\") + (parts[1] ? \"T\" + vcardValues.time.fromICAL(parts[1]) : \"\");\n            },\n            toICAL: function(aValue) {\n                var parts = aValue.split(\"T\");\n                return vcardValues.date.toICAL(parts[0]) + (parts[1] ? \"T\" + vcardValues.time.toICAL(parts[1]) : \"\");\n            }\n        },\n        timestamp: icalValues[\"date-time\"],\n        \"language-tag\": {\n            matches: /^[a-zA-Z0-9-]+$/ // Could go with a more strict regex here\n        }\n    });\n    var vcardParams = {\n        \"type\": {\n            valueType: \"text\",\n            multiValue: \",\"\n        },\n        \"value\": {\n            // since the value here is a 'type' lowercase is used.\n            values: [\n                \"text\",\n                \"uri\",\n                \"date\",\n                \"time\",\n                \"date-time\",\n                \"date-and-or-time\",\n                \"timestamp\",\n                \"boolean\",\n                \"integer\",\n                \"float\",\n                \"utc-offset\",\n                \"language-tag\"\n            ],\n            allowXName: true,\n            allowIanaToken: true\n        }\n    };\n    var vcardProperties = ICAL.helpers.extend(commonProperties, {\n        \"adr\": {\n            defaultType: \"text\",\n            structuredValue: \";\",\n            multiValue: \",\"\n        },\n        \"anniversary\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n        \"bday\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n        \"caladruri\": DEFAULT_TYPE_URI,\n        \"caluri\": DEFAULT_TYPE_URI,\n        \"clientpidmap\": DEFAULT_TYPE_TEXT_STRUCTURED,\n        \"email\": DEFAULT_TYPE_TEXT,\n        \"fburl\": DEFAULT_TYPE_URI,\n        \"fn\": DEFAULT_TYPE_TEXT,\n        \"gender\": DEFAULT_TYPE_TEXT_STRUCTURED,\n        \"geo\": DEFAULT_TYPE_URI,\n        \"impp\": DEFAULT_TYPE_URI,\n        \"key\": DEFAULT_TYPE_URI,\n        \"kind\": DEFAULT_TYPE_TEXT,\n        \"lang\": {\n            defaultType: \"language-tag\"\n        },\n        \"logo\": DEFAULT_TYPE_URI,\n        \"member\": DEFAULT_TYPE_URI,\n        \"n\": {\n            defaultType: \"text\",\n            structuredValue: \";\",\n            multiValue: \",\"\n        },\n        \"nickname\": DEFAULT_TYPE_TEXT_MULTI,\n        \"note\": DEFAULT_TYPE_TEXT,\n        \"org\": {\n            defaultType: \"text\",\n            structuredValue: \";\"\n        },\n        \"photo\": DEFAULT_TYPE_URI,\n        \"related\": DEFAULT_TYPE_URI,\n        \"rev\": {\n            defaultType: \"timestamp\"\n        },\n        \"role\": DEFAULT_TYPE_TEXT,\n        \"sound\": DEFAULT_TYPE_URI,\n        \"source\": DEFAULT_TYPE_URI,\n        \"tel\": {\n            defaultType: \"uri\",\n            allowedTypes: [\n                \"uri\",\n                \"text\"\n            ]\n        },\n        \"title\": DEFAULT_TYPE_TEXT,\n        \"tz\": {\n            defaultType: \"text\",\n            allowedTypes: [\n                \"text\",\n                \"utc-offset\",\n                \"uri\"\n            ]\n        },\n        \"xml\": DEFAULT_TYPE_TEXT\n    });\n    var vcard3Values = ICAL.helpers.extend(commonValues, {\n        binary: icalValues.binary,\n        date: vcardValues.date,\n        \"date-time\": vcardValues[\"date-time\"],\n        \"phone-number\": {\n        },\n        uri: icalValues.uri,\n        text: icalValues.text,\n        time: icalValues.time,\n        vcard: icalValues.text,\n        \"utc-offset\": {\n            toICAL: function(aValue) {\n                return aValue.substr(0, 7);\n            },\n            fromICAL: function(aValue) {\n                return aValue.substr(0, 7);\n            },\n            decorate: function(aValue) {\n                return ICAL.UtcOffset.fromString(aValue);\n            },\n            undecorate: function(aValue) {\n                return aValue.toString();\n            }\n        }\n    });\n    var vcard3Params = {\n        \"type\": {\n            valueType: \"text\",\n            multiValue: \",\"\n        },\n        \"value\": {\n            // since the value here is a 'type' lowercase is used.\n            values: [\n                \"text\",\n                \"uri\",\n                \"date\",\n                \"date-time\",\n                \"phone-number\",\n                \"time\",\n                \"boolean\",\n                \"integer\",\n                \"float\",\n                \"utc-offset\",\n                \"vcard\",\n                \"binary\"\n            ],\n            allowXName: true,\n            allowIanaToken: true\n        }\n    };\n    var vcard3Properties = ICAL.helpers.extend(commonProperties, {\n        fn: DEFAULT_TYPE_TEXT,\n        n: {\n            defaultType: \"text\",\n            structuredValue: \";\",\n            multiValue: \",\"\n        },\n        nickname: DEFAULT_TYPE_TEXT_MULTI,\n        photo: {\n            defaultType: \"binary\",\n            allowedTypes: [\n                \"binary\",\n                \"uri\"\n            ]\n        },\n        bday: {\n            defaultType: \"date-time\",\n            allowedTypes: [\n                \"date-time\",\n                \"date\"\n            ],\n            detectType: function(string) {\n                return string.indexOf(\"T\") === -1 ? \"date\" : \"date-time\";\n            }\n        },\n        adr: {\n            defaultType: \"text\",\n            structuredValue: \";\",\n            multiValue: \",\"\n        },\n        label: DEFAULT_TYPE_TEXT,\n        tel: {\n            defaultType: \"phone-number\"\n        },\n        email: DEFAULT_TYPE_TEXT,\n        mailer: DEFAULT_TYPE_TEXT,\n        tz: {\n            defaultType: \"utc-offset\",\n            allowedTypes: [\n                \"utc-offset\",\n                \"text\"\n            ]\n        },\n        geo: {\n            defaultType: \"float\",\n            structuredValue: \";\"\n        },\n        title: DEFAULT_TYPE_TEXT,\n        role: DEFAULT_TYPE_TEXT,\n        logo: {\n            defaultType: \"binary\",\n            allowedTypes: [\n                \"binary\",\n                \"uri\"\n            ]\n        },\n        agent: {\n            defaultType: \"vcard\",\n            allowedTypes: [\n                \"vcard\",\n                \"text\",\n                \"uri\"\n            ]\n        },\n        org: DEFAULT_TYPE_TEXT_STRUCTURED,\n        note: DEFAULT_TYPE_TEXT_MULTI,\n        prodid: DEFAULT_TYPE_TEXT,\n        rev: {\n            defaultType: \"date-time\",\n            allowedTypes: [\n                \"date-time\",\n                \"date\"\n            ],\n            detectType: function(string) {\n                return string.indexOf(\"T\") === -1 ? \"date\" : \"date-time\";\n            }\n        },\n        \"sort-string\": DEFAULT_TYPE_TEXT,\n        sound: {\n            defaultType: \"binary\",\n            allowedTypes: [\n                \"binary\",\n                \"uri\"\n            ]\n        },\n        class: DEFAULT_TYPE_TEXT,\n        key: {\n            defaultType: \"binary\",\n            allowedTypes: [\n                \"binary\",\n                \"text\"\n            ]\n        }\n    });\n    /**\n   * iCalendar design set\n   * @type {ICAL.design.designSet}\n   */ var icalSet = {\n        value: icalValues,\n        param: icalParams,\n        property: icalProperties\n    };\n    /**\n   * vCard 4.0 design set\n   * @type {ICAL.design.designSet}\n   */ var vcardSet = {\n        value: vcardValues,\n        param: vcardParams,\n        property: vcardProperties\n    };\n    /**\n   * vCard 3.0 design set\n   * @type {ICAL.design.designSet}\n   */ var vcard3Set = {\n        value: vcard3Values,\n        param: vcard3Params,\n        property: vcard3Properties\n    };\n    /**\n   * The design data, used by the parser to determine types for properties and\n   * other metadata needed to produce correct jCard/jCal data.\n   *\n   * @alias ICAL.design\n   * @namespace\n   */ var design = {\n        /**\n     * A designSet describes value, parameter and property data. It is used by\n     * ther parser and stringifier in components and properties to determine they\n     * should be represented.\n     *\n     * @typedef {Object} designSet\n     * @memberOf ICAL.design\n     * @property {Object} value       Definitions for value types, keys are type names\n     * @property {Object} param       Definitions for params, keys are param names\n     * @property {Object} property    Defintions for properties, keys are property names\n     */ /**\n     * Can be set to false to make the parser more lenient.\n     */ strict: true,\n        /**\n     * The default set for new properties and components if none is specified.\n     * @type {ICAL.design.designSet}\n     */ defaultSet: icalSet,\n        /**\n     * The default type for unknown properties\n     * @type {String}\n     */ defaultType: \"unknown\",\n        /**\n     * Holds the design set for known top-level components\n     *\n     * @type {Object}\n     * @property {ICAL.design.designSet} vcard       vCard VCARD\n     * @property {ICAL.design.designSet} vevent      iCalendar VEVENT\n     * @property {ICAL.design.designSet} vtodo       iCalendar VTODO\n     * @property {ICAL.design.designSet} vjournal    iCalendar VJOURNAL\n     * @property {ICAL.design.designSet} valarm      iCalendar VALARM\n     * @property {ICAL.design.designSet} vtimezone   iCalendar VTIMEZONE\n     * @property {ICAL.design.designSet} daylight    iCalendar DAYLIGHT\n     * @property {ICAL.design.designSet} standard    iCalendar STANDARD\n     *\n     * @example\n     * var propertyName = 'fn';\n     * var componentDesign = ICAL.design.components.vcard;\n     * var propertyDetails = componentDesign.property[propertyName];\n     * if (propertyDetails.defaultType == 'text') {\n     *   // Yep, sure is...\n     * }\n     */ components: {\n            vcard: vcardSet,\n            vcard3: vcard3Set,\n            vevent: icalSet,\n            vtodo: icalSet,\n            vjournal: icalSet,\n            valarm: icalSet,\n            vtimezone: icalSet,\n            daylight: icalSet,\n            standard: icalSet\n        },\n        /**\n     * The design set for iCalendar (rfc5545/rfc7265) components.\n     * @type {ICAL.design.designSet}\n     */ icalendar: icalSet,\n        /**\n     * The design set for vCard (rfc6350/rfc7095) components.\n     * @type {ICAL.design.designSet}\n     */ vcard: vcardSet,\n        /**\n     * The design set for vCard (rfc2425/rfc2426/rfc7095) components.\n     * @type {ICAL.design.designSet}\n     */ vcard3: vcard3Set,\n        /**\n     * Gets the design set for the given component name.\n     *\n     * @param {String} componentName        The name of the component\n     * @return {ICAL.design.designSet}      The design set for the component\n     */ getDesignSet: function(componentName) {\n            var isInDesign = componentName && componentName in design.components;\n            return isInDesign ? design.components[componentName] : design.defaultSet;\n        }\n    };\n    return design;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */ /**\n * Contains various functions to convert jCal and jCard data back into\n * iCalendar and vCard.\n * @namespace\n */ ICAL.stringify = function() {\n    \"use strict\";\n    var LINE_ENDING = \"\\r\\n\";\n    var DEFAULT_VALUE_TYPE = \"unknown\";\n    var design = ICAL.design;\n    var helpers = ICAL.helpers;\n    /**\n   * Convert a full jCal/jCard array into a iCalendar/vCard string.\n   *\n   * @function ICAL.stringify\n   * @variation function\n   * @param {Array} jCal    The jCal/jCard document\n   * @return {String}       The stringified iCalendar/vCard document\n   */ function stringify(jCal) {\n        if (typeof jCal[0] == \"string\") {\n            // This is a single component\n            jCal = [\n                jCal\n            ];\n        }\n        var i = 0;\n        var len = jCal.length;\n        var result = \"\";\n        for(; i < len; i++){\n            result += stringify.component(jCal[i]) + LINE_ENDING;\n        }\n        return result;\n    }\n    /**\n   * Converts an jCal component array into a ICAL string.\n   * Recursive will resolve sub-components.\n   *\n   * Exact component/property order is not saved all\n   * properties will come before subcomponents.\n   *\n   * @function ICAL.stringify.component\n   * @param {Array} component\n   *        jCal/jCard fragment of a component\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this component\n   * @return {String}       The iCalendar/vCard string\n   */ stringify.component = function(component, designSet) {\n        var name = component[0].toUpperCase();\n        var result = \"BEGIN:\" + name + LINE_ENDING;\n        var props = component[1];\n        var propIdx = 0;\n        var propLen = props.length;\n        var designSetName = component[0];\n        // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n        // component with as value 4.0, note that 3.0 does not have this requirement.\n        if (designSetName === \"vcard\" && component[1].length > 0 && !(component[1][0][0] === \"version\" && component[1][0][3] === \"4.0\")) {\n            designSetName = \"vcard3\";\n        }\n        designSet = designSet || design.getDesignSet(designSetName);\n        for(; propIdx < propLen; propIdx++){\n            result += stringify.property(props[propIdx], designSet) + LINE_ENDING;\n        }\n        // Ignore subcomponents if none exist, e.g. in vCard.\n        var comps = component[2] || [];\n        var compIdx = 0;\n        var compLen = comps.length;\n        for(; compIdx < compLen; compIdx++){\n            result += stringify.component(comps[compIdx], designSet) + LINE_ENDING;\n        }\n        result += \"END:\" + name;\n        return result;\n    };\n    /**\n   * Converts a single jCal/jCard property to a iCalendar/vCard string.\n   *\n   * @function ICAL.stringify.property\n   * @param {Array} property\n   *        jCal/jCard property array\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this property\n   * @param {Boolean} noFold\n   *        If true, the line is not folded\n   * @return {String}       The iCalendar/vCard string\n   */ stringify.property = function(property, designSet, noFold) {\n        var name = property[0].toUpperCase();\n        var jsName = property[0];\n        var params = property[1];\n        var line = name;\n        var paramName;\n        for(paramName in params){\n            var value1 = params[paramName];\n            /* istanbul ignore else */ if (params.hasOwnProperty(paramName)) {\n                var multiValue = paramName in designSet.param && designSet.param[paramName].multiValue;\n                if (multiValue && Array.isArray(value1)) {\n                    if (designSet.param[paramName].multiValueSeparateDQuote) {\n                        multiValue = '\"' + multiValue + '\"';\n                    }\n                    value1 = value1.map(stringify._rfc6868Unescape);\n                    value1 = stringify.multiValue(value1, multiValue, \"unknown\", null, designSet);\n                } else {\n                    value1 = stringify._rfc6868Unescape(value1);\n                }\n                line += \";\" + paramName.toUpperCase();\n                line += \"=\" + stringify.propertyValue(value1);\n            }\n        }\n        if (property.length === 3) {\n            // If there are no values, we must assume a blank value\n            return line + \":\";\n        }\n        var valueType = property[2];\n        if (!designSet) {\n            designSet = design.defaultSet;\n        }\n        var propDetails;\n        var multiValue = false;\n        var structuredValue = false;\n        var isDefault = false;\n        if (jsName in designSet.property) {\n            propDetails = designSet.property[jsName];\n            if (\"multiValue\" in propDetails) {\n                multiValue = propDetails.multiValue;\n            }\n            if (\"structuredValue\" in propDetails && Array.isArray(property[3])) {\n                structuredValue = propDetails.structuredValue;\n            }\n            if (\"defaultType\" in propDetails) {\n                if (valueType === propDetails.defaultType) {\n                    isDefault = true;\n                }\n            } else {\n                if (valueType === DEFAULT_VALUE_TYPE) {\n                    isDefault = true;\n                }\n            }\n        } else {\n            if (valueType === DEFAULT_VALUE_TYPE) {\n                isDefault = true;\n            }\n        }\n        // push the VALUE property if type is not the default\n        // for the current property.\n        if (!isDefault) {\n            // value will never contain ;/:/, so we don't escape it here.\n            line += \";VALUE=\" + valueType.toUpperCase();\n        }\n        line += \":\";\n        if (multiValue && structuredValue) {\n            line += stringify.multiValue(property[3], structuredValue, valueType, multiValue, designSet, structuredValue);\n        } else if (multiValue) {\n            line += stringify.multiValue(property.slice(3), multiValue, valueType, null, designSet, false);\n        } else if (structuredValue) {\n            line += stringify.multiValue(property[3], structuredValue, valueType, null, designSet, structuredValue);\n        } else {\n            line += stringify.value(property[3], valueType, designSet, false);\n        }\n        return noFold ? line : ICAL.helpers.foldline(line);\n    };\n    /**\n   * Handles escaping of property values that may contain:\n   *\n   *    COLON (:), SEMICOLON (;), or COMMA (,)\n   *\n   * If any of the above are present the result is wrapped\n   * in double quotes.\n   *\n   * @function ICAL.stringify.propertyValue\n   * @param {String} value      Raw property value\n   * @return {String}           Given or escaped value when needed\n   */ stringify.propertyValue = function(value1) {\n        if (helpers.unescapedIndexOf(value1, \",\") === -1 && helpers.unescapedIndexOf(value1, \":\") === -1 && helpers.unescapedIndexOf(value1, \";\") === -1) {\n            return value1;\n        }\n        return '\"' + value1 + '\"';\n    };\n    /**\n   * Converts an array of ical values into a single\n   * string based on a type and a delimiter value (like \",\").\n   *\n   * @function ICAL.stringify.multiValue\n   * @param {Array} values      List of values to convert\n   * @param {String} delim      Used to join the values (\",\", \";\", \":\")\n   * @param {String} type       Lowecase ical value type\n   *        (like boolean, date-time, etc..)\n   * @param {?String} innerMulti If set, each value will again be processed\n   *        Used for structured values\n   * @param {ICAL.design.designSet} designSet\n   *        The design data to use for this property\n   *\n   * @return {String}           iCalendar/vCard string for value\n   */ stringify.multiValue = function(values, delim, type, innerMulti, designSet, structuredValue) {\n        var result = \"\";\n        var len = values.length;\n        var i = 0;\n        for(; i < len; i++){\n            if (innerMulti && Array.isArray(values[i])) {\n                result += stringify.multiValue(values[i], innerMulti, type, null, designSet, structuredValue);\n            } else {\n                result += stringify.value(values[i], type, designSet, structuredValue);\n            }\n            if (i !== len - 1) {\n                result += delim;\n            }\n        }\n        return result;\n    };\n    /**\n   * Processes a single ical value runs the associated \"toICAL\" method from the\n   * design value type if available to convert the value.\n   *\n   * @function ICAL.stringify.value\n   * @param {String|Number} value       A formatted value\n   * @param {String} type               Lowercase iCalendar/vCard value type\n   *  (like boolean, date-time, etc..)\n   * @return {String}                   iCalendar/vCard value for single value\n   */ stringify.value = function(value1, type, designSet, structuredValue) {\n        if (type in designSet.value && \"toICAL\" in designSet.value[type]) {\n            return designSet.value[type].toICAL(value1, structuredValue);\n        }\n        return value1;\n    };\n    /**\n   * Internal helper for rfc6868. Exposing this on ICAL.stringify so that\n   * hackers can disable the rfc6868 parsing if the really need to.\n   *\n   * @param {String} val        The value to unescape\n   * @return {String}           The escaped value\n   */ stringify._rfc6868Unescape = function(val) {\n        return val.replace(/[\\n^\"]/g, function(x) {\n            return RFC6868_REPLACE_MAP[x];\n        });\n    };\n    var RFC6868_REPLACE_MAP = {\n        '\"': \"^'\",\n        \"\\n\": \"^n\",\n        \"^\": \"^^\"\n    };\n    return stringify;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */ /**\n * Contains various functions to parse iCalendar and vCard data.\n * @namespace\n */ ICAL.parse = function() {\n    \"use strict\";\n    var CHAR = /[^ \\t]/;\n    var MULTIVALUE_DELIMITER = \",\";\n    var VALUE_DELIMITER = \":\";\n    var PARAM_DELIMITER = \";\";\n    var PARAM_NAME_DELIMITER = \"=\";\n    var DEFAULT_VALUE_TYPE = \"unknown\";\n    var DEFAULT_PARAM_TYPE = \"text\";\n    var design = ICAL.design;\n    var helpers = ICAL.helpers;\n    /**\n   * An error that occurred during parsing.\n   *\n   * @param {String} message        The error message\n   * @memberof ICAL.parse\n   * @extends {Error}\n   * @class\n   */ function ParserError(message) {\n        this.message = message;\n        this.name = \"ParserError\";\n        try {\n            throw new Error();\n        } catch (e) {\n            if (e.stack) {\n                var split = e.stack.split(\"\\n\");\n                split.shift();\n                this.stack = split.join(\"\\n\");\n            }\n        }\n    }\n    ParserError.prototype = Error.prototype;\n    /**\n   * Parses iCalendar or vCard data into a raw jCal object. Consult\n   * documentation on the {@tutorial layers|layers of parsing} for more\n   * details.\n   *\n   * @function ICAL.parse\n   * @variation function\n   * @todo Fix the API to be more clear on the return type\n   * @param {String} input      The string data to parse\n   * @return {Object|Object[]}  A single jCal object, or an array thereof\n   */ function parser(input) {\n        var state = {};\n        var root = state.component = [];\n        state.stack = [\n            root\n        ];\n        parser._eachLine(input, function(err, line) {\n            parser._handleContentLine(line, state);\n        });\n        // when there are still items on the stack\n        // throw a fatal error, a component was not closed\n        // correctly in that case.\n        if (state.stack.length > 1) {\n            throw new ParserError(\"invalid ical body. component began but did not end\");\n        }\n        state = null;\n        return root.length == 1 ? root[0] : root;\n    }\n    /**\n   * Parse an iCalendar property value into the jCal for a single property\n   *\n   * @function ICAL.parse.property\n   * @param {String} str\n   *   The iCalendar property string to parse\n   * @param {ICAL.design.designSet=} designSet\n   *   The design data to use for this property\n   * @return {Object}\n   *   The jCal Object containing the property\n   */ parser.property = function(str, designSet) {\n        var state = {\n            component: [\n                [],\n                []\n            ],\n            designSet: designSet || design.defaultSet\n        };\n        parser._handleContentLine(str, state);\n        return state.component[1][0];\n    };\n    /**\n   * Convenience method to parse a component. You can use ICAL.parse() directly\n   * instead.\n   *\n   * @function ICAL.parse.component\n   * @see ICAL.parse(function)\n   * @param {String} str    The iCalendar component string to parse\n   * @return {Object}       The jCal Object containing the component\n   */ parser.component = function(str) {\n        return parser(str);\n    };\n    // classes & constants\n    parser.ParserError = ParserError;\n    /**\n   * The state for parsing content lines from an iCalendar/vCard string.\n   *\n   * @private\n   * @memberof ICAL.parse\n   * @typedef {Object} parserState\n   * @property {ICAL.design.designSet} designSet    The design set to use for parsing\n   * @property {ICAL.Component[]} stack             The stack of components being processed\n   * @property {ICAL.Component} component           The currently active component\n   */ /**\n   * Handles a single line of iCalendar/vCard, updating the state.\n   *\n   * @private\n   * @function ICAL.parse._handleContentLine\n   * @param {String} line               The content line to process\n   * @param {ICAL.parse.parserState}    The current state of the line parsing\n   */ parser._handleContentLine = function(line, state) {\n        // break up the parts of the line\n        var valuePos = line.indexOf(VALUE_DELIMITER);\n        var paramPos = line.indexOf(PARAM_DELIMITER);\n        var lastParamIndex;\n        var lastValuePos;\n        // name of property or begin/end\n        var name;\n        var value1;\n        // params is only overridden if paramPos !== -1.\n        // we can't do params = params || {} later on\n        // because it sacrifices ops.\n        var params = {};\n        /**\n     * Different property cases\n     *\n     *\n     * 1. RRULE:FREQ=foo\n     *    // FREQ= is not a param but the value\n     *\n     * 2. ATTENDEE;ROLE=REQ-PARTICIPANT;\n     *    // ROLE= is a param because : has not happened yet\n     */ // when the parameter delimiter is after the\n        // value delimiter then it is not a parameter.\n        if (paramPos !== -1 && valuePos !== -1) {\n            // when the parameter delimiter is after the\n            // value delimiter then it is not a parameter.\n            if (paramPos > valuePos) {\n                paramPos = -1;\n            }\n        }\n        var parsedParams;\n        if (paramPos !== -1) {\n            name = line.substring(0, paramPos).toLowerCase();\n            parsedParams = parser._parseParameters(line.substring(paramPos), 0, state.designSet);\n            if (parsedParams[2] == -1) {\n                throw new ParserError(\"Invalid parameters in '\" + line + \"'\");\n            }\n            params = parsedParams[0];\n            lastParamIndex = parsedParams[1].length + parsedParams[2] + paramPos;\n            if ((lastValuePos = line.substring(lastParamIndex).indexOf(VALUE_DELIMITER)) !== -1) {\n                value1 = line.substring(lastParamIndex + lastValuePos + 1);\n            } else {\n                throw new ParserError(\"Missing parameter value in '\" + line + \"'\");\n            }\n        } else if (valuePos !== -1) {\n            // without parmeters (BEGIN:VCAENDAR, CLASS:PUBLIC)\n            name = line.substring(0, valuePos).toLowerCase();\n            value1 = line.substring(valuePos + 1);\n            if (name === \"begin\") {\n                var newComponent = [\n                    value1.toLowerCase(),\n                    [],\n                    []\n                ];\n                if (state.stack.length === 1) {\n                    state.component.push(newComponent);\n                } else {\n                    state.component[2].push(newComponent);\n                }\n                state.stack.push(state.component);\n                state.component = newComponent;\n                if (!state.designSet) {\n                    state.designSet = design.getDesignSet(state.component[0]);\n                }\n                return;\n            } else if (name === \"end\") {\n                state.component = state.stack.pop();\n                return;\n            }\n        // If it is not begin/end, then this is a property with an empty value,\n        // which should be considered valid.\n        } else {\n            /**\n       * Invalid line.\n       * The rational to throw an error is we will\n       * never be certain that the rest of the file\n       * is sane and it is unlikely that we can serialize\n       * the result correctly either.\n       */ throw new ParserError('invalid line (no token \";\" or \":\") \"' + line + '\"');\n        }\n        var valueType;\n        var multiValue = false;\n        var structuredValue = false;\n        var propertyDetails;\n        if (name in state.designSet.property) {\n            propertyDetails = state.designSet.property[name];\n            if (\"multiValue\" in propertyDetails) {\n                multiValue = propertyDetails.multiValue;\n            }\n            if (\"structuredValue\" in propertyDetails) {\n                structuredValue = propertyDetails.structuredValue;\n            }\n            if (value1 && \"detectType\" in propertyDetails) {\n                valueType = propertyDetails.detectType(value1);\n            }\n        }\n        // attempt to determine value\n        if (!valueType) {\n            if (!(\"value\" in params)) {\n                if (propertyDetails) {\n                    valueType = propertyDetails.defaultType;\n                } else {\n                    valueType = DEFAULT_VALUE_TYPE;\n                }\n            } else {\n                // possible to avoid this?\n                valueType = params.value.toLowerCase();\n            }\n        }\n        delete params.value;\n        /**\n     * Note on `var result` juggling:\n     *\n     * I observed that building the array in pieces has adverse\n     * effects on performance, so where possible we inline the creation.\n     * It is a little ugly but resulted in ~2000 additional ops/sec.\n     */ var result;\n        if (multiValue && structuredValue) {\n            value1 = parser._parseMultiValue(value1, structuredValue, valueType, [], multiValue, state.designSet, structuredValue);\n            result = [\n                name,\n                params,\n                valueType,\n                value1\n            ];\n        } else if (multiValue) {\n            result = [\n                name,\n                params,\n                valueType\n            ];\n            parser._parseMultiValue(value1, multiValue, valueType, result, null, state.designSet, false);\n        } else if (structuredValue) {\n            value1 = parser._parseMultiValue(value1, structuredValue, valueType, [], null, state.designSet, structuredValue);\n            result = [\n                name,\n                params,\n                valueType,\n                value1\n            ];\n        } else {\n            value1 = parser._parseValue(value1, valueType, state.designSet, false);\n            result = [\n                name,\n                params,\n                valueType,\n                value1\n            ];\n        }\n        // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n        // component with as value 4.0, note that 3.0 does not have this requirement.\n        if (state.component[0] === \"vcard\" && state.component[1].length === 0 && !(name === \"version\" && value1 === \"4.0\")) {\n            state.designSet = design.getDesignSet(\"vcard3\");\n        }\n        state.component[1].push(result);\n    };\n    /**\n   * Parse a value from the raw value into the jCard/jCal value.\n   *\n   * @private\n   * @function ICAL.parse._parseValue\n   * @param {String} value          Original value\n   * @param {String} type           Type of value\n   * @param {Object} designSet      The design data to use for this value\n   * @return {Object} varies on type\n   */ parser._parseValue = function(value1, type, designSet, structuredValue) {\n        if (type in designSet.value && \"fromICAL\" in designSet.value[type]) {\n            return designSet.value[type].fromICAL(value1, structuredValue);\n        }\n        return value1;\n    };\n    /**\n   * Parse parameters from a string to object.\n   *\n   * @function ICAL.parse._parseParameters\n   * @private\n   * @param {String} line           A single unfolded line\n   * @param {Numeric} start         Position to start looking for properties\n   * @param {Object} designSet      The design data to use for this property\n   * @return {Object} key/value pairs\n   */ parser._parseParameters = function(line, start, designSet) {\n        var lastParam = start;\n        var pos = 0;\n        var delim = PARAM_NAME_DELIMITER;\n        var result = {};\n        var name, lcname;\n        var value1, valuePos = -1;\n        var type, multiValue, mvdelim;\n        // find the next '=' sign\n        // use lastParam and pos to find name\n        // check if \" is used if so get value from \"->\"\n        // then increment pos to find next ;\n        while(pos !== false && (pos = helpers.unescapedIndexOf(line, delim, pos + 1)) !== -1){\n            name = line.substr(lastParam + 1, pos - lastParam - 1);\n            if (name.length == 0) {\n                throw new ParserError(\"Empty parameter name in '\" + line + \"'\");\n            }\n            lcname = name.toLowerCase();\n            mvdelim = false;\n            multiValue = false;\n            if (lcname in designSet.param && designSet.param[lcname].valueType) {\n                type = designSet.param[lcname].valueType;\n            } else {\n                type = DEFAULT_PARAM_TYPE;\n            }\n            if (lcname in designSet.param) {\n                multiValue = designSet.param[lcname].multiValue;\n                if (designSet.param[lcname].multiValueSeparateDQuote) {\n                    mvdelim = parser._rfc6868Escape('\"' + multiValue + '\"');\n                }\n            }\n            var nextChar = line[pos + 1];\n            if (nextChar === '\"') {\n                valuePos = pos + 2;\n                pos = helpers.unescapedIndexOf(line, '\"', valuePos);\n                if (multiValue && pos != -1) {\n                    var extendedValue = true;\n                    while(extendedValue){\n                        if (line[pos + 1] == multiValue && line[pos + 2] == '\"') {\n                            pos = helpers.unescapedIndexOf(line, '\"', pos + 3);\n                        } else {\n                            extendedValue = false;\n                        }\n                    }\n                }\n                if (pos === -1) {\n                    throw new ParserError('invalid line (no matching double quote) \"' + line + '\"');\n                }\n                value1 = line.substr(valuePos, pos - valuePos);\n                lastParam = helpers.unescapedIndexOf(line, PARAM_DELIMITER, pos);\n                if (lastParam === -1) {\n                    pos = false;\n                }\n            } else {\n                valuePos = pos + 1;\n                // move to next \";\"\n                var nextPos = helpers.unescapedIndexOf(line, PARAM_DELIMITER, valuePos);\n                var propValuePos = helpers.unescapedIndexOf(line, VALUE_DELIMITER, valuePos);\n                if (propValuePos !== -1 && nextPos > propValuePos) {\n                    // this is a delimiter in the property value, let's stop here\n                    nextPos = propValuePos;\n                    pos = false;\n                } else if (nextPos === -1) {\n                    // no \";\"\n                    if (propValuePos === -1) {\n                        nextPos = line.length;\n                    } else {\n                        nextPos = propValuePos;\n                    }\n                    pos = false;\n                } else {\n                    lastParam = nextPos;\n                    pos = nextPos;\n                }\n                value1 = line.substr(valuePos, nextPos - valuePos);\n            }\n            value1 = parser._rfc6868Escape(value1);\n            if (multiValue) {\n                var delimiter = mvdelim || multiValue;\n                value1 = parser._parseMultiValue(value1, delimiter, type, [], null, designSet);\n            } else {\n                value1 = parser._parseValue(value1, type, designSet);\n            }\n            if (multiValue && lcname in result) {\n                if (Array.isArray(result[lcname])) {\n                    result[lcname].push(value1);\n                } else {\n                    result[lcname] = [\n                        result[lcname],\n                        value1\n                    ];\n                }\n            } else {\n                result[lcname] = value1;\n            }\n        }\n        return [\n            result,\n            value1,\n            valuePos\n        ];\n    };\n    /**\n   * Internal helper for rfc6868. Exposing this on ICAL.parse so that\n   * hackers can disable the rfc6868 parsing if the really need to.\n   *\n   * @function ICAL.parse._rfc6868Escape\n   * @param {String} val        The value to escape\n   * @return {String}           The escaped value\n   */ parser._rfc6868Escape = function(val) {\n        return val.replace(/\\^['n^]/g, function(x) {\n            return RFC6868_REPLACE_MAP[x];\n        });\n    };\n    var RFC6868_REPLACE_MAP = {\n        \"^'\": '\"',\n        \"^n\": \"\\n\",\n        \"^^\": \"^\"\n    };\n    /**\n   * Parse a multi value string. This function is used either for parsing\n   * actual multi-value property's values, or for handling parameter values. It\n   * can be used for both multi-value properties and structured value properties.\n   *\n   * @private\n   * @function ICAL.parse._parseMultiValue\n   * @param {String} buffer     The buffer containing the full value\n   * @param {String} delim      The multi-value delimiter\n   * @param {String} type       The value type to be parsed\n   * @param {Array.<?>} result        The array to append results to, varies on value type\n   * @param {String} innerMulti The inner delimiter to split each value with\n   * @param {ICAL.design.designSet} designSet   The design data for this value\n   * @return {?|Array.<?>}            Either an array of results, or the first result\n   */ parser._parseMultiValue = function(buffer, delim, type, result, innerMulti, designSet, structuredValue) {\n        var pos = 0;\n        var lastPos = 0;\n        var value1;\n        if (delim.length === 0) {\n            return buffer;\n        }\n        // split each piece\n        while((pos = helpers.unescapedIndexOf(buffer, delim, lastPos)) !== -1){\n            value1 = buffer.substr(lastPos, pos - lastPos);\n            if (innerMulti) {\n                value1 = parser._parseMultiValue(value1, innerMulti, type, [], null, designSet, structuredValue);\n            } else {\n                value1 = parser._parseValue(value1, type, designSet, structuredValue);\n            }\n            result.push(value1);\n            lastPos = pos + delim.length;\n        }\n        // on the last piece take the rest of string\n        value1 = buffer.substr(lastPos);\n        if (innerMulti) {\n            value1 = parser._parseMultiValue(value1, innerMulti, type, [], null, designSet, structuredValue);\n        } else {\n            value1 = parser._parseValue(value1, type, designSet, structuredValue);\n        }\n        result.push(value1);\n        return result.length == 1 ? result[0] : result;\n    };\n    /**\n   * Process a complete buffer of iCalendar/vCard data line by line, correctly\n   * unfolding content. Each line will be processed with the given callback\n   *\n   * @private\n   * @function ICAL.parse._eachLine\n   * @param {String} buffer                         The buffer to process\n   * @param {function(?String, String)} callback    The callback for each line\n   */ parser._eachLine = function(buffer, callback) {\n        var len = buffer.length;\n        var lastPos = buffer.search(CHAR);\n        var pos = lastPos;\n        var line;\n        var firstChar;\n        var newlineOffset;\n        do {\n            pos = buffer.indexOf(\"\\n\", lastPos) + 1;\n            if (pos > 1 && buffer[pos - 2] === \"\\r\") {\n                newlineOffset = 2;\n            } else {\n                newlineOffset = 1;\n            }\n            if (pos === 0) {\n                pos = len;\n                newlineOffset = 0;\n            }\n            firstChar = buffer[lastPos];\n            if (firstChar === \" \" || firstChar === \"\t\") {\n                // add to line\n                line += buffer.substr(lastPos + 1, pos - lastPos - (newlineOffset + 1));\n            } else {\n                if (line) callback(null, line);\n                // push line\n                line = buffer.substr(lastPos, pos - lastPos - newlineOffset);\n            }\n            lastPos = pos;\n        }while (pos !== len);\n        // extra ending line\n        line = line.trim();\n        if (line.length) callback(null, line);\n    };\n    return parser;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */ /**\n * This symbol is further described later on\n * @ignore\n */ ICAL.Component = function() {\n    \"use strict\";\n    var PROPERTY_INDEX = 1;\n    var COMPONENT_INDEX = 2;\n    var NAME_INDEX = 0;\n    /**\n   * @classdesc\n   * Wraps a jCal component, adding convenience methods to add, remove and\n   * update subcomponents and properties.\n   *\n   * @class\n   * @alias ICAL.Component\n   * @param {Array|String} jCal         Raw jCal component data OR name of new\n   *                                      component\n   * @param {ICAL.Component} parent     Parent component to associate\n   */ function Component(jCal, parent) {\n        if (typeof jCal === \"string\") {\n            // jCal spec (name, properties, components)\n            jCal = [\n                jCal,\n                [],\n                []\n            ];\n        }\n        // mostly for legacy reasons.\n        this.jCal = jCal;\n        this.parent = parent || null;\n    }\n    Component.prototype = {\n        /**\n     * Hydrated properties are inserted into the _properties array at the same\n     * position as in the jCal array, so it is possible that the array contains\n     * undefined values for unhydrdated properties. To avoid iterating the\n     * array when checking if all properties have been hydrated, we save the\n     * count here.\n     *\n     * @type {Number}\n     * @private\n     */ _hydratedPropertyCount: 0,\n        /**\n     * The same count as for _hydratedPropertyCount, but for subcomponents\n     *\n     * @type {Number}\n     * @private\n     */ _hydratedComponentCount: 0,\n        /**\n     * The name of this component\n     * @readonly\n     */ get name () {\n            return this.jCal[NAME_INDEX];\n        },\n        /**\n     * The design set for this component, e.g. icalendar vs vcard\n     *\n     * @type {ICAL.design.designSet}\n     * @private\n     */ get _designSet () {\n            var parentDesign = this.parent && this.parent._designSet;\n            return parentDesign || ICAL.design.getDesignSet(this.name);\n        },\n        _hydrateComponent: function(index) {\n            if (!this._components) {\n                this._components = [];\n                this._hydratedComponentCount = 0;\n            }\n            if (this._components[index]) {\n                return this._components[index];\n            }\n            var comp = new Component(this.jCal[COMPONENT_INDEX][index], this);\n            this._hydratedComponentCount++;\n            return this._components[index] = comp;\n        },\n        _hydrateProperty: function(index) {\n            if (!this._properties) {\n                this._properties = [];\n                this._hydratedPropertyCount = 0;\n            }\n            if (this._properties[index]) {\n                return this._properties[index];\n            }\n            var prop = new ICAL.Property(this.jCal[PROPERTY_INDEX][index], this);\n            this._hydratedPropertyCount++;\n            return this._properties[index] = prop;\n        },\n        /**\n     * Finds first sub component, optionally filtered by name.\n     *\n     * @param {String=} name        Optional name to filter by\n     * @return {?ICAL.Component}     The found subcomponent\n     */ getFirstSubcomponent: function(name) {\n            if (name) {\n                var i = 0;\n                var comps = this.jCal[COMPONENT_INDEX];\n                var len = comps.length;\n                for(; i < len; i++){\n                    if (comps[i][NAME_INDEX] === name) {\n                        var result = this._hydrateComponent(i);\n                        return result;\n                    }\n                }\n            } else {\n                if (this.jCal[COMPONENT_INDEX].length) {\n                    return this._hydrateComponent(0);\n                }\n            }\n            // ensure we return a value (strict mode)\n            return null;\n        },\n        /**\n     * Finds all sub components, optionally filtering by name.\n     *\n     * @param {String=} name            Optional name to filter by\n     * @return {ICAL.Component[]}       The found sub components\n     */ getAllSubcomponents: function(name) {\n            var jCalLen = this.jCal[COMPONENT_INDEX].length;\n            var i = 0;\n            if (name) {\n                var comps = this.jCal[COMPONENT_INDEX];\n                var result = [];\n                for(; i < jCalLen; i++){\n                    if (name === comps[i][NAME_INDEX]) {\n                        result.push(this._hydrateComponent(i));\n                    }\n                }\n                return result;\n            } else {\n                if (!this._components || this._hydratedComponentCount !== jCalLen) {\n                    for(; i < jCalLen; i++){\n                        this._hydrateComponent(i);\n                    }\n                }\n                return this._components || [];\n            }\n        },\n        /**\n     * Returns true when a named property exists.\n     *\n     * @param {String} name     The property name\n     * @return {Boolean}        True, when property is found\n     */ hasProperty: function(name) {\n            var props = this.jCal[PROPERTY_INDEX];\n            var len = props.length;\n            var i = 0;\n            for(; i < len; i++){\n                // 0 is property name\n                if (props[i][NAME_INDEX] === name) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n     * Finds the first property, optionally with the given name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {?ICAL.Property}     The found property\n     */ getFirstProperty: function(name) {\n            if (name) {\n                var i = 0;\n                var props = this.jCal[PROPERTY_INDEX];\n                var len = props.length;\n                for(; i < len; i++){\n                    if (props[i][NAME_INDEX] === name) {\n                        var result = this._hydrateProperty(i);\n                        return result;\n                    }\n                }\n            } else {\n                if (this.jCal[PROPERTY_INDEX].length) {\n                    return this._hydrateProperty(0);\n                }\n            }\n            return null;\n        },\n        /**\n     * Returns first property's value, if available.\n     *\n     * @param {String=} name    Lowercase property name\n     * @return {?String}        The found property value.\n     */ getFirstPropertyValue: function(name) {\n            var prop = this.getFirstProperty(name);\n            if (prop) {\n                return prop.getFirstValue();\n            }\n            return null;\n        },\n        /**\n     * Get all properties in the component, optionally filtered by name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {ICAL.Property[]}    List of properties\n     */ getAllProperties: function(name) {\n            var jCalLen = this.jCal[PROPERTY_INDEX].length;\n            var i = 0;\n            if (name) {\n                var props = this.jCal[PROPERTY_INDEX];\n                var result = [];\n                for(; i < jCalLen; i++){\n                    if (name === props[i][NAME_INDEX]) {\n                        result.push(this._hydrateProperty(i));\n                    }\n                }\n                return result;\n            } else {\n                if (!this._properties || this._hydratedPropertyCount !== jCalLen) {\n                    for(; i < jCalLen; i++){\n                        this._hydrateProperty(i);\n                    }\n                }\n                return this._properties || [];\n            }\n        },\n        _removeObjectByIndex: function(jCalIndex, cache, index) {\n            cache = cache || [];\n            // remove cached version\n            if (cache[index]) {\n                var obj = cache[index];\n                if (\"parent\" in obj) {\n                    obj.parent = null;\n                }\n            }\n            cache.splice(index, 1);\n            // remove it from the jCal\n            this.jCal[jCalIndex].splice(index, 1);\n        },\n        _removeObject: function(jCalIndex, cache, nameOrObject) {\n            var i = 0;\n            var objects = this.jCal[jCalIndex];\n            var len = objects.length;\n            var cached = this[cache];\n            if (typeof nameOrObject === \"string\") {\n                for(; i < len; i++){\n                    if (objects[i][NAME_INDEX] === nameOrObject) {\n                        this._removeObjectByIndex(jCalIndex, cached, i);\n                        return true;\n                    }\n                }\n            } else if (cached) {\n                for(; i < len; i++){\n                    if (cached[i] && cached[i] === nameOrObject) {\n                        this._removeObjectByIndex(jCalIndex, cached, i);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        _removeAllObjects: function(jCalIndex, cache, name) {\n            var cached = this[cache];\n            // Unfortunately we have to run through all children to reset their\n            // parent property.\n            var objects = this.jCal[jCalIndex];\n            var i = objects.length - 1;\n            // descending search required because splice\n            // is used and will effect the indices.\n            for(; i >= 0; i--){\n                if (!name || objects[i][NAME_INDEX] === name) {\n                    this._removeObjectByIndex(jCalIndex, cached, i);\n                }\n            }\n        },\n        /**\n     * Adds a single sub component.\n     *\n     * @param {ICAL.Component} component        The component to add\n     * @return {ICAL.Component}                 The passed in component\n     */ addSubcomponent: function(component) {\n            if (!this._components) {\n                this._components = [];\n                this._hydratedComponentCount = 0;\n            }\n            if (component.parent) {\n                component.parent.removeSubcomponent(component);\n            }\n            var idx = this.jCal[COMPONENT_INDEX].push(component.jCal);\n            this._components[idx - 1] = component;\n            this._hydratedComponentCount++;\n            component.parent = this;\n            return component;\n        },\n        /**\n     * Removes a single component by name or the instance of a specific\n     * component.\n     *\n     * @param {ICAL.Component|String} nameOrComp    Name of component, or component\n     * @return {Boolean}                            True when comp is removed\n     */ removeSubcomponent: function(nameOrComp) {\n            var removed = this._removeObject(COMPONENT_INDEX, \"_components\", nameOrComp);\n            if (removed) {\n                this._hydratedComponentCount--;\n            }\n            return removed;\n        },\n        /**\n     * Removes all components or (if given) all components by a particular\n     * name.\n     *\n     * @param {String=} name            Lowercase component name\n     */ removeAllSubcomponents: function(name) {\n            var removed = this._removeAllObjects(COMPONENT_INDEX, \"_components\", name);\n            this._hydratedComponentCount = 0;\n            return removed;\n        },\n        /**\n     * Adds an {@link ICAL.Property} to the component.\n     *\n     * @param {ICAL.Property} property      The property to add\n     * @return {ICAL.Property}              The passed in property\n     */ addProperty: function(property) {\n            if (!(property instanceof ICAL.Property)) {\n                throw new TypeError(\"must instance of ICAL.Property\");\n            }\n            if (!this._properties) {\n                this._properties = [];\n                this._hydratedPropertyCount = 0;\n            }\n            if (property.parent) {\n                property.parent.removeProperty(property);\n            }\n            var idx = this.jCal[PROPERTY_INDEX].push(property.jCal);\n            this._properties[idx - 1] = property;\n            this._hydratedPropertyCount++;\n            property.parent = this;\n            return property;\n        },\n        /**\n     * Helper method to add a property with a value to the component.\n     *\n     * @param {String}               name         Property name to add\n     * @param {String|Number|Object} value        Property value\n     * @return {ICAL.Property}                    The created property\n     */ addPropertyWithValue: function(name, value1) {\n            var prop = new ICAL.Property(name);\n            prop.setValue(value1);\n            this.addProperty(prop);\n            return prop;\n        },\n        /**\n     * Helper method that will update or create a property of the given name\n     * and sets its value. If multiple properties with the given name exist,\n     * only the first is updated.\n     *\n     * @param {String}               name         Property name to update\n     * @param {String|Number|Object} value        Property value\n     * @return {ICAL.Property}                    The created property\n     */ updatePropertyWithValue: function(name, value1) {\n            var prop = this.getFirstProperty(name);\n            if (prop) {\n                prop.setValue(value1);\n            } else {\n                prop = this.addPropertyWithValue(name, value1);\n            }\n            return prop;\n        },\n        /**\n     * Removes a single property by name or the instance of the specific\n     * property.\n     *\n     * @param {String|ICAL.Property} nameOrProp     Property name or instance to remove\n     * @return {Boolean}                            True, when deleted\n     */ removeProperty: function(nameOrProp) {\n            var removed = this._removeObject(PROPERTY_INDEX, \"_properties\", nameOrProp);\n            if (removed) {\n                this._hydratedPropertyCount--;\n            }\n            return removed;\n        },\n        /**\n     * Removes all properties associated with this component, optionally\n     * filtered by name.\n     *\n     * @param {String=} name        Lowercase property name\n     * @return {Boolean}            True, when deleted\n     */ removeAllProperties: function(name) {\n            var removed = this._removeAllObjects(PROPERTY_INDEX, \"_properties\", name);\n            this._hydratedPropertyCount = 0;\n            return removed;\n        },\n        /**\n     * Returns the Object representation of this component. The returned object\n     * is a live jCal object and should be cloned if modified.\n     * @return {Object}\n     */ toJSON: function() {\n            return this.jCal;\n        },\n        /**\n     * The string representation of this component.\n     * @return {String}\n     */ toString: function() {\n            return ICAL.stringify.component(this.jCal, this._designSet);\n        }\n    };\n    /**\n   * Create an {@link ICAL.Component} by parsing the passed iCalendar string.\n   *\n   * @param {String} str        The iCalendar string to parse\n   */ Component.fromString = function(str) {\n        return new Component(ICAL.parse.component(str));\n    };\n    return Component;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */ /**\n * This symbol is further described later on\n * @ignore\n */ ICAL.Property = function() {\n    \"use strict\";\n    var NAME_INDEX = 0;\n    var PROP_INDEX = 1;\n    var TYPE_INDEX = 2;\n    var VALUE_INDEX = 3;\n    var design = ICAL.design;\n    /**\n   * @classdesc\n   * Provides a layer on top of the raw jCal object for manipulating a single\n   * property, with its parameters and value.\n   *\n   * @description\n   * It is important to note that mutations done in the wrapper\n   * directly mutate the jCal object used to initialize.\n   *\n   * Can also be used to create new properties by passing\n   * the name of the property (as a String).\n   *\n   * @class\n   * @alias ICAL.Property\n   * @param {Array|String} jCal         Raw jCal representation OR\n   *  the new name of the property\n   *\n   * @param {ICAL.Component=} parent    Parent component\n   */ function Property(jCal, parent) {\n        this._parent = parent || null;\n        if (typeof jCal === \"string\") {\n            // We are creating the property by name and need to detect the type\n            this.jCal = [\n                jCal,\n                {},\n                design.defaultType\n            ];\n            this.jCal[TYPE_INDEX] = this.getDefaultType();\n        } else {\n            this.jCal = jCal;\n        }\n        this._updateType();\n    }\n    Property.prototype = {\n        /**\n     * The value type for this property\n     * @readonly\n     * @type {String}\n     */ get type () {\n            return this.jCal[TYPE_INDEX];\n        },\n        /**\n     * The name of this property, in lowercase.\n     * @readonly\n     * @type {String}\n     */ get name () {\n            return this.jCal[NAME_INDEX];\n        },\n        /**\n     * The parent component for this property.\n     * @type {ICAL.Component}\n     */ get parent () {\n            return this._parent;\n        },\n        set parent (p){\n            // Before setting the parent, check if the design set has changed. If it\n            // has, we later need to update the type if it was unknown before.\n            var designSetChanged = !this._parent || p && p._designSet != this._parent._designSet;\n            this._parent = p;\n            if (this.type == design.defaultType && designSetChanged) {\n                this.jCal[TYPE_INDEX] = this.getDefaultType();\n                this._updateType();\n            }\n            return p;\n        },\n        /**\n     * The design set for this property, e.g. icalendar vs vcard\n     *\n     * @type {ICAL.design.designSet}\n     * @private\n     */ get _designSet () {\n            return this.parent ? this.parent._designSet : design.defaultSet;\n        },\n        /**\n     * Updates the type metadata from the current jCal type and design set.\n     *\n     * @private\n     */ _updateType: function() {\n            var designSet = this._designSet;\n            if (this.type in designSet.value) {\n                var designType = designSet.value[this.type];\n                if (\"decorate\" in designSet.value[this.type]) {\n                    this.isDecorated = true;\n                } else {\n                    this.isDecorated = false;\n                }\n                if (this.name in designSet.property) {\n                    this.isMultiValue = \"multiValue\" in designSet.property[this.name];\n                    this.isStructuredValue = \"structuredValue\" in designSet.property[this.name];\n                }\n            }\n        },\n        /**\n     * Hydrate a single value. The act of hydrating means turning the raw jCal\n     * value into a potentially wrapped object, for example {@link ICAL.Time}.\n     *\n     * @private\n     * @param {Number} index        The index of the value to hydrate\n     * @return {Object}             The decorated value.\n     */ _hydrateValue: function(index) {\n            if (this._values && this._values[index]) {\n                return this._values[index];\n            }\n            // for the case where there is no value.\n            if (this.jCal.length <= VALUE_INDEX + index) {\n                return null;\n            }\n            if (this.isDecorated) {\n                if (!this._values) {\n                    this._values = [];\n                }\n                return this._values[index] = this._decorate(this.jCal[VALUE_INDEX + index]);\n            } else {\n                return this.jCal[VALUE_INDEX + index];\n            }\n        },\n        /**\n     * Decorate a single value, returning its wrapped object. This is used by\n     * the hydrate function to actually wrap the value.\n     *\n     * @private\n     * @param {?} value         The value to decorate\n     * @return {Object}         The decorated value\n     */ _decorate: function(value1) {\n            return this._designSet.value[this.type].decorate(value1, this);\n        },\n        /**\n     * Undecorate a single value, returning its raw jCal data.\n     *\n     * @private\n     * @param {Object} value         The value to undecorate\n     * @return {?}                   The undecorated value\n     */ _undecorate: function(value1) {\n            return this._designSet.value[this.type].undecorate(value1, this);\n        },\n        /**\n     * Sets the value at the given index while also hydrating it. The passed\n     * value can either be a decorated or undecorated value.\n     *\n     * @private\n     * @param {?} value             The value to set\n     * @param {Number} index        The index to set it at\n     */ _setDecoratedValue: function(value1, index) {\n            if (!this._values) {\n                this._values = [];\n            }\n            if (typeof value1 === \"object\" && \"icaltype\" in value1) {\n                // decorated value\n                this.jCal[VALUE_INDEX + index] = this._undecorate(value1);\n                this._values[index] = value1;\n            } else {\n                // undecorated value\n                this.jCal[VALUE_INDEX + index] = value1;\n                this._values[index] = this._decorate(value1);\n            }\n        },\n        /**\n     * Gets a parameter on the property.\n     *\n     * @param {String}        name   Parameter name (lowercase)\n     * @return {Array|String}        Parameter value\n     */ getParameter: function(name) {\n            if (name in this.jCal[PROP_INDEX]) {\n                return this.jCal[PROP_INDEX][name];\n            } else {\n                return undefined;\n            }\n        },\n        /**\n     * Gets first parameter on the property.\n     *\n     * @param {String}        name   Parameter name (lowercase)\n     * @return {String}        Parameter value\n     */ getFirstParameter: function(name) {\n            var parameters = this.getParameter(name);\n            if (Array.isArray(parameters)) {\n                return parameters[0];\n            }\n            return parameters;\n        },\n        /**\n     * Sets a parameter on the property.\n     *\n     * @param {String}       name     The parameter name\n     * @param {Array|String} value    The parameter value\n     */ setParameter: function(name, value1) {\n            var lcname = name.toLowerCase();\n            if (typeof value1 === \"string\" && lcname in this._designSet.param && \"multiValue\" in this._designSet.param[lcname]) {\n                value1 = [\n                    value1\n                ];\n            }\n            this.jCal[PROP_INDEX][name] = value1;\n        },\n        /**\n     * Removes a parameter\n     *\n     * @param {String} name     The parameter name\n     */ removeParameter: function(name) {\n            delete this.jCal[PROP_INDEX][name];\n        },\n        /**\n     * Get the default type based on this property's name.\n     *\n     * @return {String}     The default type for this property\n     */ getDefaultType: function() {\n            var name = this.jCal[NAME_INDEX];\n            var designSet = this._designSet;\n            if (name in designSet.property) {\n                var details = designSet.property[name];\n                if (\"defaultType\" in details) {\n                    return details.defaultType;\n                }\n            }\n            return design.defaultType;\n        },\n        /**\n     * Sets type of property and clears out any existing values of the current\n     * type.\n     *\n     * @param {String} type     New iCAL type (see design.*.values)\n     */ resetType: function(type) {\n            this.removeAllValues();\n            this.jCal[TYPE_INDEX] = type;\n            this._updateType();\n        },\n        /**\n     * Finds the first property value.\n     *\n     * @return {String}         First property value\n     */ getFirstValue: function() {\n            return this._hydrateValue(0);\n        },\n        /**\n     * Gets all values on the property.\n     *\n     * NOTE: this creates an array during each call.\n     *\n     * @return {Array}          List of values\n     */ getValues: function() {\n            var len = this.jCal.length - VALUE_INDEX;\n            if (len < 1) {\n                // it is possible for a property to have no value.\n                return [];\n            }\n            var i = 0;\n            var result = [];\n            for(; i < len; i++){\n                result[i] = this._hydrateValue(i);\n            }\n            return result;\n        },\n        /**\n     * Removes all values from this property\n     */ removeAllValues: function() {\n            if (this._values) {\n                this._values.length = 0;\n            }\n            this.jCal.length = 3;\n        },\n        /**\n     * Sets the values of the property.  Will overwrite the existing values.\n     * This can only be used for multi-value properties.\n     *\n     * @param {Array} values    An array of values\n     */ setValues: function(values) {\n            if (!this.isMultiValue) {\n                throw new Error(this.name + \": does not not support mulitValue.\\n\" + \"override isMultiValue\");\n            }\n            var len = values.length;\n            var i = 0;\n            this.removeAllValues();\n            if (len > 0 && typeof values[0] === \"object\" && \"icaltype\" in values[0]) {\n                this.resetType(values[0].icaltype);\n            }\n            if (this.isDecorated) {\n                for(; i < len; i++){\n                    this._setDecoratedValue(values[i], i);\n                }\n            } else {\n                for(; i < len; i++){\n                    this.jCal[VALUE_INDEX + i] = values[i];\n                }\n            }\n        },\n        /**\n     * Sets the current value of the property. If this is a multi-value\n     * property, all other values will be removed.\n     *\n     * @param {String|Object} value     New property value.\n     */ setValue: function(value1) {\n            this.removeAllValues();\n            if (typeof value1 === \"object\" && \"icaltype\" in value1) {\n                this.resetType(value1.icaltype);\n            }\n            if (this.isDecorated) {\n                this._setDecoratedValue(value1, 0);\n            } else {\n                this.jCal[VALUE_INDEX] = value1;\n            }\n        },\n        /**\n     * Returns the Object representation of this component. The returned object\n     * is a live jCal object and should be cloned if modified.\n     * @return {Object}\n     */ toJSON: function() {\n            return this.jCal;\n        },\n        /**\n     * The string representation of this component.\n     * @return {String}\n     */ toICALString: function() {\n            return ICAL.stringify.property(this.jCal, this._designSet, true);\n        }\n    };\n    /**\n   * Create an {@link ICAL.Property} by parsing the passed iCalendar string.\n   *\n   * @param {String} str                        The iCalendar string to parse\n   * @param {ICAL.design.designSet=} designSet  The design data to use for this property\n   * @return {ICAL.Property}                    The created iCalendar property\n   */ Property.fromString = function(str, designSet) {\n        return new Property(ICAL.parse.property(str, designSet));\n    };\n    return Property;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */ /**\n * This symbol is further described later on\n * @ignore\n */ ICAL.UtcOffset = function() {\n    /**\n   * @classdesc\n   * This class represents the \"duration\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.UtcOffset\n   * @param {Object} aData          An object with members of the utc offset\n   * @param {Number=} aData.hours   The hours for the utc offset\n   * @param {Number=} aData.minutes The minutes in the utc offset\n   * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\n   */ function UtcOffset(aData) {\n        this.fromData(aData);\n    }\n    UtcOffset.prototype = {\n        /**\n     * The hours in the utc-offset\n     * @type {Number}\n     */ hours: 0,\n        /**\n     * The minutes in the utc-offset\n     * @type {Number}\n     */ minutes: 0,\n        /**\n     * The sign of the utc offset, 1 for positive offset, -1 for negative\n     * offsets.\n     * @type {Number}\n     */ factor: 1,\n        /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"utc-offset\"\n     */ icaltype: \"utc-offset\",\n        /**\n     * Returns a clone of the utc offset object.\n     *\n     * @return {ICAL.UtcOffset}     The cloned object\n     */ clone: function() {\n            return ICAL.UtcOffset.fromSeconds(this.toSeconds());\n        },\n        /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData          An object with members of the utc offset\n     * @param {Number=} aData.hours   The hours for the utc offset\n     * @param {Number=} aData.minutes The minutes in the utc offset\n     * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\n     */ fromData: function(aData) {\n            if (aData) {\n                for(var key in aData){\n                    /* istanbul ignore else */ if (aData.hasOwnProperty(key)) {\n                        this[key] = aData[key];\n                    }\n                }\n            }\n            this._normalize();\n        },\n        /**\n     * Sets up the current instance from the given seconds value. The seconds\n     * value is truncated to the minute. Offsets are wrapped when the world\n     * ends, the hour after UTC+14:00 is UTC-12:00.\n     *\n     * @param {Number} aSeconds         The seconds to convert into an offset\n     */ fromSeconds: function(aSeconds) {\n            var secs = Math.abs(aSeconds);\n            this.factor = aSeconds < 0 ? -1 : 1;\n            this.hours = ICAL.helpers.trunc(secs / 3600);\n            secs -= this.hours * 3600;\n            this.minutes = ICAL.helpers.trunc(secs / 60);\n            return this;\n        },\n        /**\n     * Convert the current offset to a value in seconds\n     *\n     * @return {Number}                 The offset in seconds\n     */ toSeconds: function() {\n            return this.factor * (60 * this.minutes + 3600 * this.hours);\n        },\n        /**\n     * Compare this utc offset with another one.\n     *\n     * @param {ICAL.UtcOffset} other        The other offset to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */ compare: function icaltime_compare(other) {\n            var a = this.toSeconds();\n            var b = other.toSeconds();\n            return (a > b) - (b > a);\n        },\n        _normalize: function() {\n            // Range: 97200 seconds (with 1 hour inbetween)\n            var secs = this.toSeconds();\n            var factor = this.factor;\n            while(secs < -43200){\n                secs += 97200;\n            }\n            while(secs > 50400){\n                secs -= 97200;\n            }\n            this.fromSeconds(secs);\n            // Avoid changing the factor when on zero seconds\n            if (secs == 0) {\n                this.factor = factor;\n            }\n        },\n        /**\n     * The iCalendar string representation of this utc-offset.\n     * @return {String}\n     */ toICALString: function() {\n            return ICAL.design.icalendar.value[\"utc-offset\"].toICAL(this.toString());\n        },\n        /**\n     * The string representation of this utc-offset.\n     * @return {String}\n     */ toString: function toString() {\n            return (this.factor == 1 ? \"+\" : \"-\") + ICAL.helpers.pad2(this.hours) + \":\" + ICAL.helpers.pad2(this.minutes);\n        }\n    };\n    /**\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed string.\n   *\n   * @param {String} aString    The string to parse\n   * @return {ICAL.Duration}    The created utc-offset instance\n   */ UtcOffset.fromString = function(aString) {\n        // -05:00\n        var options = {};\n        //TODO: support seconds per rfc5545 ?\n        options.factor = aString[0] === \"+\" ? 1 : -1;\n        options.hours = ICAL.helpers.strictParseInt(aString.substr(1, 2));\n        options.minutes = ICAL.helpers.strictParseInt(aString.substr(4, 2));\n        return new ICAL.UtcOffset(options);\n    };\n    /**\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed seconds\n   * value.\n   *\n   * @param {Number} aSeconds       The number of seconds to convert\n   */ UtcOffset.fromSeconds = function(aSeconds) {\n        var instance = new UtcOffset();\n        instance.fromSeconds(aSeconds);\n        return instance;\n    };\n    return UtcOffset;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */ /**\n * This symbol is further described later on\n * @ignore\n */ ICAL.Binary = function() {\n    /**\n   * @classdesc\n   * Represents the BINARY value type, which contains extra methods for\n   * encoding and decoding.\n   *\n   * @class\n   * @alias ICAL.Binary\n   * @param {String} aValue     The binary data for this value\n   */ function Binary(aValue) {\n        this.value = aValue;\n    }\n    Binary.prototype = {\n        /**\n     * The type name, to be used in the jCal object.\n     * @default \"binary\"\n     * @constant\n     */ icaltype: \"binary\",\n        /**\n     * Base64 decode the current value\n     *\n     * @return {String}         The base64-decoded value\n     */ decodeValue: function decodeValue() {\n            return this._b64_decode(this.value);\n        },\n        /**\n     * Encodes the passed parameter with base64 and sets the internal\n     * value to the result.\n     *\n     * @param {String} aValue      The raw binary value to encode\n     */ setEncodedValue: function setEncodedValue(aValue) {\n            this.value = this._b64_encode(aValue);\n        },\n        _b64_encode: function base64_encode(data) {\n            // http://kevin.vanzonneveld.net\n            // +   original by: Tyler Akins (http://rumkin.com)\n            // +   improved by: Bayron Guevara\n            // +   improved by: Thunder.m\n            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n            // +   bugfixed by: Pellentesque Malesuada\n            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n            // +   improved by: Rafa Kukawski (http://kukawski.pl)\n            // *     example 1: base64_encode('Kevin van Zonneveld');\n            // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='\n            // mozilla has this native\n            // - but breaks in 2.0.0.12!\n            //if (typeof this.window['atob'] == 'function') {\n            //    return atob(data);\n            //}\n            var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n            var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc = \"\", tmp_arr = [];\n            if (!data) {\n                return data;\n            }\n            do {\n                o1 = data.charCodeAt(i++);\n                o2 = data.charCodeAt(i++);\n                o3 = data.charCodeAt(i++);\n                bits = o1 << 16 | o2 << 8 | o3;\n                h1 = bits >> 18 & 0x3f;\n                h2 = bits >> 12 & 0x3f;\n                h3 = bits >> 6 & 0x3f;\n                h4 = bits & 0x3f;\n                // use hexets to index into b64, and append result to encoded string\n                tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n            }while (i < data.length);\n            enc = tmp_arr.join(\"\");\n            var r = data.length % 3;\n            return (r ? enc.slice(0, r - 3) : enc) + \"===\".slice(r || 3);\n        },\n        _b64_decode: function base64_decode(data) {\n            // http://kevin.vanzonneveld.net\n            // +   original by: Tyler Akins (http://rumkin.com)\n            // +   improved by: Thunder.m\n            // +      input by: Aman Gupta\n            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n            // +   bugfixed by: Onno Marsman\n            // +   bugfixed by: Pellentesque Malesuada\n            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n            // +      input by: Brett Zamir (http://brett-zamir.me)\n            // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n            // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');\n            // *     returns 1: 'Kevin van Zonneveld'\n            // mozilla has this native\n            // - but breaks in 2.0.0.12!\n            //if (typeof this.window['btoa'] == 'function') {\n            //    return btoa(data);\n            //}\n            var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n            var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, dec = \"\", tmp_arr = [];\n            if (!data) {\n                return data;\n            }\n            data += \"\";\n            do {\n                h1 = b64.indexOf(data.charAt(i++));\n                h2 = b64.indexOf(data.charAt(i++));\n                h3 = b64.indexOf(data.charAt(i++));\n                h4 = b64.indexOf(data.charAt(i++));\n                bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n                o1 = bits >> 16 & 0xff;\n                o2 = bits >> 8 & 0xff;\n                o3 = bits & 0xff;\n                if (h3 == 64) {\n                    tmp_arr[ac++] = String.fromCharCode(o1);\n                } else if (h4 == 64) {\n                    tmp_arr[ac++] = String.fromCharCode(o1, o2);\n                } else {\n                    tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);\n                }\n            }while (i < data.length);\n            dec = tmp_arr.join(\"\");\n            return dec;\n        },\n        /**\n     * The string representation of this value\n     * @return {String}\n     */ toString: function() {\n            return this.value;\n        }\n    };\n    /**\n   * Creates a binary value from the given string.\n   *\n   * @param {String} aString        The binary value string\n   * @return {ICAL.Binary}          The binary value instance\n   */ Binary.fromString = function(aString) {\n        return new Binary(aString);\n    };\n    return Binary;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */ (function() {\n    /**\n   * @classdesc\n   * This class represents the \"period\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @description\n   * The passed data object cannot contain both and end date and a duration.\n   *\n   * @class\n   * @param {Object} aData                  An object with members of the period\n   * @param {ICAL.Time=} aData.start        The start of the period\n   * @param {ICAL.Time=} aData.end          The end of the period\n   * @param {ICAL.Duration=} aData.duration The duration of the period\n   */ ICAL.Period = function icalperiod(aData) {\n        this.wrappedJSObject = this;\n        if (aData && \"start\" in aData) {\n            if (aData.start && !(aData.start instanceof ICAL.Time)) {\n                throw new TypeError(\".start must be an instance of ICAL.Time\");\n            }\n            this.start = aData.start;\n        }\n        if (aData && aData.end && aData.duration) {\n            throw new Error(\"cannot accept both end and duration\");\n        }\n        if (aData && \"end\" in aData) {\n            if (aData.end && !(aData.end instanceof ICAL.Time)) {\n                throw new TypeError(\".end must be an instance of ICAL.Time\");\n            }\n            this.end = aData.end;\n        }\n        if (aData && \"duration\" in aData) {\n            if (aData.duration && !(aData.duration instanceof ICAL.Duration)) {\n                throw new TypeError(\".duration must be an instance of ICAL.Duration\");\n            }\n            this.duration = aData.duration;\n        }\n    };\n    ICAL.Period.prototype = {\n        /**\n     * The start of the period\n     * @type {ICAL.Time}\n     */ start: null,\n        /**\n     * The end of the period\n     * @type {ICAL.Time}\n     */ end: null,\n        /**\n     * The duration of the period\n     * @type {ICAL.Duration}\n     */ duration: null,\n        /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalperiod\"\n     */ icalclass: \"icalperiod\",\n        /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"period\"\n     */ icaltype: \"period\",\n        /**\n     * Returns a clone of the duration object.\n     *\n     * @return {ICAL.Period}      The cloned object\n     */ clone: function() {\n            return ICAL.Period.fromData({\n                start: this.start ? this.start.clone() : null,\n                end: this.end ? this.end.clone() : null,\n                duration: this.duration ? this.duration.clone() : null\n            });\n        },\n        /**\n     * Calculates the duration of the period, either directly or by subtracting\n     * start from end date.\n     *\n     * @return {ICAL.Duration}      The calculated duration\n     */ getDuration: function duration() {\n            if (this.duration) {\n                return this.duration;\n            } else {\n                return this.end.subtractDate(this.start);\n            }\n        },\n        /**\n     * Calculates the end date of the period, either directly or by adding\n     * duration to start date.\n     *\n     * @return {ICAL.Time}          The calculated end date\n     */ getEnd: function() {\n            if (this.end) {\n                return this.end;\n            } else {\n                var end = this.start.clone();\n                end.addDuration(this.duration);\n                return end;\n            }\n        },\n        /**\n     * The string representation of this period.\n     * @return {String}\n     */ toString: function toString() {\n            return this.start + \"/\" + (this.end || this.duration);\n        },\n        /**\n     * The jCal representation of this period type.\n     * @return {Object}\n     */ toJSON: function() {\n            return [\n                this.start.toString(),\n                (this.end || this.duration).toString()\n            ];\n        },\n        /**\n     * The iCalendar string representation of this period.\n     * @return {String}\n     */ toICALString: function() {\n            return this.start.toICALString() + \"/\" + (this.end || this.duration).toICALString();\n        }\n    };\n    /**\n   * Creates a new {@link ICAL.Period} instance from the passed string.\n   *\n   * @param {String} str            The string to parse\n   * @param {ICAL.Property} prop    The property this period will be on\n   * @return {ICAL.Period}          The created period instance\n   */ ICAL.Period.fromString = function fromString(str, prop) {\n        var parts = str.split(\"/\");\n        if (parts.length !== 2) {\n            throw new Error('Invalid string value: \"' + str + '\" must contain a \"/\" char.');\n        }\n        var options = {\n            start: ICAL.Time.fromDateTimeString(parts[0], prop)\n        };\n        var end = parts[1];\n        if (ICAL.Duration.isValueString(end)) {\n            options.duration = ICAL.Duration.fromString(end);\n        } else {\n            options.end = ICAL.Time.fromDateTimeString(end, prop);\n        }\n        return new ICAL.Period(options);\n    };\n    /**\n   * Creates a new {@link ICAL.Period} instance from the given data object.\n   * The passed data object cannot contain both and end date and a duration.\n   *\n   * @param {Object} aData                  An object with members of the period\n   * @param {ICAL.Time=} aData.start        The start of the period\n   * @param {ICAL.Time=} aData.end          The end of the period\n   * @param {ICAL.Duration=} aData.duration The duration of the period\n   * @return {ICAL.Period}                  The period instance\n   */ ICAL.Period.fromData = function fromData(aData) {\n        return new ICAL.Period(aData);\n    };\n    /**\n   * Returns a new period instance from the given jCal data array. The first\n   * member is always the start date string, the second member is either a\n   * duration or end date string.\n   *\n   * @param {Array<String,String>} aData    The jCal data array\n   * @param {ICAL.Property} aProp           The property this jCal data is on\n   * @param {Boolean} aLenient              If true, data value can be both date and date-time\n   * @return {ICAL.Period}                  The period instance\n   */ ICAL.Period.fromJSON = function(aData, aProp, aLenient) {\n        function fromDateOrDateTimeString(aValue, aProp) {\n            if (aLenient) {\n                return ICAL.Time.fromString(aValue, aProp);\n            } else {\n                return ICAL.Time.fromDateTimeString(aValue, aProp);\n            }\n        }\n        if (ICAL.Duration.isValueString(aData[1])) {\n            return ICAL.Period.fromData({\n                start: fromDateOrDateTimeString(aData[0], aProp),\n                duration: ICAL.Duration.fromString(aData[1])\n            });\n        } else {\n            return ICAL.Period.fromData({\n                start: fromDateOrDateTimeString(aData[0], aProp),\n                end: fromDateOrDateTimeString(aData[1], aProp)\n            });\n        }\n    };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */ (function() {\n    var DURATION_LETTERS = /([PDWHMTS]{1,1})/;\n    /**\n   * @classdesc\n   * This class represents the \"duration\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.Duration\n   * @param {Object} data               An object with members of the duration\n   * @param {Number} data.weeks         Duration in weeks\n   * @param {Number} data.days          Duration in days\n   * @param {Number} data.hours         Duration in hours\n   * @param {Number} data.minutes       Duration in minutes\n   * @param {Number} data.seconds       Duration in seconds\n   * @param {Boolean} data.isNegative   If true, the duration is negative\n   */ ICAL.Duration = function icalduration(data) {\n        this.wrappedJSObject = this;\n        this.fromData(data);\n    };\n    ICAL.Duration.prototype = {\n        /**\n     * The weeks in this duration\n     * @type {Number}\n     * @default 0\n     */ weeks: 0,\n        /**\n     * The days in this duration\n     * @type {Number}\n     * @default 0\n     */ days: 0,\n        /**\n     * The days in this duration\n     * @type {Number}\n     * @default 0\n     */ hours: 0,\n        /**\n     * The minutes in this duration\n     * @type {Number}\n     * @default 0\n     */ minutes: 0,\n        /**\n     * The seconds in this duration\n     * @type {Number}\n     * @default 0\n     */ seconds: 0,\n        /**\n     * The seconds in this duration\n     * @type {Boolean}\n     * @default false\n     */ isNegative: false,\n        /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalduration\"\n     */ icalclass: \"icalduration\",\n        /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"duration\"\n     */ icaltype: \"duration\",\n        /**\n     * Returns a clone of the duration object.\n     *\n     * @return {ICAL.Duration}      The cloned object\n     */ clone: function clone() {\n            return ICAL.Duration.fromData(this);\n        },\n        /**\n     * The duration value expressed as a number of seconds.\n     *\n     * @return {Number}             The duration value in seconds\n     */ toSeconds: function toSeconds() {\n            var seconds = this.seconds + 60 * this.minutes + 3600 * this.hours + 86400 * this.days + 7 * 86400 * this.weeks;\n            return this.isNegative ? -seconds : seconds;\n        },\n        /**\n     * Reads the passed seconds value into this duration object. Afterwards,\n     * members like {@link ICAL.Duration#days days} and {@link ICAL.Duration#weeks weeks} will be set up\n     * accordingly.\n     *\n     * @param {Number} aSeconds     The duration value in seconds\n     * @return {ICAL.Duration}      Returns this instance\n     */ fromSeconds: function fromSeconds(aSeconds) {\n            var secs = Math.abs(aSeconds);\n            this.isNegative = aSeconds < 0;\n            this.days = ICAL.helpers.trunc(secs / 86400);\n            // If we have a flat number of weeks, use them.\n            if (this.days % 7 == 0) {\n                this.weeks = this.days / 7;\n                this.days = 0;\n            } else {\n                this.weeks = 0;\n            }\n            secs -= (this.days + 7 * this.weeks) * 86400;\n            this.hours = ICAL.helpers.trunc(secs / 3600);\n            secs -= this.hours * 3600;\n            this.minutes = ICAL.helpers.trunc(secs / 60);\n            secs -= this.minutes * 60;\n            this.seconds = secs;\n            return this;\n        },\n        /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData               An object with members of the duration\n     * @param {Number} aData.weeks         Duration in weeks\n     * @param {Number} aData.days          Duration in days\n     * @param {Number} aData.hours         Duration in hours\n     * @param {Number} aData.minutes       Duration in minutes\n     * @param {Number} aData.seconds       Duration in seconds\n     * @param {Boolean} aData.isNegative   If true, the duration is negative\n     */ fromData: function fromData(aData) {\n            var propsToCopy = [\n                \"weeks\",\n                \"days\",\n                \"hours\",\n                \"minutes\",\n                \"seconds\",\n                \"isNegative\"\n            ];\n            for(var key in propsToCopy){\n                /* istanbul ignore if */ if (!propsToCopy.hasOwnProperty(key)) {\n                    continue;\n                }\n                var prop = propsToCopy[key];\n                if (aData && prop in aData) {\n                    this[prop] = aData[prop];\n                } else {\n                    this[prop] = 0;\n                }\n            }\n        },\n        /**\n     * Resets the duration instance to the default values, i.e. PT0S\n     */ reset: function reset() {\n            this.isNegative = false;\n            this.weeks = 0;\n            this.days = 0;\n            this.hours = 0;\n            this.minutes = 0;\n            this.seconds = 0;\n        },\n        /**\n     * Compares the duration instance with another one.\n     *\n     * @param {ICAL.Duration} aOther        The instance to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */ compare: function compare(aOther) {\n            var thisSeconds = this.toSeconds();\n            var otherSeconds = aOther.toSeconds();\n            return (thisSeconds > otherSeconds) - (thisSeconds < otherSeconds);\n        },\n        /**\n     * Normalizes the duration instance. For example, a duration with a value\n     * of 61 seconds will be normalized to 1 minute and 1 second.\n     */ normalize: function normalize() {\n            this.fromSeconds(this.toSeconds());\n        },\n        /**\n     * The string representation of this duration.\n     * @return {String}\n     */ toString: function toString() {\n            if (this.toSeconds() == 0) {\n                return \"PT0S\";\n            } else {\n                var str = \"\";\n                if (this.isNegative) str += \"-\";\n                str += \"P\";\n                if (this.weeks) str += this.weeks + \"W\";\n                if (this.days) str += this.days + \"D\";\n                if (this.hours || this.minutes || this.seconds) {\n                    str += \"T\";\n                    if (this.hours) str += this.hours + \"H\";\n                    if (this.minutes) str += this.minutes + \"M\";\n                    if (this.seconds) str += this.seconds + \"S\";\n                }\n                return str;\n            }\n        },\n        /**\n     * The iCalendar string representation of this duration.\n     * @return {String}\n     */ toICALString: function() {\n            return this.toString();\n        }\n    };\n    /**\n   * Returns a new ICAL.Duration instance from the passed seconds value.\n   *\n   * @param {Number} aSeconds       The seconds to create the instance from\n   * @return {ICAL.Duration}        The newly created duration instance\n   */ ICAL.Duration.fromSeconds = function icalduration_from_seconds(aSeconds) {\n        return new ICAL.Duration().fromSeconds(aSeconds);\n    };\n    /**\n   * Internal helper function to handle a chunk of a duration.\n   *\n   * @param {String} letter type of duration chunk\n   * @param {String} number numeric value or -/+\n   * @param {Object} dict target to assign values to\n   */ function parseDurationChunk(letter, number, object) {\n        var type;\n        switch(letter){\n            case \"P\":\n                if (number && number === \"-\") {\n                    object.isNegative = true;\n                } else {\n                    object.isNegative = false;\n                }\n                break;\n            case \"D\":\n                type = \"days\";\n                break;\n            case \"W\":\n                type = \"weeks\";\n                break;\n            case \"H\":\n                type = \"hours\";\n                break;\n            case \"M\":\n                type = \"minutes\";\n                break;\n            case \"S\":\n                type = \"seconds\";\n                break;\n            default:\n                // Not a valid chunk\n                return 0;\n        }\n        if (type) {\n            if (!number && number !== 0) {\n                throw new Error('invalid duration value: Missing number before \"' + letter + '\"');\n            }\n            var num = parseInt(number, 10);\n            if (ICAL.helpers.isStrictlyNaN(num)) {\n                throw new Error('invalid duration value: Invalid number \"' + number + '\" before \"' + letter + '\"');\n            }\n            object[type] = num;\n        }\n        return 1;\n    }\n    /**\n   * Checks if the given string is an iCalendar duration value.\n   *\n   * @param {String} value      The raw ical value\n   * @return {Boolean}          True, if the given value is of the\n   *                              duration ical type\n   */ ICAL.Duration.isValueString = function(string) {\n        return string[0] === \"P\" || string[1] === \"P\";\n    };\n    /**\n   * Creates a new {@link ICAL.Duration} instance from the passed string.\n   *\n   * @param {String} aStr       The string to parse\n   * @return {ICAL.Duration}    The created duration instance\n   */ ICAL.Duration.fromString = function icalduration_from_string(aStr) {\n        var pos = 0;\n        var dict = Object.create(null);\n        var chunks = 0;\n        while((pos = aStr.search(DURATION_LETTERS)) !== -1){\n            var type = aStr[pos];\n            var numeric = aStr.substr(0, pos);\n            aStr = aStr.substr(pos + 1);\n            chunks += parseDurationChunk(type, numeric, dict);\n        }\n        if (chunks < 2) {\n            // There must be at least a chunk with \"P\" and some unit chunk\n            throw new Error('invalid duration value: Not enough duration components in \"' + aStr + '\"');\n        }\n        return new ICAL.Duration(dict);\n    };\n    /**\n   * Creates a new ICAL.Duration instance from the given data object.\n   *\n   * @param {Object} aData               An object with members of the duration\n   * @param {Number} aData.weeks         Duration in weeks\n   * @param {Number} aData.days          Duration in days\n   * @param {Number} aData.hours         Duration in hours\n   * @param {Number} aData.minutes       Duration in minutes\n   * @param {Number} aData.seconds       Duration in seconds\n   * @param {Boolean} aData.isNegative   If true, the duration is negative\n   * @return {ICAL.Duration}             The createad duration instance\n   */ ICAL.Duration.fromData = function icalduration_from_data(aData) {\n        return new ICAL.Duration(aData);\n    };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2012 */ (function() {\n    var OPTIONS = [\n        \"tzid\",\n        \"location\",\n        \"tznames\",\n        \"latitude\",\n        \"longitude\"\n    ];\n    /**\n   * @classdesc\n   * Timezone representation, created by passing in a tzid and component.\n   *\n   * @example\n   * var vcalendar;\n   * var timezoneComp = vcalendar.getFirstSubcomponent('vtimezone');\n   * var tzid = timezoneComp.getFirstPropertyValue('tzid');\n   *\n   * var timezone = new ICAL.Timezone({\n   *   component: timezoneComp,\n   *   tzid\n   * });\n   *\n   * @class\n   * @param {ICAL.Component|Object} data options for class\n   * @param {String|ICAL.Component} data.component\n   *        If data is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} data.tzid      The timezone identifier\n   * @param {String} data.location  The timezone locationw\n   * @param {String} data.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} data.latitude  The latitude of the timezone\n   * @param {Number} data.longitude The longitude of the timezone\n   */ ICAL.Timezone = function icaltimezone(data) {\n        this.wrappedJSObject = this;\n        this.fromData(data);\n    };\n    ICAL.Timezone.prototype = {\n        /**\n     * Timezone identifier\n     * @type {String}\n     */ tzid: \"\",\n        /**\n     * Timezone location\n     * @type {String}\n     */ location: \"\",\n        /**\n     * Alternative timezone name, for the string representation\n     * @type {String}\n     */ tznames: \"\",\n        /**\n     * The primary latitude for the timezone.\n     * @type {Number}\n     */ latitude: 0.0,\n        /**\n     * The primary longitude for the timezone.\n     * @type {Number}\n     */ longitude: 0.0,\n        /**\n     * The vtimezone component for this timezone.\n     * @type {ICAL.Component}\n     */ component: null,\n        /**\n     * The year this timezone has been expanded to. All timezone transition\n     * dates until this year are known and can be used for calculation\n     *\n     * @private\n     * @type {Number}\n     */ expandedUntilYear: 0,\n        /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icaltimezone\"\n     */ icalclass: \"icaltimezone\",\n        /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {ICAL.Component|Object} aData options for class\n     * @param {String|ICAL.Component} aData.component\n     *        If aData is a simple object, then this member can be set to either a\n     *        string containing the component data, or an already parsed\n     *        ICAL.Component\n     * @param {String} aData.tzid      The timezone identifier\n     * @param {String} aData.location  The timezone locationw\n     * @param {String} aData.tznames   An alternative string representation of the\n     *                                  timezone\n     * @param {Number} aData.latitude  The latitude of the timezone\n     * @param {Number} aData.longitude The longitude of the timezone\n     */ fromData: function fromData(aData) {\n            this.expandedUntilYear = 0;\n            this.changes = [];\n            if (aData instanceof ICAL.Component) {\n                // Either a component is passed directly\n                this.component = aData;\n            } else {\n                // Otherwise the component may be in the data object\n                if (aData && \"component\" in aData) {\n                    if (typeof aData.component == \"string\") {\n                        // If a string was passed, parse it as a component\n                        var jCal = ICAL.parse(aData.component);\n                        this.component = new ICAL.Component(jCal);\n                    } else if (aData.component instanceof ICAL.Component) {\n                        // If it was a component already, then just set it\n                        this.component = aData.component;\n                    } else {\n                        // Otherwise just null out the component\n                        this.component = null;\n                    }\n                }\n                // Copy remaining passed properties\n                for(var key in OPTIONS){\n                    /* istanbul ignore else */ if (OPTIONS.hasOwnProperty(key)) {\n                        var prop = OPTIONS[key];\n                        if (aData && prop in aData) {\n                            this[prop] = aData[prop];\n                        }\n                    }\n                }\n            }\n            // If we have a component but no TZID, attempt to get it from the\n            // component's properties.\n            if (this.component instanceof ICAL.Component && !this.tzid) {\n                this.tzid = this.component.getFirstPropertyValue(\"tzid\");\n            }\n            return this;\n        },\n        /**\n     * Finds the utcOffset the given time would occur in this timezone.\n     *\n     * @param {ICAL.Time} tt        The time to check for\n     * @return {Number} utc offset in seconds\n     */ utcOffset: function utcOffset(tt) {\n            if (this == ICAL.Timezone.utcTimezone || this == ICAL.Timezone.localTimezone) {\n                return 0;\n            }\n            this._ensureCoverage(tt.year);\n            if (!this.changes.length) {\n                return 0;\n            }\n            var tt_change = {\n                year: tt.year,\n                month: tt.month,\n                day: tt.day,\n                hour: tt.hour,\n                minute: tt.minute,\n                second: tt.second\n            };\n            var change_num = this._findNearbyChange(tt_change);\n            var change_num_to_use = -1;\n            var step = 1;\n            // TODO: replace with bin search?\n            for(;;){\n                var change = ICAL.helpers.clone(this.changes[change_num], true);\n                if (change.utcOffset < change.prevUtcOffset) {\n                    ICAL.Timezone.adjust_change(change, 0, 0, 0, change.utcOffset);\n                } else {\n                    ICAL.Timezone.adjust_change(change, 0, 0, 0, change.prevUtcOffset);\n                }\n                var cmp = ICAL.Timezone._compare_change_fn(tt_change, change);\n                if (cmp >= 0) {\n                    change_num_to_use = change_num;\n                } else {\n                    step = -1;\n                }\n                if (step == -1 && change_num_to_use != -1) {\n                    break;\n                }\n                change_num += step;\n                if (change_num < 0) {\n                    return 0;\n                }\n                if (change_num >= this.changes.length) {\n                    break;\n                }\n            }\n            var zone_change = this.changes[change_num_to_use];\n            var utcOffset_change = zone_change.utcOffset - zone_change.prevUtcOffset;\n            if (utcOffset_change < 0 && change_num_to_use > 0) {\n                var tmp_change = ICAL.helpers.clone(zone_change, true);\n                ICAL.Timezone.adjust_change(tmp_change, 0, 0, 0, tmp_change.prevUtcOffset);\n                if (ICAL.Timezone._compare_change_fn(tt_change, tmp_change) < 0) {\n                    var prev_zone_change = this.changes[change_num_to_use - 1];\n                    var want_daylight = false; // TODO\n                    if (zone_change.is_daylight != want_daylight && prev_zone_change.is_daylight == want_daylight) {\n                        zone_change = prev_zone_change;\n                    }\n                }\n            }\n            // TODO return is_daylight?\n            return zone_change.utcOffset;\n        },\n        _findNearbyChange: function icaltimezone_find_nearby_change(change) {\n            // find the closest match\n            var idx = ICAL.helpers.binsearchInsert(this.changes, change, ICAL.Timezone._compare_change_fn);\n            if (idx >= this.changes.length) {\n                return this.changes.length - 1;\n            }\n            return idx;\n        },\n        _ensureCoverage: function(aYear) {\n            if (ICAL.Timezone._minimumExpansionYear == -1) {\n                var today = ICAL.Time.now();\n                ICAL.Timezone._minimumExpansionYear = today.year;\n            }\n            var changesEndYear = aYear;\n            if (changesEndYear < ICAL.Timezone._minimumExpansionYear) {\n                changesEndYear = ICAL.Timezone._minimumExpansionYear;\n            }\n            changesEndYear += ICAL.Timezone.EXTRA_COVERAGE;\n            if (changesEndYear > ICAL.Timezone.MAX_YEAR) {\n                changesEndYear = ICAL.Timezone.MAX_YEAR;\n            }\n            if (!this.changes.length || this.expandedUntilYear < aYear) {\n                var subcomps = this.component.getAllSubcomponents();\n                var compLen = subcomps.length;\n                var compIdx = 0;\n                for(; compIdx < compLen; compIdx++){\n                    this._expandComponent(subcomps[compIdx], changesEndYear, this.changes);\n                }\n                this.changes.sort(ICAL.Timezone._compare_change_fn);\n                this.expandedUntilYear = changesEndYear;\n            }\n        },\n        _expandComponent: function(aComponent, aYear, changes) {\n            if (!aComponent.hasProperty(\"dtstart\") || !aComponent.hasProperty(\"tzoffsetto\") || !aComponent.hasProperty(\"tzoffsetfrom\")) {\n                return null;\n            }\n            var dtstart = aComponent.getFirstProperty(\"dtstart\").getFirstValue();\n            var change;\n            function convert_tzoffset(offset) {\n                return offset.factor * (offset.hours * 3600 + offset.minutes * 60);\n            }\n            function init_changes() {\n                var changebase = {};\n                changebase.is_daylight = aComponent.name == \"daylight\";\n                changebase.utcOffset = convert_tzoffset(aComponent.getFirstProperty(\"tzoffsetto\").getFirstValue());\n                changebase.prevUtcOffset = convert_tzoffset(aComponent.getFirstProperty(\"tzoffsetfrom\").getFirstValue());\n                return changebase;\n            }\n            if (!aComponent.hasProperty(\"rrule\") && !aComponent.hasProperty(\"rdate\")) {\n                change = init_changes();\n                change.year = dtstart.year;\n                change.month = dtstart.month;\n                change.day = dtstart.day;\n                change.hour = dtstart.hour;\n                change.minute = dtstart.minute;\n                change.second = dtstart.second;\n                ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n                changes.push(change);\n            } else {\n                var props = aComponent.getAllProperties(\"rdate\");\n                for(var rdatekey in props){\n                    /* istanbul ignore if */ if (!props.hasOwnProperty(rdatekey)) {\n                        continue;\n                    }\n                    var rdate = props[rdatekey];\n                    var time = rdate.getFirstValue();\n                    change = init_changes();\n                    change.year = time.year;\n                    change.month = time.month;\n                    change.day = time.day;\n                    if (time.isDate) {\n                        change.hour = dtstart.hour;\n                        change.minute = dtstart.minute;\n                        change.second = dtstart.second;\n                        if (dtstart.zone != ICAL.Timezone.utcTimezone) {\n                            ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n                        }\n                    } else {\n                        change.hour = time.hour;\n                        change.minute = time.minute;\n                        change.second = time.second;\n                        if (time.zone != ICAL.Timezone.utcTimezone) {\n                            ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n                        }\n                    }\n                    changes.push(change);\n                }\n                var rrule = aComponent.getFirstProperty(\"rrule\");\n                if (rrule) {\n                    rrule = rrule.getFirstValue();\n                    change = init_changes();\n                    if (rrule.until && rrule.until.zone == ICAL.Timezone.utcTimezone) {\n                        rrule.until.adjust(0, 0, 0, change.prevUtcOffset);\n                        rrule.until.zone = ICAL.Timezone.localTimezone;\n                    }\n                    var iterator = rrule.iterator(dtstart);\n                    var occ;\n                    while(occ = iterator.next()){\n                        change = init_changes();\n                        if (occ.year > aYear || !occ) {\n                            break;\n                        }\n                        change.year = occ.year;\n                        change.month = occ.month;\n                        change.day = occ.day;\n                        change.hour = occ.hour;\n                        change.minute = occ.minute;\n                        change.second = occ.second;\n                        change.isDate = occ.isDate;\n                        ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n                        changes.push(change);\n                    }\n                }\n            }\n            return changes;\n        },\n        /**\n     * The string representation of this timezone.\n     * @return {String}\n     */ toString: function toString() {\n            return this.tznames ? this.tznames : this.tzid;\n        }\n    };\n    ICAL.Timezone._compare_change_fn = function icaltimezone_compare_change_fn(a, b) {\n        if (a.year < b.year) return -1;\n        else if (a.year > b.year) return 1;\n        if (a.month < b.month) return -1;\n        else if (a.month > b.month) return 1;\n        if (a.day < b.day) return -1;\n        else if (a.day > b.day) return 1;\n        if (a.hour < b.hour) return -1;\n        else if (a.hour > b.hour) return 1;\n        if (a.minute < b.minute) return -1;\n        else if (a.minute > b.minute) return 1;\n        if (a.second < b.second) return -1;\n        else if (a.second > b.second) return 1;\n        return 0;\n    };\n    /**\n   * Convert the date/time from one zone to the next.\n   *\n   * @param {ICAL.Time} tt                  The time to convert\n   * @param {ICAL.Timezone} from_zone       The source zone to convert from\n   * @param {ICAL.Timezone} to_zone         The target zone to convert to\n   * @return {ICAL.Time}                    The converted date/time object\n   */ ICAL.Timezone.convert_time = function icaltimezone_convert_time(tt, from_zone, to_zone) {\n        if (tt.isDate || from_zone.tzid == to_zone.tzid || from_zone == ICAL.Timezone.localTimezone || to_zone == ICAL.Timezone.localTimezone) {\n            tt.zone = to_zone;\n            return tt;\n        }\n        var utcOffset = from_zone.utcOffset(tt);\n        tt.adjust(0, 0, 0, -utcOffset);\n        utcOffset = to_zone.utcOffset(tt);\n        tt.adjust(0, 0, 0, utcOffset);\n        return null;\n    };\n    /**\n   * Creates a new ICAL.Timezone instance from the passed data object.\n   *\n   * @param {ICAL.Component|Object} aData options for class\n   * @param {String|ICAL.Component} aData.component\n   *        If aData is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} aData.tzid      The timezone identifier\n   * @param {String} aData.location  The timezone locationw\n   * @param {String} aData.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} aData.latitude  The latitude of the timezone\n   * @param {Number} aData.longitude The longitude of the timezone\n   */ ICAL.Timezone.fromData = function icaltimezone_fromData(aData) {\n        var tt = new ICAL.Timezone();\n        return tt.fromData(aData);\n    };\n    /**\n   * The instance describing the UTC timezone\n   * @type {ICAL.Timezone}\n   * @constant\n   * @instance\n   */ ICAL.Timezone.utcTimezone = ICAL.Timezone.fromData({\n        tzid: \"UTC\"\n    });\n    /**\n   * The instance describing the local timezone\n   * @type {ICAL.Timezone}\n   * @constant\n   * @instance\n   */ ICAL.Timezone.localTimezone = ICAL.Timezone.fromData({\n        tzid: \"floating\"\n    });\n    /**\n   * Adjust a timezone change object.\n   * @private\n   * @param {Object} change     The timezone change object\n   * @param {Number} days       The extra amount of days\n   * @param {Number} hours      The extra amount of hours\n   * @param {Number} minutes    The extra amount of minutes\n   * @param {Number} seconds    The extra amount of seconds\n   */ ICAL.Timezone.adjust_change = function icaltimezone_adjust_change(change, days, hours, minutes, seconds) {\n        return ICAL.Time.prototype.adjust.call(change, days, hours, minutes, seconds, change);\n    };\n    ICAL.Timezone._minimumExpansionYear = -1;\n    ICAL.Timezone.MAX_YEAR = 2035; // TODO this is because of time_t, which we don't need. Still usefull?\n    ICAL.Timezone.EXTRA_COVERAGE = 5;\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */ /**\n * This symbol is further described later on\n * @ignore\n */ ICAL.TimezoneService = function() {\n    var zones;\n    /**\n   * @classdesc\n   * Singleton class to contain timezones.  Right now it is all manual registry in\n   * the future we may use this class to download timezone information or handle\n   * loading pre-expanded timezones.\n   *\n   * @namespace\n   * @alias ICAL.TimezoneService\n   */ var TimezoneService = {\n        get count () {\n            return Object.keys(zones).length;\n        },\n        reset: function() {\n            zones = Object.create(null);\n            var utc = ICAL.Timezone.utcTimezone;\n            zones.Z = utc;\n            zones.UTC = utc;\n            zones.GMT = utc;\n        },\n        /**\n     * Checks if timezone id has been registered.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {Boolean}        False, when not present\n     */ has: function(tzid) {\n            return !!zones[tzid];\n        },\n        /**\n     * Returns a timezone by its tzid if present.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {?ICAL.Timezone} The timezone, or null if not found\n     */ get: function(tzid) {\n            return zones[tzid];\n        },\n        /**\n     * Registers a timezone object or component.\n     *\n     * @param {String=} name\n     *        The name of the timezone. Defaults to the component's TZID if not\n     *        passed.\n     * @param {ICAL.Component|ICAL.Timezone} zone\n     *        The initialized zone or vtimezone.\n     */ register: function(name, timezone) {\n            if (name instanceof ICAL.Component) {\n                if (name.name === \"vtimezone\") {\n                    timezone = new ICAL.Timezone(name);\n                    name = timezone.tzid;\n                }\n            }\n            if (timezone instanceof ICAL.Timezone) {\n                zones[name] = timezone;\n            } else {\n                throw new TypeError(\"timezone must be ICAL.Timezone or ICAL.Component\");\n            }\n        },\n        /**\n     * Removes a timezone by its tzid from the list.\n     *\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n     * @return {?ICAL.Timezone} The removed timezone, or null if not registered\n     */ remove: function(tzid) {\n            return delete zones[tzid];\n        }\n    };\n    // initialize defaults\n    TimezoneService.reset();\n    return TimezoneService;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */ (function() {\n    /**\n   * @classdesc\n   * iCalendar Time representation (similar to JS Date object).  Fully\n   * independent of system (OS) timezone / time.  Unlike JS Date, the month\n   * January is 1, not zero.\n   *\n   * @example\n   * var time = new ICAL.Time({\n   *   year: 2012,\n   *   month: 10,\n   *   day: 11\n   *   minute: 0,\n   *   second: 0,\n   *   isDate: false\n   * });\n   *\n   *\n   * @alias ICAL.Time\n   * @class\n   * @param {Object} data           Time initialization\n   * @param {Number=} data.year     The year for this date\n   * @param {Number=} data.month    The month for this date\n   * @param {Number=} data.day      The day for this date\n   * @param {Number=} data.hour     The hour for this date\n   * @param {Number=} data.minute   The minute for this date\n   * @param {Number=} data.second   The second for this date\n   * @param {Boolean=} data.isDate  If true, the instance represents a date (as\n   *                                  opposed to a date-time)\n   * @param {ICAL.Timezone} zone timezone this position occurs in\n   */ ICAL.Time = function icaltime(data, zone) {\n        this.wrappedJSObject = this;\n        var time = this._time = Object.create(null);\n        /* time defaults */ time.year = 0;\n        time.month = 1;\n        time.day = 1;\n        time.hour = 0;\n        time.minute = 0;\n        time.second = 0;\n        time.isDate = false;\n        this.fromData(data, zone);\n    };\n    ICAL.Time._dowCache = {};\n    ICAL.Time._wnCache = {};\n    ICAL.Time.prototype = {\n        /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icaltime\"\n     */ icalclass: \"icaltime\",\n        _cachedUnixTime: null,\n        /**\n     * The type name, to be used in the jCal object. This value may change and\n     * is strictly defined by the {@link ICAL.Time#isDate isDate} member.\n     * @readonly\n     * @type {String}\n     * @default \"date-time\"\n     */ get icaltype () {\n            return this.isDate ? \"date\" : \"date-time\";\n        },\n        /**\n     * The timezone for this time.\n     * @type {ICAL.Timezone}\n     */ zone: null,\n        /**\n     * Internal uses to indicate that a change has been made and the next read\n     * operation must attempt to normalize the value (for example changing the\n     * day to 33).\n     *\n     * @type {Boolean}\n     * @private\n     */ _pendingNormalization: false,\n        /**\n     * Returns a clone of the time object.\n     *\n     * @return {ICAL.Time}              The cloned object\n     */ clone: function() {\n            return new ICAL.Time(this._time, this.zone);\n        },\n        /**\n     * Reset the time instance to epoch time\n     */ reset: function icaltime_reset() {\n            this.fromData(ICAL.Time.epochTime);\n            this.zone = ICAL.Timezone.utcTimezone;\n        },\n        /**\n     * Reset the time instance to the given date/time values.\n     *\n     * @param {Number} year             The year to set\n     * @param {Number} month            The month to set\n     * @param {Number} day              The day to set\n     * @param {Number} hour             The hour to set\n     * @param {Number} minute           The minute to set\n     * @param {Number} second           The second to set\n     * @param {ICAL.Timezone} timezone  The timezone to set\n     */ resetTo: function icaltime_resetTo(year, month, day, hour, minute, second, timezone) {\n            this.fromData({\n                year: year,\n                month: month,\n                day: day,\n                hour: hour,\n                minute: minute,\n                second: second,\n                zone: timezone\n            });\n        },\n        /**\n     * Set up the current instance from the Javascript date value.\n     *\n     * @param {?Date} aDate     The Javascript Date to read, or null to reset\n     * @param {Boolean} useUTC  If true, the UTC values of the date will be used\n     */ fromJSDate: function icaltime_fromJSDate(aDate, useUTC) {\n            if (!aDate) {\n                this.reset();\n            } else {\n                if (useUTC) {\n                    this.zone = ICAL.Timezone.utcTimezone;\n                    this.year = aDate.getUTCFullYear();\n                    this.month = aDate.getUTCMonth() + 1;\n                    this.day = aDate.getUTCDate();\n                    this.hour = aDate.getUTCHours();\n                    this.minute = aDate.getUTCMinutes();\n                    this.second = aDate.getUTCSeconds();\n                } else {\n                    this.zone = ICAL.Timezone.localTimezone;\n                    this.year = aDate.getFullYear();\n                    this.month = aDate.getMonth() + 1;\n                    this.day = aDate.getDate();\n                    this.hour = aDate.getHours();\n                    this.minute = aDate.getMinutes();\n                    this.second = aDate.getSeconds();\n                }\n            }\n            this._cachedUnixTime = null;\n            return this;\n        },\n        /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} aData            Time initialization\n     * @param {Number=} aData.year      The year for this date\n     * @param {Number=} aData.month     The month for this date\n     * @param {Number=} aData.day       The day for this date\n     * @param {Number=} aData.hour      The hour for this date\n     * @param {Number=} aData.minute    The minute for this date\n     * @param {Number=} aData.second    The second for this date\n     * @param {Boolean=} aData.isDate   If true, the instance represents a date\n     *                                    (as opposed to a date-time)\n     * @param {ICAL.Timezone=} aZone    Timezone this position occurs in\n     */ fromData: function fromData(aData, aZone) {\n            if (aData) {\n                for(var key in aData){\n                    /* istanbul ignore else */ if (Object.prototype.hasOwnProperty.call(aData, key)) {\n                        // ical type cannot be set\n                        if (key === \"icaltype\") continue;\n                        this[key] = aData[key];\n                    }\n                }\n            }\n            if (aZone) {\n                this.zone = aZone;\n            }\n            if (aData && !(\"isDate\" in aData)) {\n                this.isDate = !(\"hour\" in aData);\n            } else if (aData && \"isDate\" in aData) {\n                this.isDate = aData.isDate;\n            }\n            if (aData && \"timezone\" in aData) {\n                var zone = ICAL.TimezoneService.get(aData.timezone);\n                this.zone = zone || ICAL.Timezone.localTimezone;\n            }\n            if (aData && \"zone\" in aData) {\n                this.zone = aData.zone;\n            }\n            if (!this.zone) {\n                this.zone = ICAL.Timezone.localTimezone;\n            }\n            this._cachedUnixTime = null;\n            return this;\n        },\n        /**\n     * Calculate the day of week.\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time.weekDay}\n     */ dayOfWeek: function icaltime_dayOfWeek(aWeekStart) {\n            var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n            var dowCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + firstDow;\n            if (dowCacheKey in ICAL.Time._dowCache) {\n                return ICAL.Time._dowCache[dowCacheKey];\n            }\n            // Using Zeller's algorithm\n            var q = this.day;\n            var m = this.month + (this.month < 3 ? 12 : 0);\n            var Y = this.year - (this.month < 3 ? 1 : 0);\n            var h = q + Y + ICAL.helpers.trunc((m + 1) * 26 / 10) + ICAL.helpers.trunc(Y / 4);\n            /* istanbul ignore else */ if (true) {\n                h += ICAL.helpers.trunc(Y / 100) * 6 + ICAL.helpers.trunc(Y / 400);\n            } else {}\n            // Normalize to 1 = wkst\n            h = (h + 7 - firstDow) % 7 + 1;\n            ICAL.Time._dowCache[dowCacheKey] = h;\n            return h;\n        },\n        /**\n     * Calculate the day of year.\n     * @return {Number}\n     */ dayOfYear: function dayOfYear() {\n            var is_leap = ICAL.Time.isLeapYear(this.year) ? 1 : 0;\n            var diypm = ICAL.Time.daysInYearPassedMonth;\n            return diypm[is_leap][this.month - 1] + this.day;\n        },\n        /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * week. The resulting ICAL.Time instance is of icaltype date, even if this\n     * is a date-time.\n     *\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time}      The start of the week (cloned)\n     */ startOfWeek: function startOfWeek(aWeekStart) {\n            var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n            var result = this.clone();\n            result.day -= (this.dayOfWeek() + 7 - firstDow) % 7;\n            result.isDate = true;\n            result.hour = 0;\n            result.minute = 0;\n            result.second = 0;\n            return result;\n        },\n        /**\n     * Returns a copy of the current date/time, shifted to the end of the week.\n     * The resulting ICAL.Time instance is of icaltype date, even if this is a\n     * date-time.\n     *\n     * @param {ICAL.Time.weekDay=} aWeekStart\n     *        The week start weekday, defaults to SUNDAY\n     * @return {ICAL.Time}      The end of the week (cloned)\n     */ endOfWeek: function endOfWeek(aWeekStart) {\n            var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n            var result = this.clone();\n            result.day += (7 - this.dayOfWeek() + firstDow - ICAL.Time.SUNDAY) % 7;\n            result.isDate = true;\n            result.hour = 0;\n            result.minute = 0;\n            result.second = 0;\n            return result;\n        },\n        /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * month. The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The start of the month (cloned)\n     */ startOfMonth: function startOfMonth() {\n            var result = this.clone();\n            result.day = 1;\n            result.isDate = true;\n            result.hour = 0;\n            result.minute = 0;\n            result.second = 0;\n            return result;\n        },\n        /**\n     * Returns a copy of the current date/time, shifted to the end of the\n     * month.  The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The end of the month (cloned)\n     */ endOfMonth: function endOfMonth() {\n            var result = this.clone();\n            result.day = ICAL.Time.daysInMonth(result.month, result.year);\n            result.isDate = true;\n            result.hour = 0;\n            result.minute = 0;\n            result.second = 0;\n            return result;\n        },\n        /**\n     * Returns a copy of the current date/time, rewound to the start of the\n     * year. The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The start of the year (cloned)\n     */ startOfYear: function startOfYear() {\n            var result = this.clone();\n            result.day = 1;\n            result.month = 1;\n            result.isDate = true;\n            result.hour = 0;\n            result.minute = 0;\n            result.second = 0;\n            return result;\n        },\n        /**\n     * Returns a copy of the current date/time, shifted to the end of the\n     * year.  The resulting ICAL.Time instance is of icaltype date, even if\n     * this is a date-time.\n     *\n     * @return {ICAL.Time}      The end of the year (cloned)\n     */ endOfYear: function endOfYear() {\n            var result = this.clone();\n            result.day = 31;\n            result.month = 12;\n            result.isDate = true;\n            result.hour = 0;\n            result.minute = 0;\n            result.second = 0;\n            return result;\n        },\n        /**\n     * First calculates the start of the week, then returns the day of year for\n     * this date. If the day falls into the previous year, the day is zero or negative.\n     *\n     * @param {ICAL.Time.weekDay=} aFirstDayOfWeek\n     *        The week start weekday, defaults to SUNDAY\n     * @return {Number}     The calculated day of year\n     */ startDoyWeek: function startDoyWeek(aFirstDayOfWeek) {\n            var firstDow = aFirstDayOfWeek || ICAL.Time.SUNDAY;\n            var delta = this.dayOfWeek() - firstDow;\n            if (delta < 0) delta += 7;\n            return this.dayOfYear() - delta;\n        },\n        /**\n     * Get the dominical letter for the current year. Letters range from A - G\n     * for common years, and AG to GF for leap years.\n     *\n     * @param {Number} yr           The year to retrieve the letter for\n     * @return {String}             The dominical letter.\n     */ getDominicalLetter: function() {\n            return ICAL.Time.getDominicalLetter(this.year);\n        },\n        /**\n     * Finds the nthWeekDay relative to the current month (not day).  The\n     * returned value is a day relative the month that this month belongs to so\n     * 1 would indicate the first of the month and 40 would indicate a day in\n     * the following month.\n     *\n     * @param {Number} aDayOfWeek   Day of the week see the day name constants\n     * @param {Number} aPos         Nth occurrence of a given week day values\n     *        of 1 and 0 both indicate the first weekday of that type. aPos may\n     *        be either positive or negative\n     *\n     * @return {Number} numeric value indicating a day relative\n     *                   to the current month of this time object\n     */ nthWeekDay: function icaltime_nthWeekDay(aDayOfWeek, aPos) {\n            var daysInMonth = ICAL.Time.daysInMonth(this.month, this.year);\n            var weekday;\n            var pos = aPos;\n            var start = 0;\n            var otherDay = this.clone();\n            if (pos >= 0) {\n                otherDay.day = 1;\n                // because 0 means no position has been given\n                // 1 and 0 indicate the same day.\n                if (pos != 0) {\n                    // remove the extra numeric value\n                    pos--;\n                }\n                // set current start offset to current day.\n                start = otherDay.day;\n                // find the current day of week\n                var startDow = otherDay.dayOfWeek();\n                // calculate the difference between current\n                // day of the week and desired day of the week\n                var offset = aDayOfWeek - startDow;\n                // if the offset goes into the past\n                // week we add 7 so it goes into the next\n                // week. We only want to go forward in time here.\n                if (offset < 0) // this is really important otherwise we would\n                // end up with dates from in the past.\n                offset += 7;\n                // add offset to start so start is the same\n                // day of the week as the desired day of week.\n                start += offset;\n                // because we are going to add (and multiply)\n                // the numeric value of the day we subtract it\n                // from the start position so not to add it twice.\n                start -= aDayOfWeek;\n                // set week day\n                weekday = aDayOfWeek;\n            } else {\n                // then we set it to the last day in the current month\n                otherDay.day = daysInMonth;\n                // find the ends weekday\n                var endDow = otherDay.dayOfWeek();\n                pos++;\n                weekday = endDow - aDayOfWeek;\n                if (weekday < 0) {\n                    weekday += 7;\n                }\n                weekday = daysInMonth - weekday;\n            }\n            weekday += pos * 7;\n            return start + weekday;\n        },\n        /**\n     * Checks if current time is the nth weekday, relative to the current\n     * month.  Will always return false when rule resolves outside of current\n     * month.\n     *\n     * @param {ICAL.Time.weekDay} aDayOfWeek       Day of week to check\n     * @param {Number} aPos                        Relative position\n     * @return {Boolean}                           True, if it is the nth weekday\n     */ isNthWeekDay: function(aDayOfWeek, aPos) {\n            var dow = this.dayOfWeek();\n            if (aPos === 0 && dow === aDayOfWeek) {\n                return true;\n            }\n            // get pos\n            var day = this.nthWeekDay(aDayOfWeek, aPos);\n            if (day === this.day) {\n                return true;\n            }\n            return false;\n        },\n        /**\n     * Calculates the ISO 8601 week number. The first week of a year is the\n     * week that contains the first Thursday. The year can have 53 weeks, if\n     * January 1st is a Friday.\n     *\n     * Note there are regions where the first week of the year is the one that\n     * starts on January 1st, which may offset the week number. Also, if a\n     * different week start is specified, this will also affect the week\n     * number.\n     *\n     * @see ICAL.Time.weekOneStarts\n     * @param {ICAL.Time.weekDay} aWeekStart        The weekday the week starts with\n     * @return {Number}                             The ISO week number\n     */ weekNumber: function weekNumber(aWeekStart) {\n            var wnCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + aWeekStart;\n            if (wnCacheKey in ICAL.Time._wnCache) {\n                return ICAL.Time._wnCache[wnCacheKey];\n            }\n            // This function courtesty of Julian Bucknall, published under the MIT license\n            // http://www.boyet.com/articles/publishedarticles/calculatingtheisoweeknumb.html\n            // plus some fixes to be able to use different week starts.\n            var week1;\n            var dt = this.clone();\n            dt.isDate = true;\n            var isoyear = this.year;\n            if (dt.month == 12 && dt.day > 25) {\n                week1 = ICAL.Time.weekOneStarts(isoyear + 1, aWeekStart);\n                if (dt.compare(week1) < 0) {\n                    week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);\n                } else {\n                    isoyear++;\n                }\n            } else {\n                week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);\n                if (dt.compare(week1) < 0) {\n                    week1 = ICAL.Time.weekOneStarts(--isoyear, aWeekStart);\n                }\n            }\n            var daysBetween = dt.subtractDate(week1).toSeconds() / 86400;\n            var answer = ICAL.helpers.trunc(daysBetween / 7) + 1;\n            ICAL.Time._wnCache[wnCacheKey] = answer;\n            return answer;\n        },\n        /**\n     * Adds the duration to the current time. The instance is modified in\n     * place.\n     *\n     * @param {ICAL.Duration} aDuration         The duration to add\n     */ addDuration: function icaltime_add(aDuration) {\n            var mult = aDuration.isNegative ? -1 : 1;\n            // because of the duration optimizations it is much\n            // more efficient to grab all the values up front\n            // then set them directly (which will avoid a normalization call).\n            // So we don't actually normalize until we need it.\n            var second = this.second;\n            var minute = this.minute;\n            var hour = this.hour;\n            var day = this.day;\n            second += mult * aDuration.seconds;\n            minute += mult * aDuration.minutes;\n            hour += mult * aDuration.hours;\n            day += mult * aDuration.days;\n            day += mult * 7 * aDuration.weeks;\n            this.second = second;\n            this.minute = minute;\n            this.hour = hour;\n            this.day = day;\n            this._cachedUnixTime = null;\n        },\n        /**\n     * Subtract the date details (_excluding_ timezone).  Useful for finding\n     * the relative difference between two time objects excluding their\n     * timezone differences.\n     *\n     * @param {ICAL.Time} aDate     The date to substract\n     * @return {ICAL.Duration}      The difference as a duration\n     */ subtractDate: function icaltime_subtract(aDate) {\n            var unixTime = this.toUnixTime() + this.utcOffset();\n            var other = aDate.toUnixTime() + aDate.utcOffset();\n            return ICAL.Duration.fromSeconds(unixTime - other);\n        },\n        /**\n     * Subtract the date details, taking timezones into account.\n     *\n     * @param {ICAL.Time} aDate  The date to subtract\n     * @return {ICAL.Duration}  The difference in duration\n     */ subtractDateTz: function icaltime_subtract_abs(aDate) {\n            var unixTime = this.toUnixTime();\n            var other = aDate.toUnixTime();\n            return ICAL.Duration.fromSeconds(unixTime - other);\n        },\n        /**\n     * Compares the ICAL.Time instance with another one.\n     *\n     * @param {ICAL.Duration} aOther        The instance to compare with\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */ compare: function icaltime_compare(other) {\n            var a = this.toUnixTime();\n            var b = other.toUnixTime();\n            if (a > b) return 1;\n            if (b > a) return -1;\n            return 0;\n        },\n        /**\n     * Compares only the date part of this instance with another one.\n     *\n     * @param {ICAL.Duration} other         The instance to compare with\n     * @param {ICAL.Timezone} tz            The timezone to compare in\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\n     */ compareDateOnlyTz: function icaltime_compareDateOnlyTz(other, tz) {\n            function cmp(attr) {\n                return ICAL.Time._cmp_attr(a, b, attr);\n            }\n            var a = this.convertToZone(tz);\n            var b = other.convertToZone(tz);\n            var rc = 0;\n            if ((rc = cmp(\"year\")) != 0) return rc;\n            if ((rc = cmp(\"month\")) != 0) return rc;\n            if ((rc = cmp(\"day\")) != 0) return rc;\n            return rc;\n        },\n        /**\n     * Convert the instance into another timezone. The returned ICAL.Time\n     * instance is always a copy.\n     *\n     * @param {ICAL.Timezone} zone      The zone to convert to\n     * @return {ICAL.Time}              The copy, converted to the zone\n     */ convertToZone: function convertToZone(zone) {\n            var copy = this.clone();\n            var zone_equals = this.zone.tzid == zone.tzid;\n            if (!this.isDate && !zone_equals) {\n                ICAL.Timezone.convert_time(copy, this.zone, zone);\n            }\n            copy.zone = zone;\n            return copy;\n        },\n        /**\n     * Calculates the UTC offset of the current date/time in the timezone it is\n     * in.\n     *\n     * @return {Number}     UTC offset in seconds\n     */ utcOffset: function utc_offset() {\n            if (this.zone == ICAL.Timezone.localTimezone || this.zone == ICAL.Timezone.utcTimezone) {\n                return 0;\n            } else {\n                return this.zone.utcOffset(this);\n            }\n        },\n        /**\n     * Returns an RFC 5545 compliant ical representation of this object.\n     *\n     * @return {String} ical date/date-time\n     */ toICALString: function() {\n            var string = this.toString();\n            if (string.length > 10) {\n                return ICAL.design.icalendar.value[\"date-time\"].toICAL(string);\n            } else {\n                return ICAL.design.icalendar.value.date.toICAL(string);\n            }\n        },\n        /**\n     * The string representation of this date/time, in jCal form\n     * (including : and - separators).\n     * @return {String}\n     */ toString: function toString() {\n            var result = this.year + \"-\" + ICAL.helpers.pad2(this.month) + \"-\" + ICAL.helpers.pad2(this.day);\n            if (!this.isDate) {\n                result += \"T\" + ICAL.helpers.pad2(this.hour) + \":\" + ICAL.helpers.pad2(this.minute) + \":\" + ICAL.helpers.pad2(this.second);\n                if (this.zone === ICAL.Timezone.utcTimezone) {\n                    result += \"Z\";\n                }\n            }\n            return result;\n        },\n        /**\n     * Converts the current instance to a Javascript date\n     * @return {Date}\n     */ toJSDate: function toJSDate() {\n            if (this.zone == ICAL.Timezone.localTimezone) {\n                if (this.isDate) {\n                    return new Date(this.year, this.month - 1, this.day);\n                } else {\n                    return new Date(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, 0);\n                }\n            } else {\n                return new Date(this.toUnixTime() * 1000);\n            }\n        },\n        _normalize: function icaltime_normalize() {\n            var isDate = this._time.isDate;\n            if (this._time.isDate) {\n                this._time.hour = 0;\n                this._time.minute = 0;\n                this._time.second = 0;\n            }\n            this.adjust(0, 0, 0, 0);\n            return this;\n        },\n        /**\n     * Adjust the date/time by the given offset\n     *\n     * @param {Number} aExtraDays       The extra amount of days\n     * @param {Number} aExtraHours      The extra amount of hours\n     * @param {Number} aExtraMinutes    The extra amount of minutes\n     * @param {Number} aExtraSeconds    The extra amount of seconds\n     * @param {Number=} aTime           The time to adjust, defaults to the\n     *                                    current instance.\n     */ adjust: function icaltime_adjust(aExtraDays, aExtraHours, aExtraMinutes, aExtraSeconds, aTime) {\n            var minutesOverflow, hoursOverflow, daysOverflow = 0, yearsOverflow = 0;\n            var second, minute, hour, day;\n            var daysInMonth;\n            var time = aTime || this._time;\n            if (!time.isDate) {\n                second = time.second + aExtraSeconds;\n                time.second = second % 60;\n                minutesOverflow = ICAL.helpers.trunc(second / 60);\n                if (time.second < 0) {\n                    time.second += 60;\n                    minutesOverflow--;\n                }\n                minute = time.minute + aExtraMinutes + minutesOverflow;\n                time.minute = minute % 60;\n                hoursOverflow = ICAL.helpers.trunc(minute / 60);\n                if (time.minute < 0) {\n                    time.minute += 60;\n                    hoursOverflow--;\n                }\n                hour = time.hour + aExtraHours + hoursOverflow;\n                time.hour = hour % 24;\n                daysOverflow = ICAL.helpers.trunc(hour / 24);\n                if (time.hour < 0) {\n                    time.hour += 24;\n                    daysOverflow--;\n                }\n            }\n            // Adjust month and year first, because we need to know what month the day\n            // is in before adjusting it.\n            if (time.month > 12) {\n                yearsOverflow = ICAL.helpers.trunc((time.month - 1) / 12);\n            } else if (time.month < 1) {\n                yearsOverflow = ICAL.helpers.trunc(time.month / 12) - 1;\n            }\n            time.year += yearsOverflow;\n            time.month -= 12 * yearsOverflow;\n            // Now take care of the days (and adjust month if needed)\n            day = time.day + aExtraDays + daysOverflow;\n            if (day > 0) {\n                for(;;){\n                    daysInMonth = ICAL.Time.daysInMonth(time.month, time.year);\n                    if (day <= daysInMonth) {\n                        break;\n                    }\n                    time.month++;\n                    if (time.month > 12) {\n                        time.year++;\n                        time.month = 1;\n                    }\n                    day -= daysInMonth;\n                }\n            } else {\n                while(day <= 0){\n                    if (time.month == 1) {\n                        time.year--;\n                        time.month = 12;\n                    } else {\n                        time.month--;\n                    }\n                    day += ICAL.Time.daysInMonth(time.month, time.year);\n                }\n            }\n            time.day = day;\n            this._cachedUnixTime = null;\n            return this;\n        },\n        /**\n     * Sets up the current instance from unix time, the number of seconds since\n     * January 1st, 1970.\n     *\n     * @param {Number} seconds      The seconds to set up with\n     */ fromUnixTime: function fromUnixTime(seconds) {\n            this.zone = ICAL.Timezone.utcTimezone;\n            var epoch = ICAL.Time.epochTime.clone();\n            epoch.adjust(0, 0, 0, seconds);\n            this.year = epoch.year;\n            this.month = epoch.month;\n            this.day = epoch.day;\n            this.hour = epoch.hour;\n            this.minute = epoch.minute;\n            this.second = Math.floor(epoch.second);\n            this._cachedUnixTime = null;\n        },\n        /**\n     * Converts the current instance to seconds since January 1st 1970.\n     *\n     * @return {Number}         Seconds since 1970\n     */ toUnixTime: function toUnixTime() {\n            if (this._cachedUnixTime !== null) {\n                return this._cachedUnixTime;\n            }\n            var offset = this.utcOffset();\n            // we use the offset trick to ensure\n            // that we are getting the actual UTC time\n            var ms = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second - offset);\n            // seconds\n            this._cachedUnixTime = ms / 1000;\n            return this._cachedUnixTime;\n        },\n        /**\n     * Converts time to into Object which can be serialized then re-created\n     * using the constructor.\n     *\n     * @example\n     * // toJSON will automatically be called\n     * var json = JSON.stringify(mytime);\n     *\n     * var deserialized = JSON.parse(json);\n     *\n     * var time = new ICAL.Time(deserialized);\n     *\n     * @return {Object}\n     */ toJSON: function() {\n            var copy = [\n                \"year\",\n                \"month\",\n                \"day\",\n                \"hour\",\n                \"minute\",\n                \"second\",\n                \"isDate\"\n            ];\n            var result = Object.create(null);\n            var i = 0;\n            var len = copy.length;\n            var prop;\n            for(; i < len; i++){\n                prop = copy[i];\n                result[prop] = this[prop];\n            }\n            if (this.zone) {\n                result.timezone = this.zone.tzid;\n            }\n            return result;\n        }\n    };\n    (function setupNormalizeAttributes() {\n        // This needs to run before any instances are created!\n        function defineAttr(attr) {\n            Object.defineProperty(ICAL.Time.prototype, attr, {\n                get: function getTimeAttr() {\n                    if (this._pendingNormalization) {\n                        this._normalize();\n                        this._pendingNormalization = false;\n                    }\n                    return this._time[attr];\n                },\n                set: function setTimeAttr(val) {\n                    // Check if isDate will be set and if was not set to normalize date.\n                    // This avoids losing days when seconds, minutes and hours are zeroed\n                    // what normalize will do when time is a date.\n                    if (attr === \"isDate\" && val && !this._time.isDate) {\n                        this.adjust(0, 0, 0, 0);\n                    }\n                    this._cachedUnixTime = null;\n                    this._pendingNormalization = true;\n                    this._time[attr] = val;\n                    return val;\n                }\n            });\n        }\n        /* istanbul ignore else */ if (\"defineProperty\" in Object) {\n            defineAttr(\"year\");\n            defineAttr(\"month\");\n            defineAttr(\"day\");\n            defineAttr(\"hour\");\n            defineAttr(\"minute\");\n            defineAttr(\"second\");\n            defineAttr(\"isDate\");\n        }\n    })();\n    /**\n   * Returns the days in the given month\n   *\n   * @param {Number} month      The month to check\n   * @param {Number} year       The year to check\n   * @return {Number}           The number of days in the month\n   */ ICAL.Time.daysInMonth = function icaltime_daysInMonth(month, year) {\n        var _daysInMonth = [\n            0,\n            31,\n            28,\n            31,\n            30,\n            31,\n            30,\n            31,\n            31,\n            30,\n            31,\n            30,\n            31\n        ];\n        var days = 30;\n        if (month < 1 || month > 12) return days;\n        days = _daysInMonth[month];\n        if (month == 2) {\n            days += ICAL.Time.isLeapYear(year);\n        }\n        return days;\n    };\n    /**\n   * Checks if the year is a leap year\n   *\n   * @param {Number} year       The year to check\n   * @return {Boolean}          True, if the year is a leap year\n   */ ICAL.Time.isLeapYear = function isLeapYear(year) {\n        if (year <= 1752) {\n            return year % 4 == 0;\n        } else {\n            return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;\n        }\n    };\n    /**\n   * Create a new ICAL.Time from the day of year and year. The date is returned\n   * in floating timezone.\n   *\n   * @param {Number} aDayOfYear     The day of year\n   * @param {Number} aYear          The year to create the instance in\n   * @return {ICAL.Time}            The created instance with the calculated date\n   */ ICAL.Time.fromDayOfYear = function icaltime_fromDayOfYear(aDayOfYear, aYear) {\n        var year = aYear;\n        var doy = aDayOfYear;\n        var tt = new ICAL.Time();\n        tt.auto_normalize = false;\n        var is_leap = ICAL.Time.isLeapYear(year) ? 1 : 0;\n        if (doy < 1) {\n            year--;\n            is_leap = ICAL.Time.isLeapYear(year) ? 1 : 0;\n            doy += ICAL.Time.daysInYearPassedMonth[is_leap][12];\n            return ICAL.Time.fromDayOfYear(doy, year);\n        } else if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][12]) {\n            is_leap = ICAL.Time.isLeapYear(year) ? 1 : 0;\n            doy -= ICAL.Time.daysInYearPassedMonth[is_leap][12];\n            year++;\n            return ICAL.Time.fromDayOfYear(doy, year);\n        }\n        tt.year = year;\n        tt.isDate = true;\n        for(var month = 11; month >= 0; month--){\n            if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][month]) {\n                tt.month = month + 1;\n                tt.day = doy - ICAL.Time.daysInYearPassedMonth[is_leap][month];\n                break;\n            }\n        }\n        tt.auto_normalize = true;\n        return tt;\n    };\n    /**\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\n   *\n   * @deprecated                Use {@link ICAL.Time.fromDateString} instead\n   * @param {String} str        The string to create from\n   * @return {ICAL.Time}        The date/time instance\n   */ ICAL.Time.fromStringv2 = function fromString(str) {\n        return new ICAL.Time({\n            year: parseInt(str.substr(0, 4), 10),\n            month: parseInt(str.substr(5, 2), 10),\n            day: parseInt(str.substr(8, 2), 10),\n            isDate: true\n        });\n    };\n    /**\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\n   *\n   * @param {String} aValue     The string to create from\n   * @return {ICAL.Time}        The date/time instance\n   */ ICAL.Time.fromDateString = function(aValue) {\n        // Dates should have no timezone.\n        // Google likes to sometimes specify Z on dates\n        // we specifically ignore that to avoid issues.\n        // YYYY-MM-DD\n        // 2012-10-10\n        return new ICAL.Time({\n            year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),\n            month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),\n            day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),\n            isDate: true\n        });\n    };\n    /**\n   * Returns a new ICAL.Time instance from a date-time string, e.g\n   * 2015-01-02T03:04:05. If a property is specified, the timezone is set up\n   * from the property's TZID parameter.\n   *\n   * @param {String} aValue         The string to create from\n   * @param {ICAL.Property=} prop   The property the date belongs to\n   * @return {ICAL.Time}            The date/time instance\n   */ ICAL.Time.fromDateTimeString = function(aValue, prop) {\n        if (aValue.length < 19) {\n            throw new Error('invalid date-time value: \"' + aValue + '\"');\n        }\n        var zone;\n        if (aValue[19] && aValue[19] === \"Z\") {\n            zone = \"Z\";\n        } else if (prop) {\n            zone = prop.getParameter(\"tzid\");\n        }\n        // 2012-10-10T10:10:10(Z)?\n        var time = new ICAL.Time({\n            year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),\n            month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),\n            day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),\n            hour: ICAL.helpers.strictParseInt(aValue.substr(11, 2)),\n            minute: ICAL.helpers.strictParseInt(aValue.substr(14, 2)),\n            second: ICAL.helpers.strictParseInt(aValue.substr(17, 2)),\n            timezone: zone\n        });\n        return time;\n    };\n    /**\n   * Returns a new ICAL.Time instance from a date or date-time string,\n   *\n   * @param {String} aValue         The string to create from\n   * @param {ICAL.Property=} prop   The property the date belongs to\n   * @return {ICAL.Time}            The date/time instance\n   */ ICAL.Time.fromString = function fromString(aValue, aProperty) {\n        if (aValue.length > 10) {\n            return ICAL.Time.fromDateTimeString(aValue, aProperty);\n        } else {\n            return ICAL.Time.fromDateString(aValue);\n        }\n    };\n    /**\n   * Creates a new ICAL.Time instance from the given Javascript Date.\n   *\n   * @param {?Date} aDate     The Javascript Date to read, or null to reset\n   * @param {Boolean} useUTC  If true, the UTC values of the date will be used\n   */ ICAL.Time.fromJSDate = function fromJSDate(aDate, useUTC) {\n        var tt = new ICAL.Time();\n        return tt.fromJSDate(aDate, useUTC);\n    };\n    /**\n   * Creates a new ICAL.Time instance from the the passed data object.\n   *\n   * @param {Object} aData            Time initialization\n   * @param {Number=} aData.year      The year for this date\n   * @param {Number=} aData.month     The month for this date\n   * @param {Number=} aData.day       The day for this date\n   * @param {Number=} aData.hour      The hour for this date\n   * @param {Number=} aData.minute    The minute for this date\n   * @param {Number=} aData.second    The second for this date\n   * @param {Boolean=} aData.isDate   If true, the instance represents a date\n   *                                    (as opposed to a date-time)\n   * @param {ICAL.Timezone=} aZone    Timezone this position occurs in\n   */ ICAL.Time.fromData = function fromData(aData, aZone) {\n        var t = new ICAL.Time();\n        return t.fromData(aData, aZone);\n    };\n    /**\n   * Creates a new ICAL.Time instance from the current moment.\n   * The instance is floating - has no timezone relation.\n   * To create an instance considering the time zone, call\n   * ICAL.Time.fromJSDate(new Date(), true)\n   * @return {ICAL.Time}\n   */ ICAL.Time.now = function icaltime_now() {\n        return ICAL.Time.fromJSDate(new Date(), false);\n    };\n    /**\n   * Returns the date on which ISO week number 1 starts.\n   *\n   * @see ICAL.Time#weekNumber\n   * @param {Number} aYear                  The year to search in\n   * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday, used for calculation.\n   * @return {ICAL.Time}                    The date on which week number 1 starts\n   */ ICAL.Time.weekOneStarts = function weekOneStarts(aYear, aWeekStart) {\n        var t = ICAL.Time.fromData({\n            year: aYear,\n            month: 1,\n            day: 1,\n            isDate: true\n        });\n        var dow = t.dayOfWeek();\n        var wkst = aWeekStart || ICAL.Time.DEFAULT_WEEK_START;\n        if (dow > ICAL.Time.THURSDAY) {\n            t.day += 7;\n        }\n        if (wkst > ICAL.Time.THURSDAY) {\n            t.day -= 7;\n        }\n        t.day -= dow - wkst;\n        return t;\n    };\n    /**\n   * Get the dominical letter for the given year. Letters range from A - G for\n   * common years, and AG to GF for leap years.\n   *\n   * @param {Number} yr           The year to retrieve the letter for\n   * @return {String}             The dominical letter.\n   */ ICAL.Time.getDominicalLetter = function(yr) {\n        var LTRS = \"GFEDCBA\";\n        var dom = (yr + (yr / 4 | 0) + (yr / 400 | 0) - (yr / 100 | 0) - 1) % 7;\n        var isLeap = ICAL.Time.isLeapYear(yr);\n        if (isLeap) {\n            return LTRS[(dom + 6) % 7] + LTRS[dom];\n        } else {\n            return LTRS[dom];\n        }\n    };\n    /**\n   * January 1st, 1970 as an ICAL.Time.\n   * @type {ICAL.Time}\n   * @constant\n   * @instance\n   */ ICAL.Time.epochTime = ICAL.Time.fromData({\n        year: 1970,\n        month: 1,\n        day: 1,\n        hour: 0,\n        minute: 0,\n        second: 0,\n        isDate: false,\n        timezone: \"Z\"\n    });\n    ICAL.Time._cmp_attr = function _cmp_attr(a, b, attr) {\n        if (a[attr] > b[attr]) return 1;\n        if (a[attr] < b[attr]) return -1;\n        return 0;\n    };\n    /**\n   * The days that have passed in the year after a given month. The array has\n   * two members, one being an array of passed days for non-leap years, the\n   * other analog for leap years.\n   * @example\n   * var isLeapYear = ICAL.Time.isLeapYear(year);\n   * var passedDays = ICAL.Time.daysInYearPassedMonth[isLeapYear][month];\n   * @type {Array.<Array.<Number>>}\n   */ ICAL.Time.daysInYearPassedMonth = [\n        [\n            0,\n            31,\n            59,\n            90,\n            120,\n            151,\n            181,\n            212,\n            243,\n            273,\n            304,\n            334,\n            365\n        ],\n        [\n            0,\n            31,\n            60,\n            91,\n            121,\n            152,\n            182,\n            213,\n            244,\n            274,\n            305,\n            335,\n            366\n        ]\n    ];\n    /**\n   * The weekday, 1 = SUNDAY, 7 = SATURDAY. Access via\n   * ICAL.Time.MONDAY, ICAL.Time.TUESDAY, ...\n   *\n   * @typedef {Number} weekDay\n   * @memberof ICAL.Time\n   */ ICAL.Time.SUNDAY = 1;\n    ICAL.Time.MONDAY = 2;\n    ICAL.Time.TUESDAY = 3;\n    ICAL.Time.WEDNESDAY = 4;\n    ICAL.Time.THURSDAY = 5;\n    ICAL.Time.FRIDAY = 6;\n    ICAL.Time.SATURDAY = 7;\n    /**\n   * The default weekday for the WKST part.\n   * @constant\n   * @default ICAL.Time.MONDAY\n   */ ICAL.Time.DEFAULT_WEEK_START = ICAL.Time.MONDAY;\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2015 */ (function() {\n    /**\n   * Describes a vCard time, which has slight differences to the ICAL.Time.\n   * Properties can be null if not specified, for example for dates with\n   * reduced accuracy or truncation.\n   *\n   * Note that currently not all methods are correctly re-implemented for\n   * VCardTime. For example, comparison will have undefined results when some\n   * members are null.\n   *\n   * Also, normalization is not yet implemented for this class!\n   *\n   * @alias ICAL.VCardTime\n   * @class\n   * @extends {ICAL.Time}\n   * @param {Object} data                           The data for the time instance\n   * @param {Number=} data.year                     The year for this date\n   * @param {Number=} data.month                    The month for this date\n   * @param {Number=} data.day                      The day for this date\n   * @param {Number=} data.hour                     The hour for this date\n   * @param {Number=} data.minute                   The minute for this date\n   * @param {Number=} data.second                   The second for this date\n   * @param {ICAL.Timezone|ICAL.UtcOffset} zone     The timezone to use\n   * @param {String} icaltype                       The type for this date/time object\n   */ ICAL.VCardTime = function(data, zone, icaltype) {\n        this.wrappedJSObject = this;\n        var time = this._time = Object.create(null);\n        time.year = null;\n        time.month = null;\n        time.day = null;\n        time.hour = null;\n        time.minute = null;\n        time.second = null;\n        this.icaltype = icaltype || \"date-and-or-time\";\n        this.fromData(data, zone);\n    };\n    ICAL.helpers.inherits(ICAL.Time, ICAL.VCardTime, /** @lends ICAL.VCardTime */ {\n        /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"vcardtime\"\n     */ icalclass: \"vcardtime\",\n        /**\n     * The type name, to be used in the jCal object.\n     * @type {String}\n     * @default \"date-and-or-time\"\n     */ icaltype: \"date-and-or-time\",\n        /**\n     * The timezone. This can either be floating, UTC, or an instance of\n     * ICAL.UtcOffset.\n     * @type {ICAL.Timezone|ICAL.UtcOFfset}\n     */ zone: null,\n        /**\n     * Returns a clone of the vcard date/time object.\n     *\n     * @return {ICAL.VCardTime}     The cloned object\n     */ clone: function() {\n            return new ICAL.VCardTime(this._time, this.zone, this.icaltype);\n        },\n        _normalize: function() {\n            return this;\n        },\n        /**\n     * @inheritdoc\n     */ utcOffset: function() {\n            if (this.zone instanceof ICAL.UtcOffset) {\n                return this.zone.toSeconds();\n            } else {\n                return ICAL.Time.prototype.utcOffset.apply(this, arguments);\n            }\n        },\n        /**\n     * Returns an RFC 6350 compliant representation of this object.\n     *\n     * @return {String}         vcard date/time string\n     */ toICALString: function() {\n            return ICAL.design.vcard.value[this.icaltype].toICAL(this.toString());\n        },\n        /**\n     * The string representation of this date/time, in jCard form\n     * (including : and - separators).\n     * @return {String}\n     */ toString: function toString() {\n            var p2 = ICAL.helpers.pad2;\n            var y = this.year, m = this.month, d = this.day;\n            var h = this.hour, mm = this.minute, s = this.second;\n            var hasYear = y !== null, hasMonth = m !== null, hasDay = d !== null;\n            var hasHour = h !== null, hasMinute = mm !== null, hasSecond = s !== null;\n            var datepart = (hasYear ? p2(y) + (hasMonth || hasDay ? \"-\" : \"\") : hasMonth || hasDay ? \"--\" : \"\") + (hasMonth ? p2(m) : \"\") + (hasDay ? \"-\" + p2(d) : \"\");\n            var timepart = (hasHour ? p2(h) : \"-\") + (hasHour && hasMinute ? \":\" : \"\") + (hasMinute ? p2(mm) : \"\") + (!hasHour && !hasMinute ? \"-\" : \"\") + (hasMinute && hasSecond ? \":\" : \"\") + (hasSecond ? p2(s) : \"\");\n            var zone;\n            if (this.zone === ICAL.Timezone.utcTimezone) {\n                zone = \"Z\";\n            } else if (this.zone instanceof ICAL.UtcOffset) {\n                zone = this.zone.toString();\n            } else if (this.zone === ICAL.Timezone.localTimezone) {\n                zone = \"\";\n            } else if (this.zone instanceof ICAL.Timezone) {\n                var offset = ICAL.UtcOffset.fromSeconds(this.zone.utcOffset(this));\n                zone = offset.toString();\n            } else {\n                zone = \"\";\n            }\n            switch(this.icaltype){\n                case \"time\":\n                    return timepart + zone;\n                case \"date-and-or-time\":\n                case \"date-time\":\n                    return datepart + (timepart == \"--\" ? \"\" : \"T\" + timepart + zone);\n                case \"date\":\n                    return datepart;\n            }\n            return null;\n        }\n    });\n    /**\n   * Returns a new ICAL.VCardTime instance from a date and/or time string.\n   *\n   * @param {String} aValue     The string to create from\n   * @param {String} aIcalType  The type for this instance, e.g. date-and-or-time\n   * @return {ICAL.VCardTime}   The date/time instance\n   */ ICAL.VCardTime.fromDateAndOrTimeString = function(aValue, aIcalType) {\n        function part(v, s, e) {\n            return v ? ICAL.helpers.strictParseInt(v.substr(s, e)) : null;\n        }\n        var parts = aValue.split(\"T\");\n        var dt = parts[0], tmz = parts[1];\n        var splitzone = tmz ? ICAL.design.vcard.value.time._splitZone(tmz) : [];\n        var zone = splitzone[0], tm = splitzone[1];\n        var stoi = ICAL.helpers.strictParseInt;\n        var dtlen = dt ? dt.length : 0;\n        var tmlen = tm ? tm.length : 0;\n        var hasDashDate = dt && dt[0] == \"-\" && dt[1] == \"-\";\n        var hasDashTime = tm && tm[0] == \"-\";\n        var o = {\n            year: hasDashDate ? null : part(dt, 0, 4),\n            month: hasDashDate && (dtlen == 4 || dtlen == 7) ? part(dt, 2, 2) : dtlen == 7 ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 5, 2) : null,\n            day: dtlen == 5 ? part(dt, 3, 2) : dtlen == 7 && hasDashDate ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 8, 2) : null,\n            hour: hasDashTime ? null : part(tm, 0, 2),\n            minute: hasDashTime && tmlen == 3 ? part(tm, 1, 2) : tmlen > 4 ? hasDashTime ? part(tm, 1, 2) : part(tm, 3, 2) : null,\n            second: tmlen == 4 ? part(tm, 2, 2) : tmlen == 6 ? part(tm, 4, 2) : tmlen == 8 ? part(tm, 6, 2) : null\n        };\n        if (zone == \"Z\") {\n            zone = ICAL.Timezone.utcTimezone;\n        } else if (zone && zone[3] == \":\") {\n            zone = ICAL.UtcOffset.fromString(zone);\n        } else {\n            zone = null;\n        }\n        return new ICAL.VCardTime(o, zone, aIcalType);\n    };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */ (function() {\n    var DOW_MAP = {\n        SU: ICAL.Time.SUNDAY,\n        MO: ICAL.Time.MONDAY,\n        TU: ICAL.Time.TUESDAY,\n        WE: ICAL.Time.WEDNESDAY,\n        TH: ICAL.Time.THURSDAY,\n        FR: ICAL.Time.FRIDAY,\n        SA: ICAL.Time.SATURDAY\n    };\n    var REVERSE_DOW_MAP = {};\n    for(var key in DOW_MAP){\n        /* istanbul ignore else */ if (DOW_MAP.hasOwnProperty(key)) {\n            REVERSE_DOW_MAP[DOW_MAP[key]] = key;\n        }\n    }\n    var COPY_PARTS = [\n        \"BYSECOND\",\n        \"BYMINUTE\",\n        \"BYHOUR\",\n        \"BYDAY\",\n        \"BYMONTHDAY\",\n        \"BYYEARDAY\",\n        \"BYWEEKNO\",\n        \"BYMONTH\",\n        \"BYSETPOS\"\n    ];\n    /**\n   * @classdesc\n   * This class represents the \"recur\" value type, with various calculation\n   * and manipulation methods.\n   *\n   * @class\n   * @alias ICAL.Recur\n   * @param {Object} data                               An object with members of the recurrence\n   * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value\n   * @param {Number=} data.interval                     The INTERVAL value\n   * @param {ICAL.Time.weekDay=} data.wkst              The week start value\n   * @param {ICAL.Time=} data.until                     The end of the recurrence set\n   * @param {Number=} data.count                        The number of occurrences\n   * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\n   * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\n   * @param {Array.<String>=} data.byday                The BYDAY values\n   * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\n   * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\n   * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\n   */ ICAL.Recur = function icalrecur(data) {\n        this.wrappedJSObject = this;\n        this.parts = {};\n        if (data && typeof data === \"object\") {\n            this.fromData(data);\n        }\n    };\n    ICAL.Recur.prototype = {\n        /**\n     * An object holding the BY-parts of the recurrence rule\n     * @type {Object}\n     */ parts: null,\n        /**\n     * The interval value for the recurrence rule.\n     * @type {Number}\n     */ interval: 1,\n        /**\n     * The week start day\n     *\n     * @type {ICAL.Time.weekDay}\n     * @default ICAL.Time.MONDAY\n     */ wkst: ICAL.Time.MONDAY,\n        /**\n     * The end of the recurrence\n     * @type {?ICAL.Time}\n     */ until: null,\n        /**\n     * The maximum number of occurrences\n     * @type {?Number}\n     */ count: null,\n        /**\n     * The frequency value.\n     * @type {ICAL.Recur.frequencyValues}\n     */ freq: null,\n        /**\n     * The class identifier.\n     * @constant\n     * @type {String}\n     * @default \"icalrecur\"\n     */ icalclass: \"icalrecur\",\n        /**\n     * The type name, to be used in the jCal object.\n     * @constant\n     * @type {String}\n     * @default \"recur\"\n     */ icaltype: \"recur\",\n        /**\n     * Create a new iterator for this recurrence rule. The passed start date\n     * must be the start date of the event, not the start of the range to\n     * search in.\n     *\n     * @example\n     * var recur = comp.getFirstPropertyValue('rrule');\n     * var dtstart = comp.getFirstPropertyValue('dtstart');\n     * var iter = recur.iterator(dtstart);\n     * for (var next = iter.next(); next; next = iter.next()) {\n     *   if (next.compare(rangeStart) < 0) {\n     *     continue;\n     *   }\n     *   console.log(next.toString());\n     * }\n     *\n     * @param {ICAL.Time} aStart        The item's start date\n     * @return {ICAL.RecurIterator}     The recurrence iterator\n     */ iterator: function(aStart) {\n            return new ICAL.RecurIterator({\n                rule: this,\n                dtstart: aStart\n            });\n        },\n        /**\n     * Returns a clone of the recurrence object.\n     *\n     * @return {ICAL.Recur}      The cloned object\n     */ clone: function clone() {\n            return new ICAL.Recur(this.toJSON());\n        },\n        /**\n     * Checks if the current rule is finite, i.e. has a count or until part.\n     *\n     * @return {Boolean}        True, if the rule is finite\n     */ isFinite: function isfinite() {\n            return !!(this.count || this.until);\n        },\n        /**\n     * Checks if the current rule has a count part, and not limited by an until\n     * part.\n     *\n     * @return {Boolean}        True, if the rule is by count\n     */ isByCount: function isbycount() {\n            return !!(this.count && !this.until);\n        },\n        /**\n     * Adds a component (part) to the recurrence rule. This is not a component\n     * in the sense of {@link ICAL.Component}, but a part of the recurrence\n     * rule, i.e. BYMONTH.\n     *\n     * @param {String} aType            The name of the component part\n     * @param {Array|String} aValue     The component value\n     */ addComponent: function addPart(aType, aValue) {\n            var ucname = aType.toUpperCase();\n            if (ucname in this.parts) {\n                this.parts[ucname].push(aValue);\n            } else {\n                this.parts[ucname] = [\n                    aValue\n                ];\n            }\n        },\n        /**\n     * Sets the component value for the given by-part.\n     *\n     * @param {String} aType        The component part name\n     * @param {Array} aValues       The component values\n     */ setComponent: function setComponent(aType, aValues) {\n            this.parts[aType.toUpperCase()] = aValues.slice();\n        },\n        /**\n     * Gets (a copy) of the requested component value.\n     *\n     * @param {String} aType        The component part name\n     * @return {Array}              The component part value\n     */ getComponent: function getComponent(aType) {\n            var ucname = aType.toUpperCase();\n            return ucname in this.parts ? this.parts[ucname].slice() : [];\n        },\n        /**\n     * Retrieves the next occurrence after the given recurrence id. See the\n     * guide on {@tutorial terminology} for more details.\n     *\n     * NOTE: Currently, this method iterates all occurrences from the start\n     * date. It should not be called in a loop for performance reasons. If you\n     * would like to get more than one occurrence, you can iterate the\n     * occurrences manually, see the example on the\n     * {@link ICAL.Recur#iterator iterator} method.\n     *\n     * @param {ICAL.Time} aStartTime        The start of the event series\n     * @param {ICAL.Time} aRecurrenceId     The date of the last occurrence\n     * @return {ICAL.Time}                  The next occurrence after\n     */ getNextOccurrence: function getNextOccurrence(aStartTime, aRecurrenceId) {\n            var iter = this.iterator(aStartTime);\n            var next, cdt;\n            do {\n                next = iter.next();\n            }while (next && next.compare(aRecurrenceId) <= 0);\n            if (next && aRecurrenceId.zone) {\n                next.zone = aRecurrenceId.zone;\n            }\n            return next;\n        },\n        /**\n     * Sets up the current instance using members from the passed data object.\n     *\n     * @param {Object} data                               An object with members of the recurrence\n     * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value\n     * @param {Number=} data.interval                     The INTERVAL value\n     * @param {ICAL.Time.weekDay=} data.wkst              The week start value\n     * @param {ICAL.Time=} data.until                     The end of the recurrence set\n     * @param {Number=} data.count                        The number of occurrences\n     * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\n     * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\n     * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\n     * @param {Array.<String>=} data.byday                The BYDAY values\n     * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\n     * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\n     * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\n     * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\n     * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\n     */ fromData: function(data) {\n            for(var key in data){\n                var uckey = key.toUpperCase();\n                if (uckey in partDesign) {\n                    if (Array.isArray(data[key])) {\n                        this.parts[uckey] = data[key];\n                    } else {\n                        this.parts[uckey] = [\n                            data[key]\n                        ];\n                    }\n                } else {\n                    this[key] = data[key];\n                }\n            }\n            if (this.interval && typeof this.interval != \"number\") {\n                optionDesign.INTERVAL(this.interval, this);\n            }\n            if (this.wkst && typeof this.wkst != \"number\") {\n                this.wkst = ICAL.Recur.icalDayToNumericDay(this.wkst);\n            }\n            if (this.until && !(this.until instanceof ICAL.Time)) {\n                this.until = ICAL.Time.fromString(this.until);\n            }\n        },\n        /**\n     * The jCal representation of this recurrence type.\n     * @return {Object}\n     */ toJSON: function() {\n            var res = Object.create(null);\n            res.freq = this.freq;\n            if (this.count) {\n                res.count = this.count;\n            }\n            if (this.interval > 1) {\n                res.interval = this.interval;\n            }\n            for(var k in this.parts){\n                /* istanbul ignore if */ if (!this.parts.hasOwnProperty(k)) {\n                    continue;\n                }\n                var kparts = this.parts[k];\n                if (Array.isArray(kparts) && kparts.length == 1) {\n                    res[k.toLowerCase()] = kparts[0];\n                } else {\n                    res[k.toLowerCase()] = ICAL.helpers.clone(this.parts[k]);\n                }\n            }\n            if (this.until) {\n                res.until = this.until.toString();\n            }\n            if (\"wkst\" in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {\n                res.wkst = ICAL.Recur.numericDayToIcalDay(this.wkst);\n            }\n            return res;\n        },\n        /**\n     * The string representation of this recurrence rule.\n     * @return {String}\n     */ toString: function icalrecur_toString() {\n            // TODO retain order\n            var str = \"FREQ=\" + this.freq;\n            if (this.count) {\n                str += \";COUNT=\" + this.count;\n            }\n            if (this.interval > 1) {\n                str += \";INTERVAL=\" + this.interval;\n            }\n            for(var k in this.parts){\n                /* istanbul ignore else */ if (this.parts.hasOwnProperty(k)) {\n                    str += \";\" + k + \"=\" + this.parts[k];\n                }\n            }\n            if (this.until) {\n                str += \";UNTIL=\" + this.until.toICALString();\n            }\n            if (\"wkst\" in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {\n                str += \";WKST=\" + ICAL.Recur.numericDayToIcalDay(this.wkst);\n            }\n            return str;\n        }\n    };\n    function parseNumericValue(type, min, max, value1) {\n        var result = value1;\n        if (value1[0] === \"+\") {\n            result = value1.substr(1);\n        }\n        result = ICAL.helpers.strictParseInt(result);\n        if (min !== undefined && value1 < min) {\n            throw new Error(type + ': invalid value \"' + value1 + '\" must be > ' + min);\n        }\n        if (max !== undefined && value1 > max) {\n            throw new Error(type + ': invalid value \"' + value1 + '\" must be < ' + min);\n        }\n        return result;\n    }\n    /**\n   * Convert an ical representation of a day (SU, MO, etc..)\n   * into a numeric value of that day.\n   *\n   * @param {String} string     The iCalendar day name\n   * @param {ICAL.Time.weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {Number}           Numeric value of given day\n   */ ICAL.Recur.icalDayToNumericDay = function toNumericDay(string, aWeekStart) {\n        //XXX: this is here so we can deal\n        //     with possibly invalid string values.\n        var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n        return (DOW_MAP[string] - firstDow + 7) % 7 + 1;\n    };\n    /**\n   * Convert a numeric day value into its ical representation (SU, MO, etc..)\n   *\n   * @param {Number} num        Numeric value of given day\n   * @param {ICAL.Time.weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {String}           The ICAL day value, e.g SU,MO,...\n   */ ICAL.Recur.numericDayToIcalDay = function toIcalDay(num, aWeekStart) {\n        //XXX: this is here so we can deal with possibly invalid number values.\n        //     Also, this allows consistent mapping between day numbers and day\n        //     names for external users.\n        var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n        var dow = num + firstDow - ICAL.Time.SUNDAY;\n        if (dow > 7) {\n            dow -= 7;\n        }\n        return REVERSE_DOW_MAP[dow];\n    };\n    var VALID_DAY_NAMES = /^(SU|MO|TU|WE|TH|FR|SA)$/;\n    var VALID_BYDAY_PART = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/;\n    /**\n   * Possible frequency values for the FREQ part\n   * (YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY, SECONDLY)\n   *\n   * @typedef {String} frequencyValues\n   * @memberof ICAL.Recur\n   */ var ALLOWED_FREQ = [\n        \"SECONDLY\",\n        \"MINUTELY\",\n        \"HOURLY\",\n        \"DAILY\",\n        \"WEEKLY\",\n        \"MONTHLY\",\n        \"YEARLY\"\n    ];\n    var optionDesign = {\n        FREQ: function(value1, dict, fmtIcal) {\n            // yes this is actually equal or faster then regex.\n            // upside here is we can enumerate the valid values.\n            if (ALLOWED_FREQ.indexOf(value1) !== -1) {\n                dict.freq = value1;\n            } else {\n                throw new Error('invalid frequency \"' + value1 + '\" expected: \"' + ALLOWED_FREQ.join(\", \") + '\"');\n            }\n        },\n        COUNT: function(value1, dict, fmtIcal) {\n            dict.count = ICAL.helpers.strictParseInt(value1);\n        },\n        INTERVAL: function(value1, dict, fmtIcal) {\n            dict.interval = ICAL.helpers.strictParseInt(value1);\n            if (dict.interval < 1) {\n                // 0 or negative values are not allowed, some engines seem to generate\n                // it though. Assume 1 instead.\n                dict.interval = 1;\n            }\n        },\n        UNTIL: function(value1, dict, fmtIcal) {\n            if (value1.length > 10) {\n                dict.until = ICAL.design.icalendar.value[\"date-time\"].fromICAL(value1);\n            } else {\n                dict.until = ICAL.design.icalendar.value.date.fromICAL(value1);\n            }\n            if (!fmtIcal) {\n                dict.until = ICAL.Time.fromString(dict.until);\n            }\n        },\n        WKST: function(value1, dict, fmtIcal) {\n            if (VALID_DAY_NAMES.test(value1)) {\n                dict.wkst = ICAL.Recur.icalDayToNumericDay(value1);\n            } else {\n                throw new Error('invalid WKST value \"' + value1 + '\"');\n            }\n        }\n    };\n    var partDesign = {\n        BYSECOND: parseNumericValue.bind(this, \"BYSECOND\", 0, 60),\n        BYMINUTE: parseNumericValue.bind(this, \"BYMINUTE\", 0, 59),\n        BYHOUR: parseNumericValue.bind(this, \"BYHOUR\", 0, 23),\n        BYDAY: function(value1) {\n            if (VALID_BYDAY_PART.test(value1)) {\n                return value1;\n            } else {\n                throw new Error('invalid BYDAY value \"' + value1 + '\"');\n            }\n        },\n        BYMONTHDAY: parseNumericValue.bind(this, \"BYMONTHDAY\", -31, 31),\n        BYYEARDAY: parseNumericValue.bind(this, \"BYYEARDAY\", -366, 366),\n        BYWEEKNO: parseNumericValue.bind(this, \"BYWEEKNO\", -53, 53),\n        BYMONTH: parseNumericValue.bind(this, \"BYMONTH\", 1, 12),\n        BYSETPOS: parseNumericValue.bind(this, \"BYSETPOS\", -366, 366)\n    };\n    /**\n   * Creates a new {@link ICAL.Recur} instance from the passed string.\n   *\n   * @param {String} string         The string to parse\n   * @return {ICAL.Recur}           The created recurrence instance\n   */ ICAL.Recur.fromString = function(string) {\n        var data = ICAL.Recur._stringToData(string, false);\n        return new ICAL.Recur(data);\n    };\n    /**\n   * Creates a new {@link ICAL.Recur} instance using members from the passed\n   * data object.\n   *\n   * @param {Object} aData                              An object with members of the recurrence\n   * @param {ICAL.Recur.frequencyValues=} aData.freq    The frequency value\n   * @param {Number=} aData.interval                    The INTERVAL value\n   * @param {ICAL.Time.weekDay=} aData.wkst             The week start value\n   * @param {ICAL.Time=} aData.until                    The end of the recurrence set\n   * @param {Number=} aData.count                       The number of occurrences\n   * @param {Array.<Number>=} aData.bysecond            The seconds for the BYSECOND part\n   * @param {Array.<Number>=} aData.byminute            The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} aData.byhour              The hours for the BYHOUR part\n   * @param {Array.<String>=} aData.byday               The BYDAY values\n   * @param {Array.<Number>=} aData.bymonthday          The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} aData.byyearday           The days for the BYYEARDAY part\n   * @param {Array.<Number>=} aData.byweekno            The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} aData.bymonth             The month for the BYMONTH part\n   * @param {Array.<Number>=} aData.bysetpos            The positionals for the BYSETPOS part\n   */ ICAL.Recur.fromData = function(aData) {\n        return new ICAL.Recur(aData);\n    };\n    /**\n   * Converts a recurrence string to a data object, suitable for the fromData\n   * method.\n   *\n   * @param {String} string     The string to parse\n   * @param {Boolean} fmtIcal   If true, the string is considered to be an\n   *                              iCalendar string\n   * @return {ICAL.Recur}       The recurrence instance\n   */ ICAL.Recur._stringToData = function(string, fmtIcal) {\n        var dict = Object.create(null);\n        // split is slower in FF but fast enough.\n        // v8 however this is faster then manual split?\n        var values = string.split(\";\");\n        var len = values.length;\n        for(var i = 0; i < len; i++){\n            var parts = values[i].split(\"=\");\n            var ucname = parts[0].toUpperCase();\n            var lcname = parts[0].toLowerCase();\n            var name = fmtIcal ? lcname : ucname;\n            var value1 = parts[1];\n            if (ucname in partDesign) {\n                var partArr = value1.split(\",\");\n                var partArrIdx = 0;\n                var partArrLen = partArr.length;\n                for(; partArrIdx < partArrLen; partArrIdx++){\n                    partArr[partArrIdx] = partDesign[ucname](partArr[partArrIdx]);\n                }\n                dict[name] = partArr.length == 1 ? partArr[0] : partArr;\n            } else if (ucname in optionDesign) {\n                optionDesign[ucname](value1, dict, fmtIcal);\n            } else {\n                // Don't swallow unknown values. Just set them as they are.\n                dict[lcname] = value1;\n            }\n        }\n        return dict;\n    };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */ /**\n * This symbol is further described later on\n * @ignore\n */ ICAL.RecurIterator = function() {\n    /**\n   * @classdesc\n   * An iterator for a single recurrence rule. This class usually doesn't have\n   * to be instanciated directly, the convenience method\n   * {@link ICAL.Recur#iterator} can be used.\n   *\n   * @description\n   * The options object may contain additional members when resuming iteration from a previous run\n   *\n   * @description\n   * The options object may contain additional members when resuming iteration\n   * from a previous run.\n   *\n   * @class\n   * @alias ICAL.RecurIterator\n   * @param {Object} options                The iterator options\n   * @param {ICAL.Recur} options.rule       The rule to iterate.\n   * @param {ICAL.Time} options.dtstart     The start date of the event.\n   * @param {Boolean=} options.initialized  When true, assume that options are\n   *        from a previously constructed iterator. Initialization will not be\n   *        repeated.\n   */ function icalrecur_iterator(options) {\n        this.fromData(options);\n    }\n    icalrecur_iterator.prototype = {\n        /**\n     * True when iteration is finished.\n     * @type {Boolean}\n     */ completed: false,\n        /**\n     * The rule that is being iterated\n     * @type {ICAL.Recur}\n     */ rule: null,\n        /**\n     * The start date of the event being iterated.\n     * @type {ICAL.Time}\n     */ dtstart: null,\n        /**\n     * The last occurrence that was returned from the\n     * {@link ICAL.RecurIterator#next} method.\n     * @type {ICAL.Time}\n     */ last: null,\n        /**\n     * The sequence number from the occurrence\n     * @type {Number}\n     */ occurrence_number: 0,\n        /**\n     * The indices used for the {@link ICAL.RecurIterator#by_data} object.\n     * @type {Object}\n     * @private\n     */ by_indices: null,\n        /**\n     * If true, the iterator has already been initialized\n     * @type {Boolean}\n     * @private\n     */ initialized: false,\n        /**\n     * The initializd by-data.\n     * @type {Object}\n     * @private\n     */ by_data: null,\n        /**\n     * The expanded yeardays\n     * @type {Array}\n     * @private\n     */ days: null,\n        /**\n     * The index in the {@link ICAL.RecurIterator#days} array.\n     * @type {Number}\n     * @private\n     */ days_index: 0,\n        /**\n     * Initialize the recurrence iterator from the passed data object. This\n     * method is usually not called directly, you can initialize the iterator\n     * through the constructor.\n     *\n     * @param {Object} options                The iterator options\n     * @param {ICAL.Recur} options.rule       The rule to iterate.\n     * @param {ICAL.Time} options.dtstart     The start date of the event.\n     * @param {Boolean=} options.initialized  When true, assume that options are\n     *        from a previously constructed iterator. Initialization will not be\n     *        repeated.\n     */ fromData: function(options) {\n            this.rule = ICAL.helpers.formatClassType(options.rule, ICAL.Recur);\n            if (!this.rule) {\n                throw new Error(\"iterator requires a (ICAL.Recur) rule\");\n            }\n            this.dtstart = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);\n            if (!this.dtstart) {\n                throw new Error(\"iterator requires a (ICAL.Time) dtstart\");\n            }\n            if (options.by_data) {\n                this.by_data = options.by_data;\n            } else {\n                this.by_data = ICAL.helpers.clone(this.rule.parts, true);\n            }\n            if (options.occurrence_number) this.occurrence_number = options.occurrence_number;\n            this.days = options.days || [];\n            if (options.last) {\n                this.last = ICAL.helpers.formatClassType(options.last, ICAL.Time);\n            }\n            this.by_indices = options.by_indices;\n            if (!this.by_indices) {\n                this.by_indices = {\n                    \"BYSECOND\": 0,\n                    \"BYMINUTE\": 0,\n                    \"BYHOUR\": 0,\n                    \"BYDAY\": 0,\n                    \"BYMONTH\": 0,\n                    \"BYWEEKNO\": 0,\n                    \"BYMONTHDAY\": 0\n                };\n            }\n            this.initialized = options.initialized || false;\n            if (!this.initialized) {\n                this.init();\n            }\n        },\n        /**\n     * Intialize the iterator\n     * @private\n     */ init: function icalrecur_iterator_init() {\n            this.initialized = true;\n            this.last = this.dtstart.clone();\n            var parts = this.by_data;\n            if (\"BYDAY\" in parts) {\n                // libical does this earlier when the rule is loaded, but we postpone to\n                // now so we can preserve the original order.\n                this.sort_byday_rules(parts.BYDAY);\n            }\n            // If the BYYEARDAY appares, no other date rule part may appear\n            if (\"BYYEARDAY\" in parts) {\n                if (\"BYMONTH\" in parts || \"BYWEEKNO\" in parts || \"BYMONTHDAY\" in parts || \"BYDAY\" in parts) {\n                    throw new Error(\"Invalid BYYEARDAY rule\");\n                }\n            }\n            // BYWEEKNO and BYMONTHDAY rule parts may not both appear\n            if (\"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {\n                throw new Error(\"BYWEEKNO does not fit to BYMONTHDAY\");\n            }\n            // For MONTHLY recurrences (FREQ=MONTHLY) neither BYYEARDAY nor\n            // BYWEEKNO may appear.\n            if (this.rule.freq == \"MONTHLY\" && (\"BYYEARDAY\" in parts || \"BYWEEKNO\" in parts)) {\n                throw new Error(\"For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear\");\n            }\n            // For WEEKLY recurrences (FREQ=WEEKLY) neither BYMONTHDAY nor\n            // BYYEARDAY may appear.\n            if (this.rule.freq == \"WEEKLY\" && (\"BYYEARDAY\" in parts || \"BYMONTHDAY\" in parts)) {\n                throw new Error(\"For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear\");\n            }\n            // BYYEARDAY may only appear in YEARLY rules\n            if (this.rule.freq != \"YEARLY\" && \"BYYEARDAY\" in parts) {\n                throw new Error(\"BYYEARDAY may only appear in YEARLY rules\");\n            }\n            this.last.second = this.setup_defaults(\"BYSECOND\", \"SECONDLY\", this.dtstart.second);\n            this.last.minute = this.setup_defaults(\"BYMINUTE\", \"MINUTELY\", this.dtstart.minute);\n            this.last.hour = this.setup_defaults(\"BYHOUR\", \"HOURLY\", this.dtstart.hour);\n            this.last.day = this.setup_defaults(\"BYMONTHDAY\", \"DAILY\", this.dtstart.day);\n            this.last.month = this.setup_defaults(\"BYMONTH\", \"MONTHLY\", this.dtstart.month);\n            if (this.rule.freq == \"WEEKLY\") {\n                if (\"BYDAY\" in parts) {\n                    var bydayParts = this.ruleDayOfWeek(parts.BYDAY[0], this.rule.wkst);\n                    var pos = bydayParts[0];\n                    var dow = bydayParts[1];\n                    var wkdy = dow - this.last.dayOfWeek(this.rule.wkst);\n                    if (this.last.dayOfWeek(this.rule.wkst) < dow && wkdy >= 0 || wkdy < 0) {\n                        // Initial time is after first day of BYDAY data\n                        this.last.day += wkdy;\n                    }\n                } else {\n                    var dayName = ICAL.Recur.numericDayToIcalDay(this.dtstart.dayOfWeek());\n                    parts.BYDAY = [\n                        dayName\n                    ];\n                }\n            }\n            if (this.rule.freq == \"YEARLY\") {\n                for(;;){\n                    this.expand_year_days(this.last.year);\n                    if (this.days.length > 0) {\n                        break;\n                    }\n                    this.increment_year(this.rule.interval);\n                }\n                this._nextByYearDay();\n            }\n            if (this.rule.freq == \"MONTHLY\" && this.has_by_data(\"BYDAY\")) {\n                var tempLast = null;\n                var initLast = this.last.clone();\n                var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n                // Check every weekday in BYDAY with relative dow and pos.\n                for(var i in this.by_data.BYDAY){\n                    /* istanbul ignore if */ if (!this.by_data.BYDAY.hasOwnProperty(i)) {\n                        continue;\n                    }\n                    this.last = initLast.clone();\n                    var bydayParts = this.ruleDayOfWeek(this.by_data.BYDAY[i]);\n                    var pos = bydayParts[0];\n                    var dow = bydayParts[1];\n                    var dayOfMonth = this.last.nthWeekDay(dow, pos);\n                    // If |pos| >= 6, the byday is invalid for a monthly rule.\n                    if (pos >= 6 || pos <= -6) {\n                        throw new Error(\"Malformed values in BYDAY part\");\n                    }\n                    // If a Byday with pos=+/-5 is not in the current month it\n                    // must be searched in the next months.\n                    if (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\n                        // Skip if we have already found a \"last\" in this month.\n                        if (tempLast && tempLast.month == initLast.month) {\n                            continue;\n                        }\n                        while(dayOfMonth > daysInMonth || dayOfMonth <= 0){\n                            this.increment_month();\n                            daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n                            dayOfMonth = this.last.nthWeekDay(dow, pos);\n                        }\n                    }\n                    this.last.day = dayOfMonth;\n                    if (!tempLast || this.last.compare(tempLast) < 0) {\n                        tempLast = this.last.clone();\n                    }\n                }\n                this.last = tempLast.clone();\n                //XXX: This feels like a hack, but we need to initialize\n                //     the BYMONTHDAY case correctly and byDayAndMonthDay handles\n                //     this case. It accepts a special flag which will avoid incrementing\n                //     the initial value without the flag days that match the start time\n                //     would be missed.\n                if (this.has_by_data(\"BYMONTHDAY\")) {\n                    this._byDayAndMonthDay(true);\n                }\n                if (this.last.day > daysInMonth || this.last.day == 0) {\n                    throw new Error(\"Malformed values in BYDAY part\");\n                }\n            } else if (this.has_by_data(\"BYMONTHDAY\")) {\n                if (this.last.day < 0) {\n                    var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n                    this.last.day = daysInMonth + this.last.day + 1;\n                }\n            }\n        },\n        /**\n     * Retrieve the next occurrence from the iterator.\n     * @return {ICAL.Time}\n     */ next: function icalrecur_iterator_next() {\n            var before = this.last ? this.last.clone() : null;\n            if (this.rule.count && this.occurrence_number >= this.rule.count || this.rule.until && this.last.compare(this.rule.until) > 0) {\n                //XXX: right now this is just a flag and has no impact\n                //     we can simplify the above case to check for completed later.\n                this.completed = true;\n                return null;\n            }\n            if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) {\n                // First of all, give the instance that was initialized\n                this.occurrence_number++;\n                return this.last;\n            }\n            var valid;\n            do {\n                valid = 1;\n                switch(this.rule.freq){\n                    case \"SECONDLY\":\n                        this.next_second();\n                        break;\n                    case \"MINUTELY\":\n                        this.next_minute();\n                        break;\n                    case \"HOURLY\":\n                        this.next_hour();\n                        break;\n                    case \"DAILY\":\n                        this.next_day();\n                        break;\n                    case \"WEEKLY\":\n                        this.next_week();\n                        break;\n                    case \"MONTHLY\":\n                        valid = this.next_month();\n                        break;\n                    case \"YEARLY\":\n                        this.next_year();\n                        break;\n                    default:\n                        return null;\n                }\n            }while (!this.check_contracting_rules() || this.last.compare(this.dtstart) < 0 || !valid);\n            // TODO is this valid?\n            if (this.last.compare(before) == 0) {\n                throw new Error(\"Same occurrence found twice, protecting \" + \"you from death by recursion\");\n            }\n            if (this.rule.until && this.last.compare(this.rule.until) > 0) {\n                this.completed = true;\n                return null;\n            } else {\n                this.occurrence_number++;\n                return this.last;\n            }\n        },\n        next_second: function next_second() {\n            return this.next_generic(\"BYSECOND\", \"SECONDLY\", \"second\", \"minute\");\n        },\n        increment_second: function increment_second(inc) {\n            return this.increment_generic(inc, \"second\", 60, \"minute\");\n        },\n        next_minute: function next_minute() {\n            return this.next_generic(\"BYMINUTE\", \"MINUTELY\", \"minute\", \"hour\", \"next_second\");\n        },\n        increment_minute: function increment_minute(inc) {\n            return this.increment_generic(inc, \"minute\", 60, \"hour\");\n        },\n        next_hour: function next_hour() {\n            return this.next_generic(\"BYHOUR\", \"HOURLY\", \"hour\", \"monthday\", \"next_minute\");\n        },\n        increment_hour: function increment_hour(inc) {\n            this.increment_generic(inc, \"hour\", 24, \"monthday\");\n        },\n        next_day: function next_day() {\n            var has_by_day = \"BYDAY\" in this.by_data;\n            var this_freq = this.rule.freq == \"DAILY\";\n            if (this.next_hour() == 0) {\n                return 0;\n            }\n            if (this_freq) {\n                this.increment_monthday(this.rule.interval);\n            } else {\n                this.increment_monthday(1);\n            }\n            return 0;\n        },\n        next_week: function next_week() {\n            var end_of_data = 0;\n            if (this.next_weekday_by_week() == 0) {\n                return end_of_data;\n            }\n            if (this.has_by_data(\"BYWEEKNO\")) {\n                var idx = ++this.by_indices.BYWEEKNO;\n                if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) {\n                    this.by_indices.BYWEEKNO = 0;\n                    end_of_data = 1;\n                }\n                // HACK should be first month of the year\n                this.last.month = 1;\n                this.last.day = 1;\n                var week_no = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO];\n                this.last.day += 7 * week_no;\n                if (end_of_data) {\n                    this.increment_year(1);\n                }\n            } else {\n                // Jump to the next week\n                this.increment_monthday(7 * this.rule.interval);\n            }\n            return end_of_data;\n        },\n        /**\n     * Normalize each by day rule for a given year/month.\n     * Takes into account ordering and negative rules\n     *\n     * @private\n     * @param {Number} year         Current year.\n     * @param {Number} month        Current month.\n     * @param {Array}  rules        Array of rules.\n     *\n     * @return {Array} sorted and normalized rules.\n     *                 Negative rules will be expanded to their\n     *                 correct positive values for easier processing.\n     */ normalizeByMonthDayRules: function(year, month, rules) {\n            var daysInMonth = ICAL.Time.daysInMonth(month, year);\n            // XXX: This is probably bad for performance to allocate\n            //      a new array for each month we scan, if possible\n            //      we should try to optimize this...\n            var newRules = [];\n            var ruleIdx = 0;\n            var len = rules.length;\n            var rule;\n            for(; ruleIdx < len; ruleIdx++){\n                rule = rules[ruleIdx];\n                // if this rule falls outside of given\n                // month discard it.\n                if (Math.abs(rule) > daysInMonth) {\n                    continue;\n                }\n                // negative case\n                if (rule < 0) {\n                    // we add (not subtract it is a negative number)\n                    // one from the rule because 1 === last day of month\n                    rule = daysInMonth + (rule + 1);\n                } else if (rule === 0) {\n                    continue;\n                }\n                // only add unique items...\n                if (newRules.indexOf(rule) === -1) {\n                    newRules.push(rule);\n                }\n            }\n            // unique and sort\n            return newRules.sort(function(a, b) {\n                return a - b;\n            });\n        },\n        /**\n     * NOTES:\n     * We are given a list of dates in the month (BYMONTHDAY) (23, etc..)\n     * Also we are given a list of days (BYDAY) (MO, 2SU, etc..) when\n     * both conditions match a given date (this.last.day) iteration stops.\n     *\n     * @private\n     * @param {Boolean=} isInit     When given true will not increment the\n     *                                current day (this.last).\n     */ _byDayAndMonthDay: function(isInit) {\n            var byMonthDay; // setup in initMonth\n            var byDay = this.by_data.BYDAY;\n            var date;\n            var dateIdx = 0;\n            var dateLen; // setup in initMonth\n            var dayLen = byDay.length;\n            // we are not valid by default\n            var dataIsValid = 0;\n            var daysInMonth;\n            var self = this;\n            // we need a copy of this, because a DateTime gets normalized\n            // automatically if the day is out of range. At some points we\n            // set the last day to 0 to start counting.\n            var lastDay = this.last.day;\n            function initMonth() {\n                daysInMonth = ICAL.Time.daysInMonth(self.last.month, self.last.year);\n                byMonthDay = self.normalizeByMonthDayRules(self.last.year, self.last.month, self.by_data.BYMONTHDAY);\n                dateLen = byMonthDay.length;\n                // For the case of more than one occurrence in one month\n                // we have to be sure to start searching after the last\n                // found date or at the last BYMONTHDAY, unless we are\n                // initializing the iterator because in this case we have\n                // to consider the last found date too.\n                while(byMonthDay[dateIdx] <= lastDay && !(isInit && byMonthDay[dateIdx] == lastDay) && dateIdx < dateLen - 1){\n                    dateIdx++;\n                }\n            }\n            function nextMonth() {\n                // since the day is incremented at the start\n                // of the loop below, we need to start at 0\n                lastDay = 0;\n                self.increment_month();\n                dateIdx = 0;\n                initMonth();\n            }\n            initMonth();\n            // should come after initMonth\n            if (isInit) {\n                lastDay -= 1;\n            }\n            // Use a counter to avoid an infinite loop with malformed rules.\n            // Stop checking after 4 years so we consider also a leap year.\n            var monthsCounter = 48;\n            while(!dataIsValid && monthsCounter){\n                monthsCounter--;\n                // increment the current date. This is really\n                // important otherwise we may fall into the infinite\n                // loop trap. The initial date takes care of the case\n                // where the current date is the date we are looking\n                // for.\n                date = lastDay + 1;\n                if (date > daysInMonth) {\n                    nextMonth();\n                    continue;\n                }\n                // find next date\n                var next = byMonthDay[dateIdx++];\n                // this logic is dependant on the BYMONTHDAYS\n                // being in order (which is done by #normalizeByMonthDayRules)\n                if (next >= date) {\n                    // if the next month day is in the future jump to it.\n                    lastDay = next;\n                } else {\n                    // in this case the 'next' monthday has past\n                    // we must move to the month.\n                    nextMonth();\n                    continue;\n                }\n                // Now we can loop through the day rules to see\n                // if one matches the current month date.\n                for(var dayIdx = 0; dayIdx < dayLen; dayIdx++){\n                    var parts = this.ruleDayOfWeek(byDay[dayIdx]);\n                    var pos = parts[0];\n                    var dow = parts[1];\n                    this.last.day = lastDay;\n                    if (this.last.isNthWeekDay(dow, pos)) {\n                        // when we find the valid one we can mark\n                        // the conditions as met and break the loop.\n                        // (Because we have this condition above\n                        //  it will also break the parent loop).\n                        dataIsValid = 1;\n                        break;\n                    }\n                }\n                // It is completely possible that the combination\n                // cannot be matched in the current month.\n                // When we reach the end of possible combinations\n                // in the current month we iterate to the next one.\n                // since dateIdx is incremented right after getting\n                // \"next\", we don't need dateLen -1 here.\n                if (!dataIsValid && dateIdx === dateLen) {\n                    nextMonth();\n                    continue;\n                }\n            }\n            if (monthsCounter <= 0) {\n                // Checked 4 years without finding a Byday that matches\n                // a Bymonthday. Maybe the rule is not correct.\n                throw new Error(\"Malformed values in BYDAY combined with BYMONTHDAY parts\");\n            }\n            return dataIsValid;\n        },\n        next_month: function next_month() {\n            var this_freq = this.rule.freq == \"MONTHLY\";\n            var data_valid = 1;\n            if (this.next_hour() == 0) {\n                return data_valid;\n            }\n            if (this.has_by_data(\"BYDAY\") && this.has_by_data(\"BYMONTHDAY\")) {\n                data_valid = this._byDayAndMonthDay();\n            } else if (this.has_by_data(\"BYDAY\")) {\n                var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n                var setpos = 0;\n                var setpos_total = 0;\n                if (this.has_by_data(\"BYSETPOS\")) {\n                    var last_day = this.last.day;\n                    for(var day = 1; day <= daysInMonth; day++){\n                        this.last.day = day;\n                        if (this.is_day_in_byday(this.last)) {\n                            setpos_total++;\n                            if (day <= last_day) {\n                                setpos++;\n                            }\n                        }\n                    }\n                    this.last.day = last_day;\n                }\n                data_valid = 0;\n                for(var day = this.last.day + 1; day <= daysInMonth; day++){\n                    this.last.day = day;\n                    if (this.is_day_in_byday(this.last)) {\n                        if (!this.has_by_data(\"BYSETPOS\") || this.check_set_position(++setpos) || this.check_set_position(setpos - setpos_total - 1)) {\n                            data_valid = 1;\n                            break;\n                        }\n                    }\n                }\n                if (day > daysInMonth) {\n                    this.last.day = 1;\n                    this.increment_month();\n                    if (this.is_day_in_byday(this.last)) {\n                        if (!this.has_by_data(\"BYSETPOS\") || this.check_set_position(1)) {\n                            data_valid = 1;\n                        }\n                    } else {\n                        data_valid = 0;\n                    }\n                }\n            } else if (this.has_by_data(\"BYMONTHDAY\")) {\n                this.by_indices.BYMONTHDAY++;\n                if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {\n                    this.by_indices.BYMONTHDAY = 0;\n                    this.increment_month();\n                }\n                var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n                var day = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY];\n                if (day < 0) {\n                    day = daysInMonth + day + 1;\n                }\n                if (day > daysInMonth) {\n                    this.last.day = 1;\n                    data_valid = this.is_day_in_byday(this.last);\n                } else {\n                    this.last.day = day;\n                }\n            } else {\n                this.increment_month();\n                var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n                if (this.by_data.BYMONTHDAY[0] > daysInMonth) {\n                    data_valid = 0;\n                } else {\n                    this.last.day = this.by_data.BYMONTHDAY[0];\n                }\n            }\n            return data_valid;\n        },\n        next_weekday_by_week: function next_weekday_by_week() {\n            var end_of_data = 0;\n            if (this.next_hour() == 0) {\n                return end_of_data;\n            }\n            if (!this.has_by_data(\"BYDAY\")) {\n                return 1;\n            }\n            for(;;){\n                var tt = new ICAL.Time();\n                this.by_indices.BYDAY++;\n                if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) {\n                    this.by_indices.BYDAY = 0;\n                    end_of_data = 1;\n                }\n                var coded_day = this.by_data.BYDAY[this.by_indices.BYDAY];\n                var parts = this.ruleDayOfWeek(coded_day);\n                var dow = parts[1];\n                dow -= this.rule.wkst;\n                if (dow < 0) {\n                    dow += 7;\n                }\n                tt.year = this.last.year;\n                tt.month = this.last.month;\n                tt.day = this.last.day;\n                var startOfWeek = tt.startDoyWeek(this.rule.wkst);\n                if (dow + startOfWeek < 1) {\n                    // The selected date is in the previous year\n                    if (!end_of_data) {\n                        continue;\n                    }\n                }\n                var next = ICAL.Time.fromDayOfYear(startOfWeek + dow, this.last.year);\n                /**\n         * The normalization horrors below are due to\n         * the fact that when the year/month/day changes\n         * it can effect the other operations that come after.\n         */ this.last.year = next.year;\n                this.last.month = next.month;\n                this.last.day = next.day;\n                return end_of_data;\n            }\n        },\n        next_year: function next_year() {\n            if (this.next_hour() == 0) {\n                return 0;\n            }\n            if (++this.days_index == this.days.length) {\n                this.days_index = 0;\n                do {\n                    this.increment_year(this.rule.interval);\n                    this.expand_year_days(this.last.year);\n                }while (this.days.length == 0);\n            }\n            this._nextByYearDay();\n            return 1;\n        },\n        _nextByYearDay: function _nextByYearDay() {\n            var doy = this.days[this.days_index];\n            var year = this.last.year;\n            if (doy < 1) {\n                // Time.fromDayOfYear(doy, year) indexes relative to the\n                // start of the given year. That is different from the\n                // semantics of BYYEARDAY where negative indexes are an\n                // offset from the end of the given year.\n                doy += 1;\n                year += 1;\n            }\n            var next = ICAL.Time.fromDayOfYear(doy, year);\n            this.last.day = next.day;\n            this.last.month = next.month;\n        },\n        /**\n     * @param dow (eg: '1TU', '-1MO')\n     * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday\n     * @return [pos, numericDow] (eg: [1, 3]) numericDow is relative to aWeekStart\n     */ ruleDayOfWeek: function ruleDayOfWeek(dow, aWeekStart) {\n            var matches = dow.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/);\n            if (matches) {\n                var pos = parseInt(matches[1] || 0, 10);\n                dow = ICAL.Recur.icalDayToNumericDay(matches[2], aWeekStart);\n                return [\n                    pos,\n                    dow\n                ];\n            } else {\n                return [\n                    0,\n                    0\n                ];\n            }\n        },\n        next_generic: function next_generic(aRuleType, aInterval, aDateAttr, aFollowingAttr, aPreviousIncr) {\n            var has_by_rule = aRuleType in this.by_data;\n            var this_freq = this.rule.freq == aInterval;\n            var end_of_data = 0;\n            if (aPreviousIncr && this[aPreviousIncr]() == 0) {\n                return end_of_data;\n            }\n            if (has_by_rule) {\n                this.by_indices[aRuleType]++;\n                var idx = this.by_indices[aRuleType];\n                var dta = this.by_data[aRuleType];\n                if (this.by_indices[aRuleType] == dta.length) {\n                    this.by_indices[aRuleType] = 0;\n                    end_of_data = 1;\n                }\n                this.last[aDateAttr] = dta[this.by_indices[aRuleType]];\n            } else if (this_freq) {\n                this[\"increment_\" + aDateAttr](this.rule.interval);\n            }\n            if (has_by_rule && end_of_data && this_freq) {\n                this[\"increment_\" + aFollowingAttr](1);\n            }\n            return end_of_data;\n        },\n        increment_monthday: function increment_monthday(inc) {\n            for(var i = 0; i < inc; i++){\n                var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n                this.last.day++;\n                if (this.last.day > daysInMonth) {\n                    this.last.day -= daysInMonth;\n                    this.increment_month();\n                }\n            }\n        },\n        increment_month: function increment_month() {\n            this.last.day = 1;\n            if (this.has_by_data(\"BYMONTH\")) {\n                this.by_indices.BYMONTH++;\n                if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) {\n                    this.by_indices.BYMONTH = 0;\n                    this.increment_year(1);\n                }\n                this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH];\n            } else {\n                if (this.rule.freq == \"MONTHLY\") {\n                    this.last.month += this.rule.interval;\n                } else {\n                    this.last.month++;\n                }\n                this.last.month--;\n                var years = ICAL.helpers.trunc(this.last.month / 12);\n                this.last.month %= 12;\n                this.last.month++;\n                if (years != 0) {\n                    this.increment_year(years);\n                }\n            }\n        },\n        increment_year: function increment_year(inc) {\n            this.last.year += inc;\n        },\n        increment_generic: function increment_generic(inc, aDateAttr, aFactor, aNextIncrement) {\n            this.last[aDateAttr] += inc;\n            var nextunit = ICAL.helpers.trunc(this.last[aDateAttr] / aFactor);\n            this.last[aDateAttr] %= aFactor;\n            if (nextunit != 0) {\n                this[\"increment_\" + aNextIncrement](nextunit);\n            }\n        },\n        has_by_data: function has_by_data(aRuleType) {\n            return aRuleType in this.rule.parts;\n        },\n        expand_year_days: function expand_year_days(aYear) {\n            var t = new ICAL.Time();\n            this.days = [];\n            // We need our own copy with a few keys set\n            var parts = {};\n            var rules = [\n                \"BYDAY\",\n                \"BYWEEKNO\",\n                \"BYMONTHDAY\",\n                \"BYMONTH\",\n                \"BYYEARDAY\"\n            ];\n            for(var p1 in rules){\n                /* istanbul ignore else */ if (rules.hasOwnProperty(p1)) {\n                    var part = rules[p1];\n                    if (part in this.rule.parts) {\n                        parts[part] = this.rule.parts[part];\n                    }\n                }\n            }\n            if (\"BYMONTH\" in parts && \"BYWEEKNO\" in parts) {\n                var valid = 1;\n                var validWeeks = {};\n                t.year = aYear;\n                t.isDate = true;\n                for(var monthIdx = 0; monthIdx < this.by_data.BYMONTH.length; monthIdx++){\n                    var month = this.by_data.BYMONTH[monthIdx];\n                    t.month = month;\n                    t.day = 1;\n                    var first_week = t.weekNumber(this.rule.wkst);\n                    t.day = ICAL.Time.daysInMonth(month, aYear);\n                    var last_week = t.weekNumber(this.rule.wkst);\n                    for(monthIdx = first_week; monthIdx < last_week; monthIdx++){\n                        validWeeks[monthIdx] = 1;\n                    }\n                }\n                for(var weekIdx = 0; weekIdx < this.by_data.BYWEEKNO.length && valid; weekIdx++){\n                    var weekno = this.by_data.BYWEEKNO[weekIdx];\n                    if (weekno < 52) {\n                        valid &= validWeeks[weekIdx];\n                    } else {\n                        valid = 0;\n                    }\n                }\n                if (valid) {\n                    delete parts.BYMONTH;\n                } else {\n                    delete parts.BYWEEKNO;\n                }\n            }\n            var partCount = Object.keys(parts).length;\n            if (partCount == 0) {\n                var t1 = this.dtstart.clone();\n                t1.year = this.last.year;\n                this.days.push(t1.dayOfYear());\n            } else if (partCount == 1 && \"BYMONTH\" in parts) {\n                for(var monthkey in this.by_data.BYMONTH){\n                    /* istanbul ignore if */ if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n                        continue;\n                    }\n                    var t2 = this.dtstart.clone();\n                    t2.year = aYear;\n                    t2.month = this.by_data.BYMONTH[monthkey];\n                    t2.isDate = true;\n                    this.days.push(t2.dayOfYear());\n                }\n            } else if (partCount == 1 && \"BYMONTHDAY\" in parts) {\n                for(var monthdaykey in this.by_data.BYMONTHDAY){\n                    /* istanbul ignore if */ if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {\n                        continue;\n                    }\n                    var t3 = this.dtstart.clone();\n                    var day_ = this.by_data.BYMONTHDAY[monthdaykey];\n                    if (day_ < 0) {\n                        var daysInMonth = ICAL.Time.daysInMonth(t3.month, aYear);\n                        day_ = day_ + daysInMonth + 1;\n                    }\n                    t3.day = day_;\n                    t3.year = aYear;\n                    t3.isDate = true;\n                    this.days.push(t3.dayOfYear());\n                }\n            } else if (partCount == 2 && \"BYMONTHDAY\" in parts && \"BYMONTH\" in parts) {\n                for(var monthkey in this.by_data.BYMONTH){\n                    /* istanbul ignore if */ if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n                        continue;\n                    }\n                    var month_ = this.by_data.BYMONTH[monthkey];\n                    var daysInMonth = ICAL.Time.daysInMonth(month_, aYear);\n                    for(var monthdaykey in this.by_data.BYMONTHDAY){\n                        /* istanbul ignore if */ if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {\n                            continue;\n                        }\n                        var day_ = this.by_data.BYMONTHDAY[monthdaykey];\n                        if (day_ < 0) {\n                            day_ = day_ + daysInMonth + 1;\n                        }\n                        t.day = day_;\n                        t.month = month_;\n                        t.year = aYear;\n                        t.isDate = true;\n                        this.days.push(t.dayOfYear());\n                    }\n                }\n            } else if (partCount == 1 && \"BYWEEKNO\" in parts) {\n            // TODO unimplemented in libical\n            } else if (partCount == 2 && \"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {\n            // TODO unimplemented in libical\n            } else if (partCount == 1 && \"BYDAY\" in parts) {\n                this.days = this.days.concat(this.expand_by_day(aYear));\n            } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTH\" in parts) {\n                for(var monthkey in this.by_data.BYMONTH){\n                    /* istanbul ignore if */ if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n                        continue;\n                    }\n                    var month = this.by_data.BYMONTH[monthkey];\n                    var daysInMonth = ICAL.Time.daysInMonth(month, aYear);\n                    t.year = aYear;\n                    t.month = this.by_data.BYMONTH[monthkey];\n                    t.day = 1;\n                    t.isDate = true;\n                    var first_dow = t.dayOfWeek();\n                    var doy_offset = t.dayOfYear() - 1;\n                    t.day = daysInMonth;\n                    var last_dow = t.dayOfWeek();\n                    if (this.has_by_data(\"BYSETPOS\")) {\n                        var set_pos_counter = 0;\n                        var by_month_day = [];\n                        for(var day = 1; day <= daysInMonth; day++){\n                            t.day = day;\n                            if (this.is_day_in_byday(t)) {\n                                by_month_day.push(day);\n                            }\n                        }\n                        for(var spIndex = 0; spIndex < by_month_day.length; spIndex++){\n                            if (this.check_set_position(spIndex + 1) || this.check_set_position(spIndex - by_month_day.length)) {\n                                this.days.push(doy_offset + by_month_day[spIndex]);\n                            }\n                        }\n                    } else {\n                        for(var daycodedkey in this.by_data.BYDAY){\n                            /* istanbul ignore if */ if (!this.by_data.BYDAY.hasOwnProperty(daycodedkey)) {\n                                continue;\n                            }\n                            var coded_day = this.by_data.BYDAY[daycodedkey];\n                            var bydayParts = this.ruleDayOfWeek(coded_day);\n                            var pos = bydayParts[0];\n                            var dow = bydayParts[1];\n                            var month_day;\n                            var first_matching_day = (dow + 7 - first_dow) % 7 + 1;\n                            var last_matching_day = daysInMonth - (last_dow + 7 - dow) % 7;\n                            if (pos == 0) {\n                                for(var day = first_matching_day; day <= daysInMonth; day += 7){\n                                    this.days.push(doy_offset + day);\n                                }\n                            } else if (pos > 0) {\n                                month_day = first_matching_day + (pos - 1) * 7;\n                                if (month_day <= daysInMonth) {\n                                    this.days.push(doy_offset + month_day);\n                                }\n                            } else {\n                                month_day = last_matching_day + (pos + 1) * 7;\n                                if (month_day > 0) {\n                                    this.days.push(doy_offset + month_day);\n                                }\n                            }\n                        }\n                    }\n                }\n                // Return dates in order of occurrence (1,2,3,...) instead\n                // of by groups of weekdays (1,8,15,...,2,9,16,...).\n                this.days.sort(function(a, b) {\n                    return a - b;\n                }); // Comparator function allows to sort numbers.\n            } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTHDAY\" in parts) {\n                var expandedDays = this.expand_by_day(aYear);\n                for(var daykey in expandedDays){\n                    /* istanbul ignore if */ if (!expandedDays.hasOwnProperty(daykey)) {\n                        continue;\n                    }\n                    var day = expandedDays[daykey];\n                    var tt = ICAL.Time.fromDayOfYear(day, aYear);\n                    if (this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n                        this.days.push(day);\n                    }\n                }\n            } else if (partCount == 3 && \"BYDAY\" in parts && \"BYMONTHDAY\" in parts && \"BYMONTH\" in parts) {\n                var expandedDays = this.expand_by_day(aYear);\n                for(var daykey in expandedDays){\n                    /* istanbul ignore if */ if (!expandedDays.hasOwnProperty(daykey)) {\n                        continue;\n                    }\n                    var day = expandedDays[daykey];\n                    var tt = ICAL.Time.fromDayOfYear(day, aYear);\n                    if (this.by_data.BYMONTH.indexOf(tt.month) >= 0 && this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n                        this.days.push(day);\n                    }\n                }\n            } else if (partCount == 2 && \"BYDAY\" in parts && \"BYWEEKNO\" in parts) {\n                var expandedDays = this.expand_by_day(aYear);\n                for(var daykey in expandedDays){\n                    /* istanbul ignore if */ if (!expandedDays.hasOwnProperty(daykey)) {\n                        continue;\n                    }\n                    var day = expandedDays[daykey];\n                    var tt = ICAL.Time.fromDayOfYear(day, aYear);\n                    var weekno = tt.weekNumber(this.rule.wkst);\n                    if (this.by_data.BYWEEKNO.indexOf(weekno)) {\n                        this.days.push(day);\n                    }\n                }\n            } else if (partCount == 3 && \"BYDAY\" in parts && \"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {\n            // TODO unimplemted in libical\n            } else if (partCount == 1 && \"BYYEARDAY\" in parts) {\n                this.days = this.days.concat(this.by_data.BYYEARDAY);\n            } else {\n                this.days = [];\n            }\n            return 0;\n        },\n        expand_by_day: function expand_by_day(aYear) {\n            var days_list = [];\n            var tmp = this.last.clone();\n            tmp.year = aYear;\n            tmp.month = 1;\n            tmp.day = 1;\n            tmp.isDate = true;\n            var start_dow = tmp.dayOfWeek();\n            tmp.month = 12;\n            tmp.day = 31;\n            tmp.isDate = true;\n            var end_dow = tmp.dayOfWeek();\n            var end_year_day = tmp.dayOfYear();\n            for(var daykey in this.by_data.BYDAY){\n                /* istanbul ignore if */ if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {\n                    continue;\n                }\n                var day = this.by_data.BYDAY[daykey];\n                var parts = this.ruleDayOfWeek(day);\n                var pos = parts[0];\n                var dow = parts[1];\n                if (pos == 0) {\n                    var tmp_start_doy = (dow + 7 - start_dow) % 7 + 1;\n                    for(var doy = tmp_start_doy; doy <= end_year_day; doy += 7){\n                        days_list.push(doy);\n                    }\n                } else if (pos > 0) {\n                    var first;\n                    if (dow >= start_dow) {\n                        first = dow - start_dow + 1;\n                    } else {\n                        first = dow - start_dow + 8;\n                    }\n                    days_list.push(first + (pos - 1) * 7);\n                } else {\n                    var last;\n                    pos = -pos;\n                    if (dow <= end_dow) {\n                        last = end_year_day - end_dow + dow;\n                    } else {\n                        last = end_year_day - end_dow + dow - 7;\n                    }\n                    days_list.push(last - (pos - 1) * 7);\n                }\n            }\n            return days_list;\n        },\n        is_day_in_byday: function is_day_in_byday(tt) {\n            for(var daykey in this.by_data.BYDAY){\n                /* istanbul ignore if */ if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {\n                    continue;\n                }\n                var day = this.by_data.BYDAY[daykey];\n                var parts = this.ruleDayOfWeek(day);\n                var pos = parts[0];\n                var dow = parts[1];\n                var this_dow = tt.dayOfWeek();\n                if (pos == 0 && dow == this_dow || tt.nthWeekDay(dow, pos) == tt.day) {\n                    return 1;\n                }\n            }\n            return 0;\n        },\n        /**\n     * Checks if given value is in BYSETPOS.\n     *\n     * @private\n     * @param {Numeric} aPos position to check for.\n     * @return {Boolean} false unless BYSETPOS rules exist\n     *                   and the given value is present in rules.\n     */ check_set_position: function check_set_position(aPos) {\n            if (this.has_by_data(\"BYSETPOS\")) {\n                var idx = this.by_data.BYSETPOS.indexOf(aPos);\n                // negative numbers are not false-y\n                return idx !== -1;\n            }\n            return false;\n        },\n        sort_byday_rules: function icalrecur_sort_byday_rules(aRules) {\n            for(var i = 0; i < aRules.length; i++){\n                for(var j = 0; j < i; j++){\n                    var one = this.ruleDayOfWeek(aRules[j], this.rule.wkst)[1];\n                    var two = this.ruleDayOfWeek(aRules[i], this.rule.wkst)[1];\n                    if (one > two) {\n                        var tmp = aRules[i];\n                        aRules[i] = aRules[j];\n                        aRules[j] = tmp;\n                    }\n                }\n            }\n        },\n        check_contract_restriction: function check_contract_restriction(aRuleType, v) {\n            var indexMapValue = icalrecur_iterator._indexMap[aRuleType];\n            var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];\n            var pass = false;\n            if (aRuleType in this.by_data && ruleMapValue == icalrecur_iterator.CONTRACT) {\n                var ruleType = this.by_data[aRuleType];\n                for(var bydatakey in ruleType){\n                    /* istanbul ignore else */ if (ruleType.hasOwnProperty(bydatakey)) {\n                        if (ruleType[bydatakey] == v) {\n                            pass = true;\n                            break;\n                        }\n                    }\n                }\n            } else {\n                // Not a contracting byrule or has no data, test passes\n                pass = true;\n            }\n            return pass;\n        },\n        check_contracting_rules: function check_contracting_rules() {\n            var dow = this.last.dayOfWeek();\n            var weekNo = this.last.weekNumber(this.rule.wkst);\n            var doy = this.last.dayOfYear();\n            return this.check_contract_restriction(\"BYSECOND\", this.last.second) && this.check_contract_restriction(\"BYMINUTE\", this.last.minute) && this.check_contract_restriction(\"BYHOUR\", this.last.hour) && this.check_contract_restriction(\"BYDAY\", ICAL.Recur.numericDayToIcalDay(dow)) && this.check_contract_restriction(\"BYWEEKNO\", weekNo) && this.check_contract_restriction(\"BYMONTHDAY\", this.last.day) && this.check_contract_restriction(\"BYMONTH\", this.last.month) && this.check_contract_restriction(\"BYYEARDAY\", doy);\n        },\n        setup_defaults: function setup_defaults(aRuleType, req, deftime) {\n            var indexMapValue = icalrecur_iterator._indexMap[aRuleType];\n            var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];\n            if (ruleMapValue != icalrecur_iterator.CONTRACT) {\n                if (!(aRuleType in this.by_data)) {\n                    this.by_data[aRuleType] = [\n                        deftime\n                    ];\n                }\n                if (this.rule.freq != req) {\n                    return this.by_data[aRuleType][0];\n                }\n            }\n            return deftime;\n        },\n        /**\n     * Convert iterator into a serialize-able object.  Will preserve current\n     * iteration sequence to ensure the seamless continuation of the recurrence\n     * rule.\n     * @return {Object}\n     */ toJSON: function() {\n            var result = Object.create(null);\n            result.initialized = this.initialized;\n            result.rule = this.rule.toJSON();\n            result.dtstart = this.dtstart.toJSON();\n            result.by_data = this.by_data;\n            result.days = this.days;\n            result.last = this.last.toJSON();\n            result.by_indices = this.by_indices;\n            result.occurrence_number = this.occurrence_number;\n            return result;\n        }\n    };\n    icalrecur_iterator._indexMap = {\n        \"BYSECOND\": 0,\n        \"BYMINUTE\": 1,\n        \"BYHOUR\": 2,\n        \"BYDAY\": 3,\n        \"BYMONTHDAY\": 4,\n        \"BYYEARDAY\": 5,\n        \"BYWEEKNO\": 6,\n        \"BYMONTH\": 7,\n        \"BYSETPOS\": 8\n    };\n    icalrecur_iterator._expandMap = {\n        \"SECONDLY\": [\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1\n        ],\n        \"MINUTELY\": [\n            2,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1\n        ],\n        \"HOURLY\": [\n            2,\n            2,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1\n        ],\n        \"DAILY\": [\n            2,\n            2,\n            2,\n            1,\n            1,\n            1,\n            1,\n            1\n        ],\n        \"WEEKLY\": [\n            2,\n            2,\n            2,\n            2,\n            3,\n            3,\n            1,\n            1\n        ],\n        \"MONTHLY\": [\n            2,\n            2,\n            2,\n            2,\n            2,\n            3,\n            3,\n            1\n        ],\n        \"YEARLY\": [\n            2,\n            2,\n            2,\n            2,\n            2,\n            2,\n            2,\n            2\n        ]\n    };\n    icalrecur_iterator.UNKNOWN = 0;\n    icalrecur_iterator.CONTRACT = 1;\n    icalrecur_iterator.EXPAND = 2;\n    icalrecur_iterator.ILLEGAL = 3;\n    return icalrecur_iterator;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */ /**\n * This symbol is further described later on\n * @ignore\n */ ICAL.RecurExpansion = function() {\n    function formatTime(item) {\n        return ICAL.helpers.formatClassType(item, ICAL.Time);\n    }\n    function compareTime(a, b) {\n        return a.compare(b);\n    }\n    function isRecurringComponent(comp) {\n        return comp.hasProperty(\"rdate\") || comp.hasProperty(\"rrule\") || comp.hasProperty(\"recurrence-id\");\n    }\n    /**\n   * @classdesc\n   * Primary class for expanding recurring rules.  Can take multiple rrules,\n   * rdates, exdate(s) and iterate (in order) over each next occurrence.\n   *\n   * Once initialized this class can also be serialized saved and continue\n   * iteration from the last point.\n   *\n   * NOTE: it is intended that this class is to be used\n   *       with ICAL.Event which handles recurrence exceptions.\n   *\n   * @example\n   * // assuming event is a parsed ical component\n   * var event;\n   *\n   * var expand = new ICAL.RecurExpansion({\n   *   component: event,\n   *   dtstart: event.getFirstPropertyValue('dtstart')\n   * });\n   *\n   * // remember there are infinite rules\n   * // so it is a good idea to limit the scope\n   * // of the iterations then resume later on.\n   *\n   * // next is always an ICAL.Time or null\n   * var next;\n   *\n   * while (someCondition && (next = expand.next())) {\n   *   // do something with next\n   * }\n   *\n   * // save instance for later\n   * var json = JSON.stringify(expand);\n   *\n   * //...\n   *\n   * // NOTE: if the component's properties have\n   * //       changed you will need to rebuild the\n   * //       class and start over. This only works\n   * //       when the component's recurrence info is the same.\n   * var expand = new ICAL.RecurExpansion(JSON.parse(json));\n   *\n   * @description\n   * The options object can be filled with the specified initial values. It can\n   * also contain additional members, as a result of serializing a previous\n   * expansion state, as shown in the example.\n   *\n   * @class\n   * @alias ICAL.RecurExpansion\n   * @param {Object} options\n   *        Recurrence expansion options\n   * @param {ICAL.Time} options.dtstart\n   *        Start time of the event\n   * @param {ICAL.Component=} options.component\n   *        Component for expansion, required if not resuming.\n   */ function RecurExpansion(options) {\n        this.ruleDates = [];\n        this.exDates = [];\n        this.fromData(options);\n    }\n    RecurExpansion.prototype = {\n        /**\n     * True when iteration is fully completed.\n     * @type {Boolean}\n     */ complete: false,\n        /**\n     * Array of rrule iterators.\n     *\n     * @type {ICAL.RecurIterator[]}\n     * @private\n     */ ruleIterators: null,\n        /**\n     * Array of rdate instances.\n     *\n     * @type {ICAL.Time[]}\n     * @private\n     */ ruleDates: null,\n        /**\n     * Array of exdate instances.\n     *\n     * @type {ICAL.Time[]}\n     * @private\n     */ exDates: null,\n        /**\n     * Current position in ruleDates array.\n     * @type {Number}\n     * @private\n     */ ruleDateInc: 0,\n        /**\n     * Current position in exDates array\n     * @type {Number}\n     * @private\n     */ exDateInc: 0,\n        /**\n     * Current negative date.\n     *\n     * @type {ICAL.Time}\n     * @private\n     */ exDate: null,\n        /**\n     * Current additional date.\n     *\n     * @type {ICAL.Time}\n     * @private\n     */ ruleDate: null,\n        /**\n     * Start date of recurring rules.\n     *\n     * @type {ICAL.Time}\n     */ dtstart: null,\n        /**\n     * Last expanded time\n     *\n     * @type {ICAL.Time}\n     */ last: null,\n        /**\n     * Initialize the recurrence expansion from the data object. The options\n     * object may also contain additional members, see the\n     * {@link ICAL.RecurExpansion constructor} for more details.\n     *\n     * @param {Object} options\n     *        Recurrence expansion options\n     * @param {ICAL.Time} options.dtstart\n     *        Start time of the event\n     * @param {ICAL.Component=} options.component\n     *        Component for expansion, required if not resuming.\n     */ fromData: function(options) {\n            var start = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);\n            if (!start) {\n                throw new Error(\".dtstart (ICAL.Time) must be given\");\n            } else {\n                this.dtstart = start;\n            }\n            if (options.component) {\n                this._init(options.component);\n            } else {\n                this.last = formatTime(options.last) || start.clone();\n                if (!options.ruleIterators) {\n                    throw new Error(\".ruleIterators or .component must be given\");\n                }\n                this.ruleIterators = options.ruleIterators.map(function(item) {\n                    return ICAL.helpers.formatClassType(item, ICAL.RecurIterator);\n                });\n                this.ruleDateInc = options.ruleDateInc;\n                this.exDateInc = options.exDateInc;\n                if (options.ruleDates) {\n                    this.ruleDates = options.ruleDates.map(formatTime);\n                    this.ruleDate = this.ruleDates[this.ruleDateInc];\n                }\n                if (options.exDates) {\n                    this.exDates = options.exDates.map(formatTime);\n                    this.exDate = this.exDates[this.exDateInc];\n                }\n                if (typeof options.complete !== \"undefined\") {\n                    this.complete = options.complete;\n                }\n            }\n        },\n        /**\n     * Retrieve the next occurrence in the series.\n     * @return {ICAL.Time}\n     */ next: function() {\n            var iter;\n            var ruleOfDay;\n            var next;\n            var compare;\n            var maxTries = 500;\n            var currentTry = 0;\n            while(true){\n                if (currentTry++ > maxTries) {\n                    throw new Error(\"max tries have occured, rule may be impossible to forfill.\");\n                }\n                next = this.ruleDate;\n                iter = this._nextRecurrenceIter(this.last);\n                // no more matches\n                // because we increment the rule day or rule\n                // _after_ we choose a value this should be\n                // the only spot where we need to worry about the\n                // end of events.\n                if (!next && !iter) {\n                    // there are no more iterators or rdates\n                    this.complete = true;\n                    break;\n                }\n                // no next rule day or recurrence rule is first.\n                if (!next || iter && next.compare(iter.last) > 0) {\n                    // must be cloned, recur will reuse the time element.\n                    next = iter.last.clone();\n                    // move to next so we can continue\n                    iter.next();\n                }\n                // if the ruleDate is still next increment it.\n                if (this.ruleDate === next) {\n                    this._nextRuleDay();\n                }\n                this.last = next;\n                // check the negative rules\n                if (this.exDate) {\n                    compare = this.exDate.compare(this.last);\n                    if (compare < 0) {\n                        this._nextExDay();\n                    }\n                    // if the current rule is excluded skip it.\n                    if (compare === 0) {\n                        this._nextExDay();\n                        continue;\n                    }\n                }\n                //XXX: The spec states that after we resolve the final\n                //     list of dates we execute exdate this seems somewhat counter\n                //     intuitive to what I have seen most servers do so for now\n                //     I exclude based on the original date not the one that may\n                //     have been modified by the exception.\n                return this.last;\n            }\n        },\n        /**\n     * Converts object into a serialize-able format. This format can be passed\n     * back into the expansion to resume iteration.\n     * @return {Object}\n     */ toJSON: function() {\n            function toJSON(item) {\n                return item.toJSON();\n            }\n            var result = Object.create(null);\n            result.ruleIterators = this.ruleIterators.map(toJSON);\n            if (this.ruleDates) {\n                result.ruleDates = this.ruleDates.map(toJSON);\n            }\n            if (this.exDates) {\n                result.exDates = this.exDates.map(toJSON);\n            }\n            result.ruleDateInc = this.ruleDateInc;\n            result.exDateInc = this.exDateInc;\n            result.last = this.last.toJSON();\n            result.dtstart = this.dtstart.toJSON();\n            result.complete = this.complete;\n            return result;\n        },\n        /**\n     * Extract all dates from the properties in the given component. The\n     * properties will be filtered by the property name.\n     *\n     * @private\n     * @param {ICAL.Component} component        The component to search in\n     * @param {String} propertyName             The property name to search for\n     * @return {ICAL.Time[]}                    The extracted dates.\n     */ _extractDates: function(component, propertyName) {\n            function handleProp(prop) {\n                idx = ICAL.helpers.binsearchInsert(result, prop, compareTime);\n                // ordered insert\n                result.splice(idx, 0, prop);\n            }\n            var result = [];\n            var props = component.getAllProperties(propertyName);\n            var len = props.length;\n            var i = 0;\n            var prop;\n            var idx;\n            for(; i < len; i++){\n                props[i].getValues().forEach(handleProp);\n            }\n            return result;\n        },\n        /**\n     * Initialize the recurrence expansion.\n     *\n     * @private\n     * @param {ICAL.Component} component    The component to initialize from.\n     */ _init: function(component) {\n            this.ruleIterators = [];\n            this.last = this.dtstart.clone();\n            // to provide api consistency non-recurring\n            // events can also use the iterator though it will\n            // only return a single time.\n            if (!isRecurringComponent(component)) {\n                this.ruleDate = this.last.clone();\n                this.complete = true;\n                return;\n            }\n            if (component.hasProperty(\"rdate\")) {\n                this.ruleDates = this._extractDates(component, \"rdate\");\n                // special hack for cases where first rdate is prior\n                // to the start date. We only check for the first rdate.\n                // This is mostly for google's crazy recurring date logic\n                // (contacts birthdays).\n                if (this.ruleDates[0] && this.ruleDates[0].compare(this.dtstart) < 0) {\n                    this.ruleDateInc = 0;\n                    this.last = this.ruleDates[0].clone();\n                } else {\n                    this.ruleDateInc = ICAL.helpers.binsearchInsert(this.ruleDates, this.last, compareTime);\n                }\n                this.ruleDate = this.ruleDates[this.ruleDateInc];\n            }\n            if (component.hasProperty(\"rrule\")) {\n                var rules = component.getAllProperties(\"rrule\");\n                var i = 0;\n                var len = rules.length;\n                var rule;\n                var iter;\n                for(; i < len; i++){\n                    rule = rules[i].getFirstValue();\n                    iter = rule.iterator(this.dtstart);\n                    this.ruleIterators.push(iter);\n                    // increment to the next occurrence so future\n                    // calls to next return times beyond the initial iteration.\n                    // XXX: I find this suspicious might be a bug?\n                    iter.next();\n                }\n            }\n            if (component.hasProperty(\"exdate\")) {\n                this.exDates = this._extractDates(component, \"exdate\");\n                // if we have a .last day we increment the index to beyond it.\n                this.exDateInc = ICAL.helpers.binsearchInsert(this.exDates, this.last, compareTime);\n                this.exDate = this.exDates[this.exDateInc];\n            }\n        },\n        /**\n     * Advance to the next exdate\n     * @private\n     */ _nextExDay: function() {\n            this.exDate = this.exDates[++this.exDateInc];\n        },\n        /**\n     * Advance to the next rule date\n     * @private\n     */ _nextRuleDay: function() {\n            this.ruleDate = this.ruleDates[++this.ruleDateInc];\n        },\n        /**\n     * Find and return the recurrence rule with the most recent event and\n     * return it.\n     *\n     * @private\n     * @return {?ICAL.RecurIterator}    Found iterator.\n     */ _nextRecurrenceIter: function() {\n            var iters = this.ruleIterators;\n            if (iters.length === 0) {\n                return null;\n            }\n            var len = iters.length;\n            var iter;\n            var iterTime;\n            var iterIdx = 0;\n            var chosenIter;\n            // loop through each iterator\n            for(; iterIdx < len; iterIdx++){\n                iter = iters[iterIdx];\n                iterTime = iter.last;\n                // if iteration is complete\n                // then we must exclude it from\n                // the search and remove it.\n                if (iter.completed) {\n                    len--;\n                    if (iterIdx !== 0) {\n                        iterIdx--;\n                    }\n                    iters.splice(iterIdx, 1);\n                    continue;\n                }\n                // find the most recent possible choice\n                if (!chosenIter || chosenIter.last.compare(iterTime) > 0) {\n                    // that iterator is saved\n                    chosenIter = iter;\n                }\n            }\n            // the chosen iterator is returned but not mutated\n            // this iterator contains the most recent event.\n            return chosenIter;\n        }\n    };\n    return RecurExpansion;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */ /**\n * This symbol is further described later on\n * @ignore\n */ ICAL.Event = function() {\n    /**\n   * @classdesc\n   * ICAL.js is organized into multiple layers. The bottom layer is a raw jCal\n   * object, followed by the component/property layer. The highest level is the\n   * event representation, which this class is part of. See the\n   * {@tutorial layers} guide for more details.\n   *\n   * @class\n   * @alias ICAL.Event\n   * @param {ICAL.Component=} component         The ICAL.Component to base this event on\n   * @param {Object} options                    Options for this event\n   * @param {Boolean} options.strictExceptions\n   *          When true, will verify exceptions are related by their UUID\n   * @param {Array<ICAL.Component|ICAL.Event>} options.exceptions\n   *          Exceptions to this event, either as components or events. If not\n   *            specified exceptions will automatically be set in relation of\n   *            component's parent\n   */ function Event(component, options) {\n        if (!(component instanceof ICAL.Component)) {\n            options = component;\n            component = null;\n        }\n        if (component) {\n            this.component = component;\n        } else {\n            this.component = new ICAL.Component(\"vevent\");\n        }\n        this._rangeExceptionCache = Object.create(null);\n        this.exceptions = Object.create(null);\n        this.rangeExceptions = [];\n        if (options && options.strictExceptions) {\n            this.strictExceptions = options.strictExceptions;\n        }\n        if (options && options.exceptions) {\n            options.exceptions.forEach(this.relateException, this);\n        } else if (this.component.parent && !this.isRecurrenceException()) {\n            this.component.parent.getAllSubcomponents(\"vevent\").forEach(function(event) {\n                if (event.hasProperty(\"recurrence-id\")) {\n                    this.relateException(event);\n                }\n            }, this);\n        }\n    }\n    Event.prototype = {\n        THISANDFUTURE: \"THISANDFUTURE\",\n        /**\n     * List of related event exceptions.\n     *\n     * @type {ICAL.Event[]}\n     */ exceptions: null,\n        /**\n     * When true, will verify exceptions are related by their UUID.\n     *\n     * @type {Boolean}\n     */ strictExceptions: false,\n        /**\n     * Relates a given event exception to this object.  If the given component\n     * does not share the UID of this event it cannot be related and will throw\n     * an exception.\n     *\n     * If this component is an exception it cannot have other exceptions\n     * related to it.\n     *\n     * @param {ICAL.Component|ICAL.Event} obj       Component or event\n     */ relateException: function(obj) {\n            if (this.isRecurrenceException()) {\n                throw new Error(\"cannot relate exception to exceptions\");\n            }\n            if (obj instanceof ICAL.Component) {\n                obj = new ICAL.Event(obj);\n            }\n            if (this.strictExceptions && obj.uid !== this.uid) {\n                throw new Error(\"attempted to relate unrelated exception\");\n            }\n            var id = obj.recurrenceId.toString();\n            // we don't sort or manage exceptions directly\n            // here the recurrence expander handles that.\n            this.exceptions[id] = obj;\n            // index RANGE=THISANDFUTURE exceptions so we can\n            // look them up later in getOccurrenceDetails.\n            if (obj.modifiesFuture()) {\n                var item = [\n                    obj.recurrenceId.toUnixTime(),\n                    id\n                ];\n                // we keep them sorted so we can find the nearest\n                // value later on...\n                var idx = ICAL.helpers.binsearchInsert(this.rangeExceptions, item, compareRangeException);\n                this.rangeExceptions.splice(idx, 0, item);\n            }\n        },\n        /**\n     * Checks if this record is an exception and has the RANGE=THISANDFUTURE\n     * value.\n     *\n     * @return {Boolean}        True, when exception is within range\n     */ modifiesFuture: function() {\n            if (!this.component.hasProperty(\"recurrence-id\")) {\n                return false;\n            }\n            var range = this.component.getFirstProperty(\"recurrence-id\").getParameter(\"range\");\n            return range === this.THISANDFUTURE;\n        },\n        /**\n     * Finds the range exception nearest to the given date.\n     *\n     * @param {ICAL.Time} time usually an occurrence time of an event\n     * @return {?ICAL.Event} the related event/exception or null\n     */ findRangeException: function(time) {\n            if (!this.rangeExceptions.length) {\n                return null;\n            }\n            var utc = time.toUnixTime();\n            var idx = ICAL.helpers.binsearchInsert(this.rangeExceptions, [\n                utc\n            ], compareRangeException);\n            idx -= 1;\n            // occurs before\n            if (idx < 0) {\n                return null;\n            }\n            var rangeItem = this.rangeExceptions[idx];\n            /* istanbul ignore next: sanity check only */ if (utc < rangeItem[0]) {\n                return null;\n            }\n            return rangeItem[1];\n        },\n        /**\n     * This object is returned by {@link ICAL.Event#getOccurrenceDetails getOccurrenceDetails}\n     *\n     * @typedef {Object} occurrenceDetails\n     * @memberof ICAL.Event\n     * @property {ICAL.Time} recurrenceId       The passed in recurrence id\n     * @property {ICAL.Event} item              The occurrence\n     * @property {ICAL.Time} startDate          The start of the occurrence\n     * @property {ICAL.Time} endDate            The end of the occurrence\n     */ /**\n     * Returns the occurrence details based on its start time.  If the\n     * occurrence has an exception will return the details for that exception.\n     *\n     * NOTE: this method is intend to be used in conjunction\n     *       with the {@link ICAL.Event#iterator iterator} method.\n     *\n     * @param {ICAL.Time} occurrence time occurrence\n     * @return {ICAL.Event.occurrenceDetails} Information about the occurrence\n     */ getOccurrenceDetails: function(occurrence) {\n            var id = occurrence.toString();\n            var utcId = occurrence.convertToZone(ICAL.Timezone.utcTimezone).toString();\n            var item;\n            var result = {\n                //XXX: Clone?\n                recurrenceId: occurrence\n            };\n            if (id in this.exceptions) {\n                item = result.item = this.exceptions[id];\n                result.startDate = item.startDate;\n                result.endDate = item.endDate;\n                result.item = item;\n            } else if (utcId in this.exceptions) {\n                item = this.exceptions[utcId];\n                result.startDate = item.startDate;\n                result.endDate = item.endDate;\n                result.item = item;\n            } else {\n                // range exceptions (RANGE=THISANDFUTURE) have a\n                // lower priority then direct exceptions but\n                // must be accounted for first. Their item is\n                // always the first exception with the range prop.\n                var rangeExceptionId = this.findRangeException(occurrence);\n                var end;\n                if (rangeExceptionId) {\n                    var exception = this.exceptions[rangeExceptionId];\n                    // range exception must modify standard time\n                    // by the difference (if any) in start/end times.\n                    result.item = exception;\n                    var startDiff = this._rangeExceptionCache[rangeExceptionId];\n                    if (!startDiff) {\n                        var original = exception.recurrenceId.clone();\n                        var newStart = exception.startDate.clone();\n                        // zones must be same otherwise subtract may be incorrect.\n                        original.zone = newStart.zone;\n                        startDiff = newStart.subtractDate(original);\n                        this._rangeExceptionCache[rangeExceptionId] = startDiff;\n                    }\n                    var start = occurrence.clone();\n                    start.zone = exception.startDate.zone;\n                    start.addDuration(startDiff);\n                    end = start.clone();\n                    end.addDuration(exception.duration);\n                    result.startDate = start;\n                    result.endDate = end;\n                } else {\n                    // no range exception standard expansion\n                    end = occurrence.clone();\n                    end.addDuration(this.duration);\n                    result.endDate = end;\n                    result.startDate = occurrence;\n                    result.item = this;\n                }\n            }\n            return result;\n        },\n        /**\n     * Builds a recur expansion instance for a specific point in time (defaults\n     * to startDate).\n     *\n     * @param {ICAL.Time} startTime     Starting point for expansion\n     * @return {ICAL.RecurExpansion}    Expansion object\n     */ iterator: function(startTime) {\n            return new ICAL.RecurExpansion({\n                component: this.component,\n                dtstart: startTime || this.startDate\n            });\n        },\n        /**\n     * Checks if the event is recurring\n     *\n     * @return {Boolean}        True, if event is recurring\n     */ isRecurring: function() {\n            var comp = this.component;\n            return comp.hasProperty(\"rrule\") || comp.hasProperty(\"rdate\");\n        },\n        /**\n     * Checks if the event describes a recurrence exception. See\n     * {@tutorial terminology} for details.\n     *\n     * @return {Boolean}    True, if the event describes a recurrence exception\n     */ isRecurrenceException: function() {\n            return this.component.hasProperty(\"recurrence-id\");\n        },\n        /**\n     * Returns the types of recurrences this event may have.\n     *\n     * Returned as an object with the following possible keys:\n     *\n     *    - YEARLY\n     *    - MONTHLY\n     *    - WEEKLY\n     *    - DAILY\n     *    - MINUTELY\n     *    - SECONDLY\n     *\n     * @return {Object.<ICAL.Recur.frequencyValues, Boolean>}\n     *          Object of recurrence flags\n     */ getRecurrenceTypes: function() {\n            var rules = this.component.getAllProperties(\"rrule\");\n            var i = 0;\n            var len = rules.length;\n            var result = Object.create(null);\n            for(; i < len; i++){\n                var value1 = rules[i].getFirstValue();\n                result[value1.freq] = true;\n            }\n            return result;\n        },\n        /**\n     * The uid of this event\n     * @type {String}\n     */ get uid () {\n            return this._firstProp(\"uid\");\n        },\n        set uid (value){\n            this._setProp(\"uid\", value);\n        },\n        /**\n     * The start date\n     * @type {ICAL.Time}\n     */ get startDate () {\n            return this._firstProp(\"dtstart\");\n        },\n        set startDate (value){\n            this._setTime(\"dtstart\", value);\n        },\n        /**\n     * The end date. This can be the result directly from the property, or the\n     * end date calculated from start date and duration. Setting the property\n     * will remove any duration properties.\n     * @type {ICAL.Time}\n     */ get endDate () {\n            var endDate = this._firstProp(\"dtend\");\n            if (!endDate) {\n                var duration = this._firstProp(\"duration\");\n                endDate = this.startDate.clone();\n                if (duration) {\n                    endDate.addDuration(duration);\n                } else if (endDate.isDate) {\n                    endDate.day += 1;\n                }\n            }\n            return endDate;\n        },\n        set endDate (value){\n            if (this.component.hasProperty(\"duration\")) {\n                this.component.removeProperty(\"duration\");\n            }\n            this._setTime(\"dtend\", value);\n        },\n        /**\n     * The duration. This can be the result directly from the property, or the\n     * duration calculated from start date and end date. Setting the property\n     * will remove any `dtend` properties.\n     * @type {ICAL.Duration}\n     */ get duration () {\n            var duration1 = this._firstProp(\"duration\");\n            if (!duration1) {\n                return this.endDate.subtractDateTz(this.startDate);\n            }\n            return duration1;\n        },\n        set duration (value){\n            if (this.component.hasProperty(\"dtend\")) {\n                this.component.removeProperty(\"dtend\");\n            }\n            this._setProp(\"duration\", value);\n        },\n        /**\n     * The location of the event.\n     * @type {String}\n     */ get location () {\n            return this._firstProp(\"location\");\n        },\n        set location (value){\n            return this._setProp(\"location\", value);\n        },\n        /**\n     * The attendees in the event\n     * @type {ICAL.Property[]}\n     * @readonly\n     */ get attendees () {\n            //XXX: This is way lame we should have a better\n            //     data structure for this later.\n            return this.component.getAllProperties(\"attendee\");\n        },\n        /**\n     * The event summary\n     * @type {String}\n     */ get summary () {\n            return this._firstProp(\"summary\");\n        },\n        set summary (value){\n            this._setProp(\"summary\", value);\n        },\n        /**\n     * The event description.\n     * @type {String}\n     */ get description () {\n            return this._firstProp(\"description\");\n        },\n        set description (value){\n            this._setProp(\"description\", value);\n        },\n        /**\n     * The event color from [rfc7986](https://datatracker.ietf.org/doc/html/rfc7986)\n     * @type {String}\n     */ get color () {\n            return this._firstProp(\"color\");\n        },\n        set color (value){\n            this._setProp(\"color\", value);\n        },\n        /**\n     * The organizer value as an uri. In most cases this is a mailto: uri, but\n     * it can also be something else, like urn:uuid:...\n     * @type {String}\n     */ get organizer () {\n            return this._firstProp(\"organizer\");\n        },\n        set organizer (value){\n            this._setProp(\"organizer\", value);\n        },\n        /**\n     * The sequence value for this event. Used for scheduling\n     * see {@tutorial terminology}.\n     * @type {Number}\n     */ get sequence () {\n            return this._firstProp(\"sequence\");\n        },\n        set sequence (value){\n            this._setProp(\"sequence\", value);\n        },\n        /**\n     * The recurrence id for this event. See {@tutorial terminology} for details.\n     * @type {ICAL.Time}\n     */ get recurrenceId () {\n            return this._firstProp(\"recurrence-id\");\n        },\n        set recurrenceId (value){\n            this._setTime(\"recurrence-id\", value);\n        },\n        /**\n     * Set/update a time property's value.\n     * This will also update the TZID of the property.\n     *\n     * TODO: this method handles the case where we are switching\n     * from a known timezone to an implied timezone (one without TZID).\n     * This does _not_ handle the case of moving between a known\n     *  (by TimezoneService) timezone to an unknown timezone...\n     *\n     * We will not add/remove/update the VTIMEZONE subcomponents\n     *  leading to invalid ICAL data...\n     * @private\n     * @param {String} propName     The property name\n     * @param {ICAL.Time} time      The time to set\n     */ _setTime: function(propName, time) {\n            var prop = this.component.getFirstProperty(propName);\n            if (!prop) {\n                prop = new ICAL.Property(propName);\n                this.component.addProperty(prop);\n            }\n            // utc and local don't get a tzid\n            if (time.zone === ICAL.Timezone.localTimezone || time.zone === ICAL.Timezone.utcTimezone) {\n                // remove the tzid\n                prop.removeParameter(\"tzid\");\n            } else {\n                prop.setParameter(\"tzid\", time.zone.tzid);\n            }\n            prop.setValue(time);\n        },\n        _setProp: function(name, value1) {\n            this.component.updatePropertyWithValue(name, value1);\n        },\n        _firstProp: function(name) {\n            return this.component.getFirstPropertyValue(name);\n        },\n        /**\n     * The string representation of this event.\n     * @return {String}\n     */ toString: function() {\n            return this.component.toString();\n        }\n    };\n    function compareRangeException(a, b) {\n        if (a[0] > b[0]) return 1;\n        if (b[0] > a[0]) return -1;\n        return 0;\n    }\n    return Event;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */ /**\n * This symbol is further described later on\n * @ignore\n */ ICAL.ComponentParser = function() {\n    /**\n   * @classdesc\n   * The ComponentParser is used to process a String or jCal Object,\n   * firing callbacks for various found components, as well as completion.\n   *\n   * @example\n   * var options = {\n   *   // when false no events will be emitted for type\n   *   parseEvent: true,\n   *   parseTimezone: true\n   * };\n   *\n   * var parser = new ICAL.ComponentParser(options);\n   *\n   * parser.onevent(eventComponent) {\n   *   //...\n   * }\n   *\n   * // ontimezone, etc...\n   *\n   * parser.oncomplete = function() {\n   *\n   * };\n   *\n   * parser.process(stringOrComponent);\n   *\n   * @class\n   * @alias ICAL.ComponentParser\n   * @param {Object=} options        Component parser options\n   * @param {Boolean} options.parseEvent        Whether events should be parsed\n   * @param {Boolean} options.parseTimezeone    Whether timezones should be parsed\n   */ function ComponentParser(options) {\n        if (typeof options === \"undefined\") {\n            options = {};\n        }\n        var key;\n        for(key in options){\n            /* istanbul ignore else */ if (options.hasOwnProperty(key)) {\n                this[key] = options[key];\n            }\n        }\n    }\n    ComponentParser.prototype = {\n        /**\n     * When true, parse events\n     *\n     * @type {Boolean}\n     */ parseEvent: true,\n        /**\n     * When true, parse timezones\n     *\n     * @type {Boolean}\n     */ parseTimezone: true,\n        /* SAX like events here for reference */ /**\n     * Fired when parsing is complete\n     * @callback\n     */ oncomplete: /* istanbul ignore next */ function() {},\n        /**\n     * Fired if an error occurs during parsing.\n     *\n     * @callback\n     * @param {Error} err details of error\n     */ onerror: /* istanbul ignore next */ function(err) {},\n        /**\n     * Fired when a top level component (VTIMEZONE) is found\n     *\n     * @callback\n     * @param {ICAL.Timezone} component     Timezone object\n     */ ontimezone: /* istanbul ignore next */ function(component) {},\n        /**\n     * Fired when a top level component (VEVENT) is found.\n     *\n     * @callback\n     * @param {ICAL.Event} component    Top level component\n     */ onevent: /* istanbul ignore next */ function(component) {},\n        /**\n     * Process a string or parse ical object.  This function itself will return\n     * nothing but will start the parsing process.\n     *\n     * Events must be registered prior to calling this method.\n     *\n     * @param {ICAL.Component|String|Object} ical      The component to process,\n     *        either in its final form, as a jCal Object, or string representation\n     */ process: function(ical) {\n            //TODO: this is sync now in the future we will have a incremental parser.\n            if (typeof ical === \"string\") {\n                ical = ICAL.parse(ical);\n            }\n            if (!(ical instanceof ICAL.Component)) {\n                ical = new ICAL.Component(ical);\n            }\n            var components = ical.getAllSubcomponents();\n            var i = 0;\n            var len = components.length;\n            var component;\n            for(; i < len; i++){\n                component = components[i];\n                switch(component.name){\n                    case \"vtimezone\":\n                        if (this.parseTimezone) {\n                            var tzid = component.getFirstPropertyValue(\"tzid\");\n                            if (tzid) {\n                                this.ontimezone(new ICAL.Timezone({\n                                    tzid: tzid,\n                                    component: component\n                                }));\n                            }\n                        }\n                        break;\n                    case \"vevent\":\n                        if (this.parseEvent) {\n                            this.onevent(new ICAL.Event(component));\n                        }\n                        break;\n                    default:\n                        continue;\n                }\n            }\n            //XXX: ideally we should do a \"nextTick\" here\n            //     so in all cases this is actually async.\n            this.oncomplete();\n        }\n    };\n    return ComponentParser;\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaWNhbC5qcy9idWlsZC9pY2FsLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Z0RBR2dELEdBRWhELHVCQUF1QixHQUN2QixJQUFJQTtBQUNIO0lBQ0Msd0JBQXdCLEdBQ3hCLElBQUksSUFBa0IsRUFBVTtRQUM5QixzREFBc0Q7UUFDdERBLE9BQU9DLE9BQU9DLE9BQU87SUFDdkIsT0FBTyxFQUtOO0FBQ0g7QUFDQSxxQkFBcUIsR0FDckI7OztxREFHcUQsR0FFckQ7Ozs7Q0FJQyxHQUNERixLQUFLTSxVQUFVLEdBQUc7QUFHbEI7Ozs7O0NBS0MsR0FDRE4sS0FBS08sV0FBVyxHQUFHO0FBR25COzs7Q0FHQyxHQUNEUCxLQUFLUSxPQUFPLEdBQUc7SUFDYjs7Ozs7Ozs7R0FRQyxHQUNEQyxpQkFBaUIsU0FBU0MsSUFBSTtRQUM1QixJQUFJQyxTQUFTQyxZQUFZQyxZQUFZQyxTQUFTQyxHQUFHQztRQUVqRCxJQUFJLENBQUNOLFFBQVFBLEtBQUtPLElBQUksS0FBSyxhQUFhO1lBQ3RDLHFDQUFxQztZQUNyQyxPQUFPUDtRQUNUO1FBRUEsK0RBQStEO1FBQy9ELHdEQUF3RDtRQUN4REMsVUFBVUQsS0FBS1EsbUJBQW1CO1FBQ2xDTixhQUFhLEVBQUU7UUFDZkMsYUFBYSxDQUFDO1FBQ2QsSUFBS0UsSUFBSSxHQUFHQSxJQUFJSixRQUFRUSxNQUFNLEVBQUVKLElBQUs7WUFDbkMsSUFBSUosT0FBTyxDQUFDSSxFQUFFLENBQUNFLElBQUksS0FBSyxhQUFhO2dCQUNuQ0QsT0FBT0wsT0FBTyxDQUFDSSxFQUFFLENBQUNLLGdCQUFnQixDQUFDLFFBQVFDLGFBQWE7Z0JBQ3hEUixVQUFVLENBQUNHLEtBQUssR0FBR0wsT0FBTyxDQUFDSSxFQUFFO1lBQy9CLE9BQU87Z0JBQ0xILGFBQWFBLFdBQVdVLE1BQU0sQ0FBQ1gsT0FBTyxDQUFDSSxFQUFFLENBQUNRLGdCQUFnQjtZQUM1RDtRQUNGO1FBRUEsc0RBQXNEO1FBQ3REVCxVQUFVLENB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QUFJLENBQUNpN0IsVUFBVSxFQUFFOzRCQUNuQixJQUFJLENBQUNLLE9BQU8sQ0FBQyxJQUFJcjlCLEtBQUt1NkIsS0FBSyxDQUFDeDRCO3dCQUM5Qjt3QkFDQTtvQkFDRjt3QkFDRTtnQkFDSjtZQUNGO1lBRUEsNkNBQTZDO1lBQzdDLDhDQUE4QztZQUM5QyxJQUFJLENBQUNtN0IsVUFBVTtRQUNqQjtJQUNGO0lBRUEsT0FBT0g7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL3RpY3RhY3RvZS8uL25vZGVfbW9kdWxlcy9pY2FsLmpzL2J1aWxkL2ljYWwuanM/NzE0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMjEgKi9cblxuLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xudmFyIElDQUw7XG4oZnVuY3Rpb24oKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgIC8vIENvbW1vbkpTLCB3aGVyZSBleHBvcnRzIG1heSBiZSBkaWZmZXJlbnQgZWFjaCB0aW1lLlxuICAgIElDQUwgPSBtb2R1bGUuZXhwb3J0cztcbiAgfSBlbHNlIGlmICh0eXBlb2YgSFRNTFNjcmlwdEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmICdub01vZHVsZScgaW4gSFRNTFNjcmlwdEVsZW1lbnQucHJvdG90eXBlKSB7XG4gICAgLy8gVW50aWwgd2UgdXNlIEVTNiBleHBvcnRzLCB1c2luZyA8c2NyaXB0IHR5cGU9XCJtb2R1bGVcIj4gd2UgZGVmaW5lIElDQUwgb24gdGhlIHdpbmRvdyBnbG9iYWwuXG4gICAgd2luZG93LklDQUwgPSBJQ0FMID0ge307XG4gIH0gZWxzZSBpZiAodHlwZW9mIElDQUwgIT09ICdvYmplY3QnKSB7XG4gICAgSUNBTCA9IHt9O1xuICB9XG59KSgpO1xuLyoganNoaW50IGlnbm9yZTplbmQgKi9cbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cbi8qKlxuICogVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGJlZm9yZSBpQ2FsZW5kYXIgbGluZSBmb2xkaW5nIHNob3VsZCBvY2N1clxuICogQHR5cGUge051bWJlcn1cbiAqIEBkZWZhdWx0IDc1XG4gKi9cbklDQUwuZm9sZExlbmd0aCA9IDc1O1xuXG5cbi8qKlxuICogVGhlIGNoYXJhY3RlcihzKSB0byBiZSB1c2VkIGZvciBhIG5ld2xpbmUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHByb3ZpZGVkIGJ5XG4gKiByZmM1NTQ1LlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0IFwiXFxyXFxuXCJcbiAqL1xuSUNBTC5uZXdMaW5lQ2hhciA9ICdcXHJcXG4nO1xuXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9ucyB1c2VkIGluIHZhcmlvdXMgcGxhY2VzIHdpdGhpbiBpY2FsLmpzXG4gKiBAbmFtZXNwYWNlXG4gKi9cbklDQUwuaGVscGVycyA9IHtcbiAgLyoqXG4gICAqIENvbXBpbGVzIGEgbGlzdCBvZiBhbGwgcmVmZXJlbmNlZCBUWklEcyBpbiBhbGwgc3ViY29tcG9uZW50cyBhbmRcbiAgICogcmVtb3ZlcyBhbnkgZXh0cmEgVlRJTUVaT05FIHN1YmNvbXBvbmVudHMuIEluIGFkZGl0aW9uLCBpZiBhbnkgVFpJRHNcbiAgICogYXJlIHJlZmVyZW5jZWQgYnkgYSBjb21wb25lbnQsIGJ1dCBhIFZUSU1FWk9ORSBkb2VzIG5vdCBleGlzdCxcbiAgICogYW4gYXR0ZW1wdCB3aWxsIGJlIG1hZGUgdG8gZ2VuZXJhdGUgYSBWVElNRVpPTkUgdXNpbmcgSUNBTC5UaW1lem9uZVNlcnZpY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnR9IHZjYWwgICAgIFRoZSB0b3AtbGV2ZWwgVkNBTEVOREFSIGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7SUNBTC5Db21wb25lbnR9ICAgICAgICAgVGhlIElDQUwuQ29tcG9uZW50IHRoYXQgd2FzIHBhc3NlZCBpbi5cbiAgICovXG4gIHVwZGF0ZVRpbWV6b25lczogZnVuY3Rpb24odmNhbCkge1xuICAgIHZhciBhbGxzdWJzLCBwcm9wZXJ0aWVzLCB2dGltZXpvbmVzLCByZXFUemlkLCBpLCB0emlkO1xuXG4gICAgaWYgKCF2Y2FsIHx8IHZjYWwubmFtZSAhPT0gXCJ2Y2FsZW5kYXJcIikge1xuICAgICAgLy9ub3QgYSB0b3AtbGV2ZWwgdmNhbGVuZGFyIGNvbXBvbmVudFxuICAgICAgcmV0dXJuIHZjYWw7XG4gICAgfVxuXG4gICAgLy9TdG9yZSB2dGltZXpvbmUgc3ViY29tcG9uZW50cyBpbiBhbiBvYmplY3QgcmVmZXJlbmNlIGJ5IHR6aWQuXG4gICAgLy9TdG9yZSBwcm9wZXJ0aWVzIGZyb20gZXZlcnl0aGluZyBlbHNlIGluIGFub3RoZXIgYXJyYXlcbiAgICBhbGxzdWJzID0gdmNhbC5nZXRBbGxTdWJjb21wb25lbnRzKCk7XG4gICAgcHJvcGVydGllcyA9IFtdO1xuICAgIHZ0aW1lem9uZXMgPSB7fTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYWxsc3Vicy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFsbHN1YnNbaV0ubmFtZSA9PT0gXCJ2dGltZXpvbmVcIikge1xuICAgICAgICB0emlkID0gYWxsc3Vic1tpXS5nZXRGaXJzdFByb3BlcnR5KFwidHppZFwiKS5nZXRGaXJzdFZhbHVlKCk7XG4gICAgICAgIHZ0aW1lem9uZXNbdHppZF0gPSBhbGxzdWJzW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMuY29uY2F0KGFsbHN1YnNbaV0uZ2V0QWxsUHJvcGVydGllcygpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL2NyZWF0ZSBhbiBvYmplY3Qgd2l0aCBvbmUgZW50cnkgZm9yIGVhY2ggcmVxdWlyZWQgdHpcbiAgICByZXFUemlkID0ge307XG4gICAgZm9yIChpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICgodHppZCA9IHByb3BlcnRpZXNbaV0uZ2V0UGFyYW1ldGVyKFwidHppZFwiKSkpIHtcbiAgICAgICAgcmVxVHppZFt0emlkXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9kZWxldGUgYW55IHZ0aW1lem9uZXMgdGhhdCBhcmUgbm90IG9uIHRoZSByZXFUemlkIGxpc3QuXG4gICAgZm9yIChpIGluIHZ0aW1lem9uZXMpIHtcbiAgICAgIGlmICh2dGltZXpvbmVzLmhhc093blByb3BlcnR5KGkpICYmICFyZXFUemlkW2ldKSB7XG4gICAgICAgIHZjYWwucmVtb3ZlU3ViY29tcG9uZW50KHZ0aW1lem9uZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vY3JlYXRlIGFueSBtaXNzaW5nLCBidXQgcmVnaXN0ZXJlZCB0aW1lem9uZXNcbiAgICBmb3IgKGkgaW4gcmVxVHppZCkge1xuICAgICAgaWYgKFxuICAgICAgICByZXFUemlkLmhhc093blByb3BlcnR5KGkpICYmXG4gICAgICAgICF2dGltZXpvbmVzW2ldICYmXG4gICAgICAgIElDQUwuVGltZXpvbmVTZXJ2aWNlLmhhcyhpKVxuICAgICAgKSB7XG4gICAgICAgIHZjYWwuYWRkU3ViY29tcG9uZW50KElDQUwuVGltZXpvbmVTZXJ2aWNlLmdldChpKS5jb21wb25lbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2Y2FsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIHR5cGUgaXMgb2YgdGhlIG51bWJlciB0eXBlIGFuZCBhbHNvIE5hTi5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciAgICAgVGhlIG51bWJlciB0byBjaGVja1xuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICBUcnVlLCBpZiB0aGUgbnVtYmVyIGlzIHN0cmljdGx5IE5hTlxuICAgKi9cbiAgaXNTdHJpY3RseU5hTjogZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgcmV0dXJuIHR5cGVvZihudW1iZXIpID09PSAnbnVtYmVyJyAmJiBpc05hTihudW1iZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYSBzdHJpbmcgdmFsdWUgdGhhdCBpcyBleHBlY3RlZCB0byBiZSBhbiBpbnRlZ2VyLCB3aGVuIHRoZSB2YWxpZCBpc1xuICAgKiBub3QgYW4gaW50ZWdlciB0aHJvd3MgYSBkZWNvcmF0aW9uIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nICAgICBSYXcgc3RyaW5nIGlucHV0XG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgIFBhcnNlZCBpbnRlZ2VyXG4gICAqL1xuICBzdHJpY3RQYXJzZUludDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KHN0cmluZywgMTApO1xuXG4gICAgaWYgKElDQUwuaGVscGVycy5pc1N0cmljdGx5TmFOKHJlc3VsdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0NvdWxkIG5vdCBleHRyYWN0IGludGVnZXIgZnJvbSBcIicgKyBzdHJpbmcgKyAnXCInXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgb3IgcmV0dXJucyBhIGNsYXNzIGluc3RhbmNlIG9mIGEgZ2l2ZW4gdHlwZSB3aXRoIHRoZSBpbml0aWFsaXphdGlvblxuICAgKiBkYXRhIGlmIHRoZSBkYXRhIGlzIG5vdCBhbHJlYWR5IGFuIGluc3RhbmNlIG9mIHRoZSBnaXZlbiB0eXBlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgdGltZSA9IG5ldyBJQ0FMLlRpbWUoLi4uKTtcbiAgICogdmFyIHJlc3VsdCA9IElDQUwuaGVscGVycy5mb3JtYXRDbGFzc1R5cGUodGltZSwgSUNBTC5UaW1lKTtcbiAgICpcbiAgICogKHJlc3VsdCBpbnN0YW5jZW9mIElDQUwuVGltZSlcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiByZXN1bHQgPSBJQ0FMLmhlbHBlcnMuZm9ybWF0Q2xhc3NUeXBlKHt9LCBJQ0FMLlRpbWUpO1xuICAgKiAocmVzdWx0IGlzbnRhbmNlb2YgSUNBTC5UaW1lKVxuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgIG9iamVjdCBpbml0aWFsaXphdGlvbiBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlICAgICAgIG9iamVjdCB0eXBlIChsaWtlIElDQUwuVGltZSlcbiAgICogQHJldHVybiB7P30gICAgICAgICAgICAgICAgQW4gaW5zdGFuY2Ugb2YgdGhlIGZvdW5kIHR5cGUuXG4gICAqL1xuICBmb3JtYXRDbGFzc1R5cGU6IGZ1bmN0aW9uIGZvcm1hdENsYXNzVHlwZShkYXRhLCB0eXBlKSB7XG4gICAgaWYgKHR5cGVvZihkYXRhKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiB0eXBlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB0eXBlKGRhdGEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZGVudGljYWwgdG8gaW5kZXhPZiBidXQgd2lsbCBvbmx5IG1hdGNoIHZhbHVlcyB3aGVuIHRoZXkgYXJlIG5vdCBwcmVjZWRlZFxuICAgKiBieSBhIGJhY2tzbGFzaCBjaGFyYWN0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBidWZmZXIgICAgICAgICBTdHJpbmcgdG8gc2VhcmNoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2ggICAgICAgICBWYWx1ZSB0byBsb29rIGZvclxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zICAgICAgICAgICAgU3RhcnQgcG9zaXRpb25cbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgIFRoZSBwb3NpdGlvbiwgb3IgLTEgaWYgbm90IGZvdW5kXG4gICAqL1xuICB1bmVzY2FwZWRJbmRleE9mOiBmdW5jdGlvbihidWZmZXIsIHNlYXJjaCwgcG9zKSB7XG4gICAgd2hpbGUgKChwb3MgPSBidWZmZXIuaW5kZXhPZihzZWFyY2gsIHBvcykpICE9PSAtMSkge1xuICAgICAgaWYgKHBvcyA+IDAgJiYgYnVmZmVyW3BvcyAtIDFdID09PSAnXFxcXCcpIHtcbiAgICAgICAgcG9zICs9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIGluZGV4IGZvciBpbnNlcnRpb24gdXNpbmcgYmluYXJ5IHNlYXJjaC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gbGlzdCAgICAgICAgICAgIFRoZSBsaXN0IHRvIHNlYXJjaFxuICAgKiBAcGFyYW0gez99IHNlZWtWYWwgICAgICAgICAgICAgVGhlIHZhbHVlIHRvIGluc2VydFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD8sPyl9IGNtcGZ1bmMgVGhlIGNvbXBhcmlzb24gZnVuYywgdGhhdCBjYW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyZSB0d28gc2Vla1ZhbHNcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgIFRoZSBpbnNlcnQgcG9zaXRpb25cbiAgICovXG4gIGJpbnNlYXJjaEluc2VydDogZnVuY3Rpb24obGlzdCwgc2Vla1ZhbCwgY21wZnVuYykge1xuICAgIGlmICghbGlzdC5sZW5ndGgpXG4gICAgICByZXR1cm4gMDtcblxuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gbGlzdC5sZW5ndGggLSAxLFxuICAgICAgICBtaWQsIGNtcHZhbDtcblxuICAgIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgICAgbWlkID0gbG93ICsgTWF0aC5mbG9vcigoaGlnaCAtIGxvdykgLyAyKTtcbiAgICAgIGNtcHZhbCA9IGNtcGZ1bmMoc2Vla1ZhbCwgbGlzdFttaWRdKTtcblxuICAgICAgaWYgKGNtcHZhbCA8IDApXG4gICAgICAgIGhpZ2ggPSBtaWQgLSAxO1xuICAgICAgZWxzZSBpZiAoY21wdmFsID4gMClcbiAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgIGVsc2VcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGNtcHZhbCA8IDApXG4gICAgICByZXR1cm4gbWlkOyAvLyBpbnNlcnRpb24gaXMgZGlzcGxhY2luZywgc28gdXNlIG1pZCBvdXRyaWdodC5cbiAgICBlbHNlIGlmIChjbXB2YWwgPiAwKVxuICAgICAgcmV0dXJuIG1pZCArIDE7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIG1pZDtcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGRlYnVnIG91dHB1dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZHVtcG46IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uKCkge1xuICAgIGlmICghSUNBTC5kZWJ1Zykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgKGNvbnNvbGUpICE9PSAndW5kZWZpbmVkJyAmJiAnbG9nJyBpbiBjb25zb2xlKSB7XG4gICAgICBJQ0FMLmhlbHBlcnMuZHVtcG4gPSBmdW5jdGlvbiBjb25zb2xlRHVtcG4oaW5wdXQpIHtcbiAgICAgICAgY29uc29sZS5sb2coaW5wdXQpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgSUNBTC5oZWxwZXJzLmR1bXBuID0gZnVuY3Rpb24gZ2Vja29EdW1wbihpbnB1dCkge1xuICAgICAgICBkdW1wKGlucHV0ICsgJ1xcbicpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBJQ0FMLmhlbHBlcnMuZHVtcG4oYXJndW1lbnRzWzBdKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2xvbmUgdGhlIHBhc3NlZCBvYmplY3Qgb3IgcHJpbWl0aXZlLiBCeSBkZWZhdWx0IGEgc2hhbGxvdyBjbG9uZSB3aWxsIGJlXG4gICAqIGV4ZWN1dGVkLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGFTcmMgICAgICAgICAgICBUaGUgdGhpbmcgdG8gY2xvbmVcbiAgICogQHBhcmFtIHtCb29sZWFuPX0gYURlZXAgICAgSWYgdHJ1ZSwgYSBkZWVwIGNsb25lIHdpbGwgYmUgcGVyZm9ybWVkXG4gICAqIEByZXR1cm4geyp9ICAgICAgICAgICAgICAgIFRoZSBjb3B5IG9mIHRoZSB0aGluZ1xuICAgKi9cbiAgY2xvbmU6IGZ1bmN0aW9uKGFTcmMsIGFEZWVwKSB7XG4gICAgaWYgKCFhU3JjIHx8IHR5cGVvZiBhU3JjICE9IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBhU3JjO1xuICAgIH0gZWxzZSBpZiAoYVNyYyBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShhU3JjLmdldFRpbWUoKSk7XG4gICAgfSBlbHNlIGlmIChcImNsb25lXCIgaW4gYVNyYykge1xuICAgICAgcmV0dXJuIGFTcmMuY2xvbmUoKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYVNyYykpIHtcbiAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYVNyYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnIucHVzaChhRGVlcCA/IElDQUwuaGVscGVycy5jbG9uZShhU3JjW2ldLCB0cnVlKSA6IGFTcmNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBhU3JjKSB7XG4gICAgICAgIC8vIHVzZXMgcHJvdG90eXBlIG1ldGhvZCB0byBhbGxvdyB1c2Ugb2YgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhU3JjLCBuYW1lKSkge1xuICAgICAgICAgIGlmIChhRGVlcCkge1xuICAgICAgICAgICAgb2JqW25hbWVdID0gSUNBTC5oZWxwZXJzLmNsb25lKGFTcmNbbmFtZV0sIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmpbbmFtZV0gPSBhU3JjW25hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGlDYWxlbmRhciBsaW5lIGZvbGRpbmcuIEEgbGluZSBlbmRpbmcgY2hhcmFjdGVyIGlzIGluc2VydGVkIGFuZFxuICAgKiB0aGUgbmV4dCBsaW5lIGJlZ2lucyB3aXRoIGEgd2hpdGVzcGFjZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogU1VNTUFSWTpUaGlzIGxpbmUgd2lsbCBiZSBmb2xkXG4gICAqICBlZCByaWdodCBpbiB0aGUgbWlkZGxlIG9mIGEgd29yZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFMaW5lICAgICAgVGhlIGxpbmUgdG8gZm9sZFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBUaGUgZm9sZGVkIGxpbmVcbiAgICovXG4gIGZvbGRsaW5lOiBmdW5jdGlvbiBmb2xkbGluZShhTGluZSkge1xuICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgIHZhciBsaW5lID0gYUxpbmUgfHwgXCJcIiwgcG9zID0gMCwgbGluZV9sZW5ndGggPSAwO1xuICAgIC8vcG9zIGNvdW50cyBwb3NpdGlvbiBpbiBsaW5lIGZvciB0aGUgVVRGLTE2IHByZXNlbnRhdGlvblxuICAgIC8vbGluZV9sZW5ndGggY291bnRzIHRoZSBieXRlcyBmb3IgdGhlIFVURi04IHByZXNlbnRhdGlvblxuICAgIHdoaWxlIChsaW5lLmxlbmd0aCkge1xuICAgICAgdmFyIGNwID0gbGluZS5jb2RlUG9pbnRBdChwb3MpO1xuICAgICAgaWYgKGNwIDwgMTI4KSArK2xpbmVfbGVuZ3RoO1xuICAgICAgZWxzZSBpZiAoY3AgPCAyMDQ4KSBsaW5lX2xlbmd0aCArPSAyOy8vbmVlZHMgMiBVVEYtOCBieXRlc1xuICAgICAgZWxzZSBpZiAoY3AgPCA2NTUzNikgbGluZV9sZW5ndGggKz0gMztcbiAgICAgIGVsc2UgbGluZV9sZW5ndGggKz0gNDsgLy9jcCBpcyBsZXNzIHRoYW4gMTExNDExMlxuICAgICAgaWYgKGxpbmVfbGVuZ3RoIDwgSUNBTC5mb2xkTGVuZ3RoICsgMSlcbiAgICAgICAgcG9zICs9IGNwID4gNjU1MzUgPyAyIDogMTtcbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gSUNBTC5uZXdMaW5lQ2hhciArIFwiIFwiICsgbGluZS5zdWJzdHJpbmcoMCwgcG9zKTtcbiAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyaW5nKHBvcyk7XG4gICAgICAgIHBvcyA9IGxpbmVfbGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5zdWJzdHIoSUNBTC5uZXdMaW5lQ2hhci5sZW5ndGggKyAxKTtcbiAgfSxcblxuICAvKipcbiAgICogUGFkcyB0aGUgZ2l2ZW4gc3RyaW5nIG9yIG51bWJlciB3aXRoIHplcm9zIHNvIGl0IHdpbGwgaGF2ZSBhdCBsZWFzdCB0d29cbiAgICogY2hhcmFjdGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBkYXRhICAgIFRoZSBzdHJpbmcgb3IgbnVtYmVyIHRvIHBhZFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgICAgVGhlIG51bWJlciBwYWRkZWQgYXMgYSBzdHJpbmdcbiAgICovXG4gIHBhZDI6IGZ1bmN0aW9uIHBhZChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZihkYXRhKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGhhbmRsZSBmcmFjdGlvbnMuXG4gICAgICBpZiAodHlwZW9mKGRhdGEpID09PSAnbnVtYmVyJykge1xuICAgICAgICBkYXRhID0gcGFyc2VJbnQoZGF0YSk7XG4gICAgICB9XG4gICAgICBkYXRhID0gU3RyaW5nKGRhdGEpO1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBkYXRhLmxlbmd0aDtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiAnMDAnO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gJzAnICsgZGF0YTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVHJ1bmNhdGVzIHRoZSBnaXZlbiBudW1iZXIsIGNvcnJlY3RseSBoYW5kbGluZyBuZWdhdGl2ZSBudW1iZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyICAgICBUaGUgbnVtYmVyIHRvIHRydW5jYXRlXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgIFRoZSB0cnVuY2F0ZWQgbnVtYmVyXG4gICAqL1xuICB0cnVuYzogZnVuY3Rpb24gdHJ1bmMobnVtYmVyKSB7XG4gICAgcmV0dXJuIChudW1iZXIgPCAwID8gTWF0aC5jZWlsKG51bWJlcikgOiBNYXRoLmZsb29yKG51bWJlcikpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQb29yLW1hbidzIGNyb3NzLWJyb3dzZXIgaW5oZXJpdGFuY2UgZm9yIEphdmFTY3JpcHQuIERvZXNuJ3Qgc3VwcG9ydCBhbGxcbiAgICogdGhlIGZlYXR1cmVzLCBidXQgZW5vdWdoIGZvciBvdXIgdXNhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2UgICAgIFRoZSBiYXNlIGNsYXNzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGlsZCAgICBUaGUgY2hpbGQgY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRyYSAgICAgIEV4dGVuZHMgdGhlIHByb3RvdHlwZSB3aXRoIGV4dHJhIHByb3BlcnRpZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgbWV0aG9kc1xuICAgKi9cbiAgaW5oZXJpdHM6IGZ1bmN0aW9uKGJhc2UsIGNoaWxkLCBleHRyYSkge1xuICAgIGZ1bmN0aW9uIEYoKSB7fVxuICAgIEYucHJvdG90eXBlID0gYmFzZS5wcm90b3R5cGU7XG4gICAgY2hpbGQucHJvdG90eXBlID0gbmV3IEYoKTtcblxuICAgIGlmIChleHRyYSkge1xuICAgICAgSUNBTC5oZWxwZXJzLmV4dGVuZChleHRyYSwgY2hpbGQucHJvdG90eXBlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBvb3ItbWFuJ3MgY3Jvc3MtYnJvd3NlciBvYmplY3QgZXh0ZW5zaW9uLiBEb2Vzbid0IHN1cHBvcnQgYWxsIHRoZVxuICAgKiBmZWF0dXJlcywgYnV0IGVub3VnaCBmb3Igb3VyIHVzYWdlLiBOb3RlIHRoYXQgdGhlIHRhcmdldCdzIHByb3BlcnRpZXMgYXJlXG4gICAqIG5vdCBvdmVyd3JpdHRlbiB3aXRoIHRoZSBzb3VyY2UgcHJvcGVydGllcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGNoaWxkID0gSUNBTC5oZWxwZXJzLmV4dGVuZChwYXJlbnQsIHtcbiAgICogICBcImJhclwiOiAxMjNcbiAgICogfSk7XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgICAgIFRoZSBvYmplY3QgdG8gZXh0ZW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgICAgIFRoZSBvYmplY3QgdG8gZXh0ZW5kIHdpdGhcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgUmV0dXJucyB0aGUgdGFyZ2V0LlxuICAgKi9cbiAgZXh0ZW5kOiBmdW5jdGlvbihzb3VyY2UsIHRhcmdldCkge1xuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIHZhciBkZXNjciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpO1xuICAgICAgaWYgKGRlc2NyICYmICFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxufTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cbi8qKiBAbmFtZXNwYWNlIElDQUwgKi9cblxuXG4vKipcbiAqIFRoaXMgc3ltYm9sIGlzIGZ1cnRoZXIgZGVzY3JpYmVkIGxhdGVyIG9uXG4gKiBAaWdub3JlXG4gKi9cbklDQUwuZGVzaWduID0gKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIEZST01fSUNBTF9ORVdMSU5FID0gL1xcXFxcXFxcfFxcXFw7fFxcXFwsfFxcXFxbTm5dL2c7XG4gIHZhciBUT19JQ0FMX05FV0xJTkUgPSAvXFxcXHw7fCx8XFxuL2c7XG4gIHZhciBGUk9NX1ZDQVJEX05FV0xJTkUgPSAvXFxcXFxcXFx8XFxcXCx8XFxcXFtObl0vZztcbiAgdmFyIFRPX1ZDQVJEX05FV0xJTkUgPSAvXFxcXHwsfFxcbi9nO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVRleHRUeXBlKGZyb21OZXdsaW5lLCB0b05ld2xpbmUpIHtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgbWF0Y2hlczogLy4qLyxcblxuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSwgc3RydWN0dXJlZEVzY2FwZSkge1xuICAgICAgICByZXR1cm4gcmVwbGFjZU5ld2xpbmUoYVZhbHVlLCBmcm9tTmV3bGluZSwgc3RydWN0dXJlZEVzY2FwZSk7XG4gICAgICB9LFxuXG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSwgc3RydWN0dXJlZEVzY2FwZSkge1xuICAgICAgICB2YXIgcmVnRXggPSB0b05ld2xpbmU7XG4gICAgICAgIGlmIChzdHJ1Y3R1cmVkRXNjYXBlKVxuICAgICAgICAgIHJlZ0V4ID0gbmV3IFJlZ0V4cChyZWdFeC5zb3VyY2UgKyAnfCcgKyBzdHJ1Y3R1cmVkRXNjYXBlKTtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS5yZXBsYWNlKHJlZ0V4LCBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICBzd2l0Y2ggKHN0cikge1xuICAgICAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJcXFxcXFxcXFwiO1xuICAgICAgICAgIGNhc2UgXCI7XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJcXFxcO1wiO1xuICAgICAgICAgIGNhc2UgXCIsXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJcXFxcLFwiO1xuICAgICAgICAgIGNhc2UgXCJcXG5cIjpcbiAgICAgICAgICAgIHJldHVybiBcIlxcXFxuXCI7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGRlZmF1bHQgdHlwZXMgdXNlZCBtdWx0aXBsZSB0aW1lc1xuICB2YXIgREVGQVVMVF9UWVBFX1RFWFQgPSB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiB9O1xuICB2YXIgREVGQVVMVF9UWVBFX1RFWFRfTVVMVEkgPSB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgbXVsdGlWYWx1ZTogXCIsXCIgfTtcbiAgdmFyIERFRkFVTFRfVFlQRV9URVhUX1NUUlVDVFVSRUQgPSB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiB9O1xuICB2YXIgREVGQVVMVF9UWVBFX0lOVEVHRVIgPSB7IGRlZmF1bHRUeXBlOiBcImludGVnZXJcIiB9O1xuICB2YXIgREVGQVVMVF9UWVBFX0RBVEVUSU1FX0RBVEUgPSB7IGRlZmF1bHRUeXBlOiBcImRhdGUtdGltZVwiLCBhbGxvd2VkVHlwZXM6IFtcImRhdGUtdGltZVwiLCBcImRhdGVcIl0gfTtcbiAgdmFyIERFRkFVTFRfVFlQRV9EQVRFVElNRSA9IHsgZGVmYXVsdFR5cGU6IFwiZGF0ZS10aW1lXCIgfTtcbiAgdmFyIERFRkFVTFRfVFlQRV9VUkkgPSB7IGRlZmF1bHRUeXBlOiBcInVyaVwiIH07XG4gIHZhciBERUZBVUxUX1RZUEVfVVRDT0ZGU0VUID0geyBkZWZhdWx0VHlwZTogXCJ1dGMtb2Zmc2V0XCIgfTtcbiAgdmFyIERFRkFVTFRfVFlQRV9SRUNVUiA9IHsgZGVmYXVsdFR5cGU6IFwicmVjdXJcIiB9O1xuICB2YXIgREVGQVVMVF9UWVBFX0RBVEVfQU5ET1JfVElNRSA9IHsgZGVmYXVsdFR5cGU6IFwiZGF0ZS1hbmQtb3ItdGltZVwiLCBhbGxvd2VkVHlwZXM6IFtcImRhdGUtdGltZVwiLCBcImRhdGVcIiwgXCJ0ZXh0XCJdIH07XG5cbiAgZnVuY3Rpb24gcmVwbGFjZU5ld2xpbmVSZXBsYWNlKHN0cmluZykge1xuICAgIHN3aXRjaCAoc3RyaW5nKSB7XG4gICAgICBjYXNlIFwiXFxcXFxcXFxcIjpcbiAgICAgICAgcmV0dXJuIFwiXFxcXFwiO1xuICAgICAgY2FzZSBcIlxcXFw7XCI6XG4gICAgICAgIHJldHVybiBcIjtcIjtcbiAgICAgIGNhc2UgXCJcXFxcLFwiOlxuICAgICAgICByZXR1cm4gXCIsXCI7XG4gICAgICBjYXNlIFwiXFxcXG5cIjpcbiAgICAgIGNhc2UgXCJcXFxcTlwiOlxuICAgICAgICByZXR1cm4gXCJcXG5cIjtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2VOZXdsaW5lKHZhbHVlLCBuZXdsaW5lLCBzdHJ1Y3R1cmVkRXNjYXBlKSB7XG4gICAgLy8gYXZvaWQgcmVnZXggd2hlbiBwb3NzaWJsZS5cbiAgICBpZiAodmFsdWUuaW5kZXhPZignXFxcXCcpID09PSAtMSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoc3RydWN0dXJlZEVzY2FwZSlcbiAgICAgIG5ld2xpbmUgPSBuZXcgUmVnRXhwKG5ld2xpbmUuc291cmNlICsgJ3xcXFxcXFxcXCcgKyBzdHJ1Y3R1cmVkRXNjYXBlKTtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZShuZXdsaW5lLCByZXBsYWNlTmV3bGluZVJlcGxhY2UpO1xuICB9XG5cbiAgdmFyIGNvbW1vblByb3BlcnRpZXMgPSB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IERFRkFVTFRfVFlQRV9URVhUX01VTFRJLFxuICAgIFwidXJsXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJ2ZXJzaW9uXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwidWlkXCI6IERFRkFVTFRfVFlQRV9URVhUXG4gIH07XG5cbiAgdmFyIGNvbW1vblZhbHVlcyA9IHtcbiAgICBcImJvb2xlYW5cIjoge1xuICAgICAgdmFsdWVzOiBbXCJUUlVFXCIsIFwiRkFMU0VcIl0sXG5cbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgc3dpdGNoIChhVmFsdWUpIHtcbiAgICAgICAgICBjYXNlICdUUlVFJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIGNhc2UgJ0ZBTFNFJzpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy9UT0RPOiBwYXJzZXIgd2FybmluZ1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICBpZiAoYVZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuICdUUlVFJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ0ZBTFNFJztcbiAgICAgIH1cblxuICAgIH0sXG4gICAgZmxvYXQ6IHtcbiAgICAgIG1hdGNoZXM6IC9eWystXT9cXGQrXFwuXFxkKyQvLFxuXG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZUZsb2F0KGFWYWx1ZSk7XG4gICAgICAgIGlmIChJQ0FMLmhlbHBlcnMuaXNTdHJpY3RseU5hTihwYXJzZWQpKSB7XG4gICAgICAgICAgLy8gVE9ETzogcGFyc2VyIHdhcm5pbmdcbiAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9LFxuXG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGFWYWx1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpbnRlZ2VyOiB7XG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChhVmFsdWUpO1xuICAgICAgICBpZiAoSUNBTC5oZWxwZXJzLmlzU3RyaWN0bHlOYU4ocGFyc2VkKSkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9LFxuXG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGFWYWx1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcInV0Yy1vZmZzZXRcIjoge1xuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgaWYgKGFWYWx1ZS5sZW5ndGggPCA3KSB7XG4gICAgICAgICAgLy8gbm8gc2Vjb25kc1xuICAgICAgICAgIC8vIC0wNTAwXG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZS5zdWJzdHIoMCwgMykgK1xuICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDQsIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHNlY29uZHNcbiAgICAgICAgICAvLyAtMDUwMDAwXG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZS5zdWJzdHIoMCwgMykgK1xuICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDQsIDIpICtcbiAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig3LCAyKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICBpZiAoYVZhbHVlLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgICAvLyBubyBzZWNvbmRzXG4gICAgICAgICAgLy8gLTA1OjAwXG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZS5zdWJzdHIoMCwgMykgKyAnOicgK1xuICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDMsIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHNlY29uZHNcbiAgICAgICAgICAvLyAtMDU6MDA6MDBcbiAgICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCAzKSArICc6JyArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoMywgMikgKyAnOicgK1xuICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDUsIDIpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlV0Y09mZnNldC5mcm9tU3RyaW5nKGFWYWx1ZSk7XG4gICAgICB9LFxuXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgaWNhbFBhcmFtcyA9IHtcbiAgICAvLyBBbHRob3VnaCB0aGUgc3ludGF4IGlzIERRVU9URSB1cmkgRFFVT1RFLCBJIGRvbid0IHRoaW5rIHdlIHNob3VsZFxuICAgIC8vIGVuZm9jZSBhbnl0aGluZyBhc2lkZSBmcm9tIGl0IGJlaW5nIGEgdmFsaWQgY29udGVudCBsaW5lLlxuICAgIC8vXG4gICAgLy8gQXQgbGVhc3Qgc29tZSBwYXJhbXMgcmVxdWlyZSAtIGlmIG11bHRpIHZhbHVlcyBhcmUgdXNlZCAtIERRVU9URXNcbiAgICAvLyBmb3IgZWFjaCBvZiBpdHMgdmFsdWVzIC0gZS5nLiBkZWxlZ2F0ZWQtZnJvbT1cInVyaTFcIixcInVyaTJcIlxuICAgIC8vIFRvIGluZGljYXRlIHRoaXMsIEkgaW50cm9kdWNlZCB0aGUgbmV3IGsvdiBwYWlyXG4gICAgLy8gbXVsdGlWYWx1ZVNlcGFyYXRlRFF1b3RlOiB0cnVlXG4gICAgLy9cbiAgICAvLyBcIkFMVFJFUFwiOiB7IC4uLiB9LFxuXG4gICAgLy8gQ04ganVzdCB3YW50cyBhIHBhcmFtLXZhbHVlXG4gICAgLy8gXCJDTlwiOiB7IC4uLiB9XG5cbiAgICBcImN1dHlwZVwiOiB7XG4gICAgICB2YWx1ZXM6IFtcIklORElWSURVQUxcIiwgXCJHUk9VUFwiLCBcIlJFU09VUkNFXCIsIFwiUk9PTVwiLCBcIlVOS05PV05cIl0sXG4gICAgICBhbGxvd1hOYW1lOiB0cnVlLFxuICAgICAgYWxsb3dJYW5hVG9rZW46IHRydWVcbiAgICB9LFxuXG4gICAgXCJkZWxlZ2F0ZWQtZnJvbVwiOiB7XG4gICAgICB2YWx1ZVR5cGU6IFwiY2FsLWFkZHJlc3NcIixcbiAgICAgIG11bHRpVmFsdWU6IFwiLFwiLFxuICAgICAgbXVsdGlWYWx1ZVNlcGFyYXRlRFF1b3RlOiB0cnVlXG4gICAgfSxcbiAgICBcImRlbGVnYXRlZC10b1wiOiB7XG4gICAgICB2YWx1ZVR5cGU6IFwiY2FsLWFkZHJlc3NcIixcbiAgICAgIG11bHRpVmFsdWU6IFwiLFwiLFxuICAgICAgbXVsdGlWYWx1ZVNlcGFyYXRlRFF1b3RlOiB0cnVlXG4gICAgfSxcbiAgICAvLyBcIkRJUlwiOiB7IC4uLiB9LCAvLyBTZWUgQUxUUkVQXG4gICAgXCJlbmNvZGluZ1wiOiB7XG4gICAgICB2YWx1ZXM6IFtcIjhCSVRcIiwgXCJCQVNFNjRcIl1cbiAgICB9LFxuICAgIC8vIFwiRk1UVFlQRVwiOiB7IC4uLiB9LCAvLyBTZWUgQUxUUkVQXG4gICAgXCJmYnR5cGVcIjoge1xuICAgICAgdmFsdWVzOiBbXCJGUkVFXCIsIFwiQlVTWVwiLCBcIkJVU1ktVU5BVkFJTEFCTEVcIiwgXCJCVVNZLVRFTlRBVElWRVwiXSxcbiAgICAgIGFsbG93WE5hbWU6IHRydWUsXG4gICAgICBhbGxvd0lhbmFUb2tlbjogdHJ1ZVxuICAgIH0sXG4gICAgLy8gXCJMQU5HVUFHRVwiOiB7IC4uLiB9LCAvLyBTZWUgQUxUUkVQXG4gICAgXCJtZW1iZXJcIjoge1xuICAgICAgdmFsdWVUeXBlOiBcImNhbC1hZGRyZXNzXCIsXG4gICAgICBtdWx0aVZhbHVlOiBcIixcIixcbiAgICAgIG11bHRpVmFsdWVTZXBhcmF0ZURRdW90ZTogdHJ1ZVxuICAgIH0sXG4gICAgXCJwYXJ0c3RhdFwiOiB7XG4gICAgICAvLyBUT0RPIFRoZXNlIHZhbHVlcyBhcmUgYWN0dWFsbHkgZGlmZmVyZW50IHBlci1jb21wb25lbnRcbiAgICAgIHZhbHVlczogW1wiTkVFRFMtQUNUSU9OXCIsIFwiQUNDRVBURURcIiwgXCJERUNMSU5FRFwiLCBcIlRFTlRBVElWRVwiLFxuICAgICAgICAgICAgICAgXCJERUxFR0FURURcIiwgXCJDT01QTEVURURcIiwgXCJJTi1QUk9DRVNTXCJdLFxuICAgICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gICAgfSxcbiAgICBcInJhbmdlXCI6IHtcbiAgICAgIHZhbHVlczogW1wiVEhJU0FOREZVVFVSRVwiXVxuICAgIH0sXG4gICAgXCJyZWxhdGVkXCI6IHtcbiAgICAgIHZhbHVlczogW1wiU1RBUlRcIiwgXCJFTkRcIl1cbiAgICB9LFxuICAgIFwicmVsdHlwZVwiOiB7XG4gICAgICB2YWx1ZXM6IFtcIlBBUkVOVFwiLCBcIkNISUxEXCIsIFwiU0lCTElOR1wiXSxcbiAgICAgIGFsbG93WE5hbWU6IHRydWUsXG4gICAgICBhbGxvd0lhbmFUb2tlbjogdHJ1ZVxuICAgIH0sXG4gICAgXCJyb2xlXCI6IHtcbiAgICAgIHZhbHVlczogW1wiUkVRLVBBUlRJQ0lQQU5UXCIsIFwiQ0hBSVJcIixcbiAgICAgICAgICAgICAgIFwiT1BULVBBUlRJQ0lQQU5UXCIsIFwiTk9OLVBBUlRJQ0lQQU5UXCJdLFxuICAgICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gICAgfSxcbiAgICBcInJzdnBcIjoge1xuICAgICAgdmFsdWVzOiBbXCJUUlVFXCIsIFwiRkFMU0VcIl1cbiAgICB9LFxuICAgIFwic2VudC1ieVwiOiB7XG4gICAgICB2YWx1ZVR5cGU6IFwiY2FsLWFkZHJlc3NcIlxuICAgIH0sXG4gICAgXCJ0emlkXCI6IHtcbiAgICAgIG1hdGNoZXM6IC9eXFwvL1xuICAgIH0sXG4gICAgXCJ2YWx1ZVwiOiB7XG4gICAgICAvLyBzaW5jZSB0aGUgdmFsdWUgaGVyZSBpcyBhICd0eXBlJyBsb3dlcmNhc2UgaXMgdXNlZC5cbiAgICAgIHZhbHVlczogW1wiYmluYXJ5XCIsIFwiYm9vbGVhblwiLCBcImNhbC1hZGRyZXNzXCIsIFwiZGF0ZVwiLCBcImRhdGUtdGltZVwiLFxuICAgICAgICAgICAgICAgXCJkdXJhdGlvblwiLCBcImZsb2F0XCIsIFwiaW50ZWdlclwiLCBcInBlcmlvZFwiLCBcInJlY3VyXCIsIFwidGV4dFwiLFxuICAgICAgICAgICAgICAgXCJ0aW1lXCIsIFwidXJpXCIsIFwidXRjLW9mZnNldFwiXSxcbiAgICAgIGFsbG93WE5hbWU6IHRydWUsXG4gICAgICBhbGxvd0lhbmFUb2tlbjogdHJ1ZVxuICAgIH1cbiAgfTtcblxuICAvLyBXaGVuIGFkZGluZyBhIHZhbHVlIGhlcmUsIGJlIHN1cmUgdG8gYWRkIGl0IHRvIHRoZSBwYXJhbWV0ZXIgdHlwZXMhXG4gIHZhciBpY2FsVmFsdWVzID0gSUNBTC5oZWxwZXJzLmV4dGVuZChjb21tb25WYWx1ZXMsIHtcbiAgICB0ZXh0OiBjcmVhdGVUZXh0VHlwZShGUk9NX0lDQUxfTkVXTElORSwgVE9fSUNBTF9ORVdMSU5FKSxcblxuICAgIHVyaToge1xuICAgICAgLy8gVE9ET1xuICAgICAgLyogLi4uICovXG4gICAgfSxcblxuICAgIFwiYmluYXJ5XCI6IHtcbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLkJpbmFyeS5mcm9tU3RyaW5nKGFTdHJpbmcpO1xuICAgICAgfSxcblxuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYUJpbmFyeSkge1xuICAgICAgICByZXR1cm4gYUJpbmFyeS50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJjYWwtYWRkcmVzc1wiOiB7XG4gICAgICAvLyBuZWVkcyB0byBiZSBhbiB1cmlcbiAgICB9LFxuICAgIFwiZGF0ZVwiOiB7XG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlLCBhUHJvcCkge1xuICAgICAgICBpZiAoZGVzaWduLnN0cmljdCkge1xuICAgICAgICAgIHJldHVybiBJQ0FMLlRpbWUuZnJvbURhdGVTdHJpbmcoYVZhbHVlLCBhUHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIElDQUwuVGltZS5mcm9tU3RyaW5nKGFWYWx1ZSwgYVByb3ApO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIHVuZGVjb3JhdGVzIGEgdGltZSBvYmplY3QuXG4gICAgICAgKi9cbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9LFxuXG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIC8vIGZyb206IDIwMTIwOTAxXG4gICAgICAgIC8vIHRvOiAyMDEyLTA5LTAxXG4gICAgICAgIGlmICghZGVzaWduLnN0cmljdCAmJiBhVmFsdWUubGVuZ3RoID49IDE1KSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBhIGRhdGUtdGltZSwgZS5nLiAyMDEyMDkwMVQxMzAwMDBaXG4gICAgICAgICAgcmV0dXJuIGljYWxWYWx1ZXNbXCJkYXRlLXRpbWVcIl0uZnJvbUlDQUwoYVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCA0KSArICctJyArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNCwgMikgKyAnLScgK1xuICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDYsIDIpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICAvLyBmcm9tOiAyMDEyLTA5LTAxXG4gICAgICAgIC8vIHRvOiAyMDEyMDkwMVxuICAgICAgICB2YXIgbGVuID0gYVZhbHVlLmxlbmd0aDtcblxuICAgICAgICBpZiAobGVuID09IDEwKSB7XG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZS5zdWJzdHIoMCwgNCkgK1xuICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDUsIDIpICtcbiAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig4LCAyKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZW4gPj0gMTkpIHtcbiAgICAgICAgICByZXR1cm4gaWNhbFZhbHVlc1tcImRhdGUtdGltZVwiXS50b0lDQUwoYVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL1RPRE86IHNlcmlhbGl6ZSB3YXJuaW5nP1xuICAgICAgICAgIHJldHVybiBhVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkYXRlLXRpbWVcIjoge1xuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICAvLyBmcm9tOiAyMDEyMDkwMVQxMzAwMDBcbiAgICAgICAgLy8gdG86IDIwMTItMDktMDFUMTM6MDA6MDBcbiAgICAgICAgaWYgKCFkZXNpZ24uc3RyaWN0ICYmIGFWYWx1ZS5sZW5ndGggPT0gOCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYSBkYXRlLCBlLmcuIDIwMTIwOTAxXG4gICAgICAgICAgcmV0dXJuIGljYWxWYWx1ZXMuZGF0ZS5mcm9tSUNBTChhVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBhVmFsdWUuc3Vic3RyKDAsIDQpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig0LCAyKSArICctJyArXG4gICAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNiwgMikgKyAnVCcgK1xuICAgICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDksIDIpICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cigxMSwgMikgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDEzLCAyKTtcblxuICAgICAgICAgIGlmIChhVmFsdWVbMTVdICYmIGFWYWx1ZVsxNV0gPT09ICdaJykge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdaJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICAvLyBmcm9tOiAyMDEyLTA5LTAxVDEzOjAwOjAwXG4gICAgICAgIC8vIHRvOiAyMDEyMDkwMVQxMzAwMDBcbiAgICAgICAgdmFyIGxlbiA9IGFWYWx1ZS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGxlbiA9PSAxMCAmJiAhZGVzaWduLnN0cmljdCkge1xuICAgICAgICAgIHJldHVybiBpY2FsVmFsdWVzLmRhdGUudG9JQ0FMKGFWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGVuID49IDE5KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGFWYWx1ZS5zdWJzdHIoMCwgNCkgK1xuICAgICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDUsIDIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gZ3JhYiB0aGUgKEREVEhIKSBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoOCwgNSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAvLyBNTVxuICAgICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDE0LCAyKSArXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIFNTXG4gICAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoMTcsIDIpO1xuXG4gICAgICAgICAgaWYgKGFWYWx1ZVsxOV0gJiYgYVZhbHVlWzE5XSA9PT0gJ1onKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1onO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRPRE86IGVycm9yXG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSwgYVByb3ApIHtcbiAgICAgICAgaWYgKGRlc2lnbi5zdHJpY3QpIHtcbiAgICAgICAgICByZXR1cm4gSUNBTC5UaW1lLmZyb21EYXRlVGltZVN0cmluZyhhVmFsdWUsIGFQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gSUNBTC5UaW1lLmZyb21TdHJpbmcoYVZhbHVlLCBhUHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkdXJhdGlvbjoge1xuICAgICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gSUNBTC5EdXJhdGlvbi5mcm9tU3RyaW5nKGFWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBlcmlvZDoge1xuXG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnLycpO1xuICAgICAgICBwYXJ0c1swXSA9IGljYWxWYWx1ZXNbJ2RhdGUtdGltZSddLmZyb21JQ0FMKHBhcnRzWzBdKTtcblxuICAgICAgICBpZiAoIUlDQUwuRHVyYXRpb24uaXNWYWx1ZVN0cmluZyhwYXJ0c1sxXSkpIHtcbiAgICAgICAgICBwYXJ0c1sxXSA9IGljYWxWYWx1ZXNbJ2RhdGUtdGltZSddLmZyb21JQ0FMKHBhcnRzWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24ocGFydHMpIHtcbiAgICAgICAgaWYgKCFkZXNpZ24uc3RyaWN0ICYmIHBhcnRzWzBdLmxlbmd0aCA9PSAxMCkge1xuICAgICAgICAgIHBhcnRzWzBdID0gaWNhbFZhbHVlcy5kYXRlLnRvSUNBTChwYXJ0c1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFydHNbMF0gPSBpY2FsVmFsdWVzWydkYXRlLXRpbWUnXS50b0lDQUwocGFydHNbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFJQ0FMLkR1cmF0aW9uLmlzVmFsdWVTdHJpbmcocGFydHNbMV0pKSB7XG4gICAgICAgICAgaWYgKCFkZXNpZ24uc3RyaWN0ICYmIHBhcnRzWzFdLmxlbmd0aCA9PSAxMCkge1xuICAgICAgICAgICAgcGFydHNbMV0gPSBpY2FsVmFsdWVzLmRhdGUudG9JQ0FMKHBhcnRzWzFdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFydHNbMV0gPSBpY2FsVmFsdWVzWydkYXRlLXRpbWUnXS50b0lDQUwocGFydHNbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiL1wiKTtcbiAgICAgIH0sXG5cbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUsIGFQcm9wKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlBlcmlvZC5mcm9tSlNPTihhVmFsdWUsIGFQcm9wLCAhZGVzaWduLnN0cmljdCk7XG4gICAgICB9LFxuXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS50b0pTT04oKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlY3VyOiB7XG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlJlY3VyLl9zdHJpbmdUb0RhdGEoc3RyaW5nLCB0cnVlKTtcbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgc3RyID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgayBpbiBkYXRhKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgaykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsID0gZGF0YVtrXTtcbiAgICAgICAgICBpZiAoayA9PSBcInVudGlsXCIpIHtcbiAgICAgICAgICAgIGlmICh2YWwubGVuZ3RoID4gMTApIHtcbiAgICAgICAgICAgICAgdmFsID0gaWNhbFZhbHVlc1snZGF0ZS10aW1lJ10udG9JQ0FMKHZhbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWwgPSBpY2FsVmFsdWVzLmRhdGUudG9JQ0FMKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChrID09IFwid2tzdFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgdmFsID0gSUNBTC5SZWN1ci5udW1lcmljRGF5VG9JY2FsRGF5KHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbC5qb2luKFwiLFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyICs9IGsudG9VcHBlckNhc2UoKSArIFwiPVwiICsgdmFsICsgXCI7XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgc3RyLmxlbmd0aCAtIDEpO1xuICAgICAgfSxcblxuICAgICAgZGVjb3JhdGU6IGZ1bmN0aW9uIGRlY29yYXRlKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gSUNBTC5SZWN1ci5mcm9tRGF0YShhVmFsdWUpO1xuICAgICAgfSxcblxuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVJlY3VyKSB7XG4gICAgICAgIHJldHVybiBhUmVjdXIudG9KU09OKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHRpbWU6IHtcbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgLy8gZnJvbTogTU1ISFNTKFopP1xuICAgICAgICAvLyB0bzogSEg6TU06U1MoWik/XG4gICAgICAgIGlmIChhVmFsdWUubGVuZ3RoIDwgNikge1xuICAgICAgICAgIC8vIFRPRE86IHBhcnNlciBleGNlcHRpb24/XG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhIOjpNTTo6U1NaP1xuICAgICAgICB2YXIgcmVzdWx0ID0gYVZhbHVlLnN1YnN0cigwLCAyKSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDIsIDIpICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNCwgMik7XG5cbiAgICAgICAgaWYgKGFWYWx1ZVs2XSA9PT0gJ1onKSB7XG4gICAgICAgICAgcmVzdWx0ICs9ICdaJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuXG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICAvLyBmcm9tOiBISDpNTTpTUyhaKT9cbiAgICAgICAgLy8gdG86IE1NSEhTUyhaKT9cbiAgICAgICAgaWYgKGFWYWx1ZS5sZW5ndGggPCA4KSB7XG4gICAgICAgICAgLy9UT0RPOiBlcnJvclxuICAgICAgICAgIHJldHVybiBhVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gYVZhbHVlLnN1YnN0cigwLCAyKSArXG4gICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDMsIDIpICtcbiAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNiwgMik7XG5cbiAgICAgICAgaWYgKGFWYWx1ZVs4XSA9PT0gJ1onKSB7XG4gICAgICAgICAgcmVzdWx0ICs9ICdaJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICB2YXIgaWNhbFByb3BlcnRpZXMgPSBJQ0FMLmhlbHBlcnMuZXh0ZW5kKGNvbW1vblByb3BlcnRpZXMsIHtcblxuICAgIFwiYWN0aW9uXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwiYXR0YWNoXCI6IHsgZGVmYXVsdFR5cGU6IFwidXJpXCIgfSxcbiAgICBcImF0dGVuZGVlXCI6IHsgZGVmYXVsdFR5cGU6IFwiY2FsLWFkZHJlc3NcIiB9LFxuICAgIFwiY2Fsc2NhbGVcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJjbGFzc1wiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcImNvbW1lbnRcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJjb21wbGV0ZWRcIjogREVGQVVMVF9UWVBFX0RBVEVUSU1FLFxuICAgIFwiY29udGFjdFwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcImNyZWF0ZWRcIjogREVGQVVMVF9UWVBFX0RBVEVUSU1FLFxuICAgIFwiZGVzY3JpcHRpb25cIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJkdGVuZFwiOiBERUZBVUxUX1RZUEVfREFURVRJTUVfREFURSxcbiAgICBcImR0c3RhbXBcIjogREVGQVVMVF9UWVBFX0RBVEVUSU1FLFxuICAgIFwiZHRzdGFydFwiOiBERUZBVUxUX1RZUEVfREFURVRJTUVfREFURSxcbiAgICBcImR1ZVwiOiBERUZBVUxUX1RZUEVfREFURVRJTUVfREFURSxcbiAgICBcImR1cmF0aW9uXCI6IHsgZGVmYXVsdFR5cGU6IFwiZHVyYXRpb25cIiB9LFxuICAgIFwiZXhkYXRlXCI6IHtcbiAgICAgIGRlZmF1bHRUeXBlOiBcImRhdGUtdGltZVwiLFxuICAgICAgYWxsb3dlZFR5cGVzOiBbXCJkYXRlLXRpbWVcIiwgXCJkYXRlXCJdLFxuICAgICAgbXVsdGlWYWx1ZTogJywnXG4gICAgfSxcbiAgICBcImV4cnVsZVwiOiBERUZBVUxUX1RZUEVfUkVDVVIsXG4gICAgXCJmcmVlYnVzeVwiOiB7IGRlZmF1bHRUeXBlOiBcInBlcmlvZFwiLCBtdWx0aVZhbHVlOiBcIixcIiB9LFxuICAgIFwiZ2VvXCI6IHsgZGVmYXVsdFR5cGU6IFwiZmxvYXRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiB9LFxuICAgIFwibGFzdC1tb2RpZmllZFwiOiBERUZBVUxUX1RZUEVfREFURVRJTUUsXG4gICAgXCJsb2NhdGlvblwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcIm1ldGhvZFwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcIm9yZ2FuaXplclwiOiB7IGRlZmF1bHRUeXBlOiBcImNhbC1hZGRyZXNzXCIgfSxcbiAgICBcInBlcmNlbnQtY29tcGxldGVcIjogREVGQVVMVF9UWVBFX0lOVEVHRVIsXG4gICAgXCJwcmlvcml0eVwiOiBERUZBVUxUX1RZUEVfSU5URUdFUixcbiAgICBcInByb2RpZFwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcInJlbGF0ZWQtdG9cIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJyZXBlYXRcIjogREVGQVVMVF9UWVBFX0lOVEVHRVIsXG4gICAgXCJyZGF0ZVwiOiB7XG4gICAgICBkZWZhdWx0VHlwZTogXCJkYXRlLXRpbWVcIixcbiAgICAgIGFsbG93ZWRUeXBlczogW1wiZGF0ZS10aW1lXCIsIFwiZGF0ZVwiLCBcInBlcmlvZFwiXSxcbiAgICAgIG11bHRpVmFsdWU6ICcsJyxcbiAgICAgIGRldGVjdFR5cGU6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICBpZiAoc3RyaW5nLmluZGV4T2YoJy8nKSAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gJ3BlcmlvZCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChzdHJpbmcuaW5kZXhPZignVCcpID09PSAtMSkgPyAnZGF0ZScgOiAnZGF0ZS10aW1lJztcbiAgICAgIH1cbiAgICB9LFxuICAgIFwicmVjdXJyZW5jZS1pZFwiOiBERUZBVUxUX1RZUEVfREFURVRJTUVfREFURSxcbiAgICBcInJlc291cmNlc1wiOiBERUZBVUxUX1RZUEVfVEVYVF9NVUxUSSxcbiAgICBcInJlcXVlc3Qtc3RhdHVzXCI6IERFRkFVTFRfVFlQRV9URVhUX1NUUlVDVFVSRUQsXG4gICAgXCJycnVsZVwiOiBERUZBVUxUX1RZUEVfUkVDVVIsXG4gICAgXCJzZXF1ZW5jZVwiOiBERUZBVUxUX1RZUEVfSU5URUdFUixcbiAgICBcInN0YXR1c1wiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcInN1bW1hcnlcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJ0cmFuc3BcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJ0cmlnZ2VyXCI6IHsgZGVmYXVsdFR5cGU6IFwiZHVyYXRpb25cIiwgYWxsb3dlZFR5cGVzOiBbXCJkdXJhdGlvblwiLCBcImRhdGUtdGltZVwiXSB9LFxuICAgIFwidHpvZmZzZXRmcm9tXCI6IERFRkFVTFRfVFlQRV9VVENPRkZTRVQsXG4gICAgXCJ0em9mZnNldHRvXCI6IERFRkFVTFRfVFlQRV9VVENPRkZTRVQsXG4gICAgXCJ0enVybFwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwidHppZFwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcInR6bmFtZVwiOiBERUZBVUxUX1RZUEVfVEVYVFxuICB9KTtcblxuICAvLyBXaGVuIGFkZGluZyBhIHZhbHVlIGhlcmUsIGJlIHN1cmUgdG8gYWRkIGl0IHRvIHRoZSBwYXJhbWV0ZXIgdHlwZXMhXG4gIHZhciB2Y2FyZFZhbHVlcyA9IElDQUwuaGVscGVycy5leHRlbmQoY29tbW9uVmFsdWVzLCB7XG4gICAgdGV4dDogY3JlYXRlVGV4dFR5cGUoRlJPTV9WQ0FSRF9ORVdMSU5FLCBUT19WQ0FSRF9ORVdMSU5FKSxcbiAgICB1cmk6IGNyZWF0ZVRleHRUeXBlKEZST01fVkNBUkRfTkVXTElORSwgVE9fVkNBUkRfTkVXTElORSksXG5cbiAgICBkYXRlOiB7XG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlZDYXJkVGltZS5mcm9tRGF0ZUFuZE9yVGltZVN0cmluZyhhVmFsdWUsIFwiZGF0ZVwiKTtcbiAgICAgIH0sXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgICAgfSxcbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgaWYgKGFWYWx1ZS5sZW5ndGggPT0gOCkge1xuICAgICAgICAgIHJldHVybiBpY2FsVmFsdWVzLmRhdGUuZnJvbUlDQUwoYVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChhVmFsdWVbMF0gPT0gJy0nICYmIGFWYWx1ZS5sZW5ndGggPT0gNikge1xuICAgICAgICAgIHJldHVybiBhVmFsdWUuc3Vic3RyKDAsIDQpICsgJy0nICsgYVZhbHVlLnN1YnN0cig0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgaWYgKGFWYWx1ZS5sZW5ndGggPT0gMTApIHtcbiAgICAgICAgICByZXR1cm4gaWNhbFZhbHVlcy5kYXRlLnRvSUNBTChhVmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGFWYWx1ZVswXSA9PSAnLScgJiYgYVZhbHVlLmxlbmd0aCA9PSA3KSB7XG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZS5zdWJzdHIoMCwgNCkgKyBhVmFsdWUuc3Vic3RyKDUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBhVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdGltZToge1xuICAgICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gSUNBTC5WQ2FyZFRpbWUuZnJvbURhdGVBbmRPclRpbWVTdHJpbmcoXCJUXCIgKyBhVmFsdWUsIFwidGltZVwiKTtcbiAgICAgIH0sXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgICAgfSxcbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgdmFyIHNwbGl0em9uZSA9IHZjYXJkVmFsdWVzLnRpbWUuX3NwbGl0Wm9uZShhVmFsdWUsIHRydWUpO1xuICAgICAgICB2YXIgem9uZSA9IHNwbGl0em9uZVswXSwgdmFsdWUgPSBzcGxpdHpvbmVbMV07XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlNQTElUOiBcIixzcGxpdHpvbmUpO1xuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT0gNikge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDAsIDIpICsgJzonICtcbiAgICAgICAgICAgICAgICAgIHZhbHVlLnN1YnN0cigyLCAyKSArICc6JyArXG4gICAgICAgICAgICAgICAgICB2YWx1ZS5zdWJzdHIoNCwgMik7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID09IDQgJiYgdmFsdWVbMF0gIT0gJy0nKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMCwgMikgKyAnOicgKyB2YWx1ZS5zdWJzdHIoMiwgMik7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID09IDUpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigwLCAzKSArICc6JyArIHZhbHVlLnN1YnN0cigzLCAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh6b25lLmxlbmd0aCA9PSA1ICYmICh6b25lWzBdID09ICctJyB8fCB6b25lWzBdID09ICcrJykpIHtcbiAgICAgICAgICB6b25lID0gem9uZS5zdWJzdHIoMCwgMykgKyAnOicgKyB6b25lLnN1YnN0cigzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZSArIHpvbmU7XG4gICAgICB9LFxuXG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICB2YXIgc3BsaXR6b25lID0gdmNhcmRWYWx1ZXMudGltZS5fc3BsaXRab25lKGFWYWx1ZSk7XG4gICAgICAgIHZhciB6b25lID0gc3BsaXR6b25lWzBdLCB2YWx1ZSA9IHNwbGl0em9uZVsxXTtcblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09IDgpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigwLCAyKSArXG4gICAgICAgICAgICAgICAgICB2YWx1ZS5zdWJzdHIoMywgMikgK1xuICAgICAgICAgICAgICAgICAgdmFsdWUuc3Vic3RyKDYsIDIpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA9PSA1ICYmIHZhbHVlWzBdICE9ICctJykge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDAsIDIpICsgdmFsdWUuc3Vic3RyKDMsIDIpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA9PSA2KSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMCwgMykgKyB2YWx1ZS5zdWJzdHIoNCwgMik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoem9uZS5sZW5ndGggPT0gNiAmJiAoem9uZVswXSA9PSAnLScgfHwgem9uZVswXSA9PSAnKycpKSB7XG4gICAgICAgICAgem9uZSA9IHpvbmUuc3Vic3RyKDAsIDMpICsgem9uZS5zdWJzdHIoNCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWUgKyB6b25lO1xuICAgICAgfSxcblxuICAgICAgX3NwbGl0Wm9uZTogZnVuY3Rpb24oYVZhbHVlLCBpc0Zyb21JY2FsKSB7XG4gICAgICAgIHZhciBsYXN0Q2hhciA9IGFWYWx1ZS5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgc2lnbkNoYXIgPSBhVmFsdWUubGVuZ3RoIC0gKGlzRnJvbUljYWwgPyA1IDogNik7XG4gICAgICAgIHZhciBzaWduID0gYVZhbHVlW3NpZ25DaGFyXTtcbiAgICAgICAgdmFyIHpvbmUsIHZhbHVlO1xuXG4gICAgICAgIGlmIChhVmFsdWVbbGFzdENoYXJdID09ICdaJykge1xuICAgICAgICAgIHpvbmUgPSBhVmFsdWVbbGFzdENoYXJdO1xuICAgICAgICAgIHZhbHVlID0gYVZhbHVlLnN1YnN0cigwLCBsYXN0Q2hhcik7XG4gICAgICAgIH0gZWxzZSBpZiAoYVZhbHVlLmxlbmd0aCA+IDYgJiYgKHNpZ24gPT0gJy0nIHx8IHNpZ24gPT0gJysnKSkge1xuICAgICAgICAgIHpvbmUgPSBhVmFsdWUuc3Vic3RyKHNpZ25DaGFyKTtcbiAgICAgICAgICB2YWx1ZSA9IGFWYWx1ZS5zdWJzdHIoMCwgc2lnbkNoYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHpvbmUgPSBcIlwiO1xuICAgICAgICAgIHZhbHVlID0gYVZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFt6b25lLCB2YWx1ZV07XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiZGF0ZS10aW1lXCI6IHtcbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVkNhcmRUaW1lLmZyb21EYXRlQW5kT3JUaW1lU3RyaW5nKGFWYWx1ZSwgXCJkYXRlLXRpbWVcIik7XG4gICAgICB9LFxuXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgICAgfSxcblxuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdmNhcmRWYWx1ZXNbJ2RhdGUtYW5kLW9yLXRpbWUnXS5mcm9tSUNBTChhVmFsdWUpO1xuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZjYXJkVmFsdWVzWydkYXRlLWFuZC1vci10aW1lJ10udG9JQ0FMKGFWYWx1ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiZGF0ZS1hbmQtb3ItdGltZVwiOiB7XG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlZDYXJkVGltZS5mcm9tRGF0ZUFuZE9yVGltZVN0cmluZyhhVmFsdWUsIFwiZGF0ZS1hbmQtb3ItdGltZVwiKTtcbiAgICAgIH0sXG5cbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9LFxuXG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IGFWYWx1ZS5zcGxpdCgnVCcpO1xuICAgICAgICByZXR1cm4gKHBhcnRzWzBdID8gdmNhcmRWYWx1ZXMuZGF0ZS5mcm9tSUNBTChwYXJ0c1swXSkgOiAnJykgK1xuICAgICAgICAgICAgICAgKHBhcnRzWzFdID8gJ1QnICsgdmNhcmRWYWx1ZXMudGltZS5mcm9tSUNBTChwYXJ0c1sxXSkgOiAnJyk7XG4gICAgICB9LFxuXG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICB2YXIgcGFydHMgPSBhVmFsdWUuc3BsaXQoJ1QnKTtcbiAgICAgICAgcmV0dXJuIHZjYXJkVmFsdWVzLmRhdGUudG9JQ0FMKHBhcnRzWzBdKSArXG4gICAgICAgICAgICAgICAocGFydHNbMV0gPyAnVCcgKyB2Y2FyZFZhbHVlcy50aW1lLnRvSUNBTChwYXJ0c1sxXSkgOiAnJyk7XG5cbiAgICAgIH1cbiAgICB9LFxuICAgIHRpbWVzdGFtcDogaWNhbFZhbHVlc1snZGF0ZS10aW1lJ10sXG4gICAgXCJsYW5ndWFnZS10YWdcIjoge1xuICAgICAgbWF0Y2hlczogL15bYS16QS1aMC05LV0rJC8gLy8gQ291bGQgZ28gd2l0aCBhIG1vcmUgc3RyaWN0IHJlZ2V4IGhlcmVcbiAgICB9XG4gIH0pO1xuXG4gIHZhciB2Y2FyZFBhcmFtcyA9IHtcbiAgICBcInR5cGVcIjoge1xuICAgICAgdmFsdWVUeXBlOiBcInRleHRcIixcbiAgICAgIG11bHRpVmFsdWU6IFwiLFwiXG4gICAgfSxcbiAgICBcInZhbHVlXCI6IHtcbiAgICAgIC8vIHNpbmNlIHRoZSB2YWx1ZSBoZXJlIGlzIGEgJ3R5cGUnIGxvd2VyY2FzZSBpcyB1c2VkLlxuICAgICAgdmFsdWVzOiBbXCJ0ZXh0XCIsIFwidXJpXCIsIFwiZGF0ZVwiLCBcInRpbWVcIiwgXCJkYXRlLXRpbWVcIiwgXCJkYXRlLWFuZC1vci10aW1lXCIsXG4gICAgICAgICAgICAgICBcInRpbWVzdGFtcFwiLCBcImJvb2xlYW5cIiwgXCJpbnRlZ2VyXCIsIFwiZmxvYXRcIiwgXCJ1dGMtb2Zmc2V0XCIsXG4gICAgICAgICAgICAgICBcImxhbmd1YWdlLXRhZ1wiXSxcbiAgICAgIGFsbG93WE5hbWU6IHRydWUsXG4gICAgICBhbGxvd0lhbmFUb2tlbjogdHJ1ZVxuICAgIH1cbiAgfTtcblxuICB2YXIgdmNhcmRQcm9wZXJ0aWVzID0gSUNBTC5oZWxwZXJzLmV4dGVuZChjb21tb25Qcm9wZXJ0aWVzLCB7XG4gICAgXCJhZHJcIjogeyBkZWZhdWx0VHlwZTogXCJ0ZXh0XCIsIHN0cnVjdHVyZWRWYWx1ZTogXCI7XCIsIG11bHRpVmFsdWU6IFwiLFwiIH0sXG4gICAgXCJhbm5pdmVyc2FyeVwiOiBERUZBVUxUX1RZUEVfREFURV9BTkRPUl9USU1FLFxuICAgIFwiYmRheVwiOiBERUZBVUxUX1RZUEVfREFURV9BTkRPUl9USU1FLFxuICAgIFwiY2FsYWRydXJpXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJjYWx1cmlcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcImNsaWVudHBpZG1hcFwiOiBERUZBVUxUX1RZUEVfVEVYVF9TVFJVQ1RVUkVELFxuICAgIFwiZW1haWxcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJmYnVybFwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwiZm5cIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJnZW5kZXJcIjogREVGQVVMVF9UWVBFX1RFWFRfU1RSVUNUVVJFRCxcbiAgICBcImdlb1wiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwiaW1wcFwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwia2V5XCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJraW5kXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwibGFuZ1wiOiB7IGRlZmF1bHRUeXBlOiBcImxhbmd1YWdlLXRhZ1wiIH0sXG4gICAgXCJsb2dvXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJtZW1iZXJcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcIm5cIjogeyBkZWZhdWx0VHlwZTogXCJ0ZXh0XCIsIHN0cnVjdHVyZWRWYWx1ZTogXCI7XCIsIG11bHRpVmFsdWU6IFwiLFwiIH0sXG4gICAgXCJuaWNrbmFtZVwiOiBERUZBVUxUX1RZUEVfVEVYVF9NVUxUSSxcbiAgICBcIm5vdGVcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJvcmdcIjogeyBkZWZhdWx0VHlwZTogXCJ0ZXh0XCIsIHN0cnVjdHVyZWRWYWx1ZTogXCI7XCIgfSxcbiAgICBcInBob3RvXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJyZWxhdGVkXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJyZXZcIjogeyBkZWZhdWx0VHlwZTogXCJ0aW1lc3RhbXBcIiB9LFxuICAgIFwicm9sZVwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcInNvdW5kXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJzb3VyY2VcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcInRlbFwiOiB7IGRlZmF1bHRUeXBlOiBcInVyaVwiLCBhbGxvd2VkVHlwZXM6IFtcInVyaVwiLCBcInRleHRcIl0gfSxcbiAgICBcInRpdGxlXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwidHpcIjogeyBkZWZhdWx0VHlwZTogXCJ0ZXh0XCIsIGFsbG93ZWRUeXBlczogW1widGV4dFwiLCBcInV0Yy1vZmZzZXRcIiwgXCJ1cmlcIl0gfSxcbiAgICBcInhtbFwiOiBERUZBVUxUX1RZUEVfVEVYVFxuICB9KTtcblxuICB2YXIgdmNhcmQzVmFsdWVzID0gSUNBTC5oZWxwZXJzLmV4dGVuZChjb21tb25WYWx1ZXMsIHtcbiAgICBiaW5hcnk6IGljYWxWYWx1ZXMuYmluYXJ5LFxuICAgIGRhdGU6IHZjYXJkVmFsdWVzLmRhdGUsXG4gICAgXCJkYXRlLXRpbWVcIjogdmNhcmRWYWx1ZXNbXCJkYXRlLXRpbWVcIl0sXG4gICAgXCJwaG9uZS1udW1iZXJcIjoge1xuICAgICAgLy8gVE9ET1xuICAgICAgLyogLi4uICovXG4gICAgfSxcbiAgICB1cmk6IGljYWxWYWx1ZXMudXJpLFxuICAgIHRleHQ6IGljYWxWYWx1ZXMudGV4dCxcbiAgICB0aW1lOiBpY2FsVmFsdWVzLnRpbWUsXG4gICAgdmNhcmQ6IGljYWxWYWx1ZXMudGV4dCxcbiAgICBcInV0Yy1vZmZzZXRcIjoge1xuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS5zdWJzdHIoMCwgNyk7XG4gICAgICB9LFxuXG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUuc3Vic3RyKDAsIDcpO1xuICAgICAgfSxcblxuICAgICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gSUNBTC5VdGNPZmZzZXQuZnJvbVN0cmluZyhhVmFsdWUpO1xuICAgICAgfSxcblxuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciB2Y2FyZDNQYXJhbXMgPSB7XG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIHZhbHVlVHlwZTogXCJ0ZXh0XCIsXG4gICAgICBtdWx0aVZhbHVlOiBcIixcIlxuICAgIH0sXG4gICAgXCJ2YWx1ZVwiOiB7XG4gICAgICAvLyBzaW5jZSB0aGUgdmFsdWUgaGVyZSBpcyBhICd0eXBlJyBsb3dlcmNhc2UgaXMgdXNlZC5cbiAgICAgIHZhbHVlczogW1widGV4dFwiLCBcInVyaVwiLCBcImRhdGVcIiwgXCJkYXRlLXRpbWVcIiwgXCJwaG9uZS1udW1iZXJcIiwgXCJ0aW1lXCIsXG4gICAgICAgICAgICAgICBcImJvb2xlYW5cIiwgXCJpbnRlZ2VyXCIsIFwiZmxvYXRcIiwgXCJ1dGMtb2Zmc2V0XCIsIFwidmNhcmRcIiwgXCJiaW5hcnlcIl0sXG4gICAgICBhbGxvd1hOYW1lOiB0cnVlLFxuICAgICAgYWxsb3dJYW5hVG9rZW46IHRydWVcbiAgICB9XG4gIH07XG5cbiAgdmFyIHZjYXJkM1Byb3BlcnRpZXMgPSBJQ0FMLmhlbHBlcnMuZXh0ZW5kKGNvbW1vblByb3BlcnRpZXMsIHtcbiAgICBmbjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgbjogeyBkZWZhdWx0VHlwZTogXCJ0ZXh0XCIsIHN0cnVjdHVyZWRWYWx1ZTogXCI7XCIsIG11bHRpVmFsdWU6IFwiLFwiIH0sXG4gICAgbmlja25hbWU6IERFRkFVTFRfVFlQRV9URVhUX01VTFRJLFxuICAgIHBob3RvOiB7IGRlZmF1bHRUeXBlOiBcImJpbmFyeVwiLCBhbGxvd2VkVHlwZXM6IFtcImJpbmFyeVwiLCBcInVyaVwiXSB9LFxuICAgIGJkYXk6IHtcbiAgICAgIGRlZmF1bHRUeXBlOiBcImRhdGUtdGltZVwiLFxuICAgICAgYWxsb3dlZFR5cGVzOiBbXCJkYXRlLXRpbWVcIiwgXCJkYXRlXCJdLFxuICAgICAgZGV0ZWN0VHlwZTogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiAoc3RyaW5nLmluZGV4T2YoJ1QnKSA9PT0gLTEpID8gJ2RhdGUnIDogJ2RhdGUtdGltZSc7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFkcjogeyBkZWZhdWx0VHlwZTogXCJ0ZXh0XCIsIHN0cnVjdHVyZWRWYWx1ZTogXCI7XCIsIG11bHRpVmFsdWU6IFwiLFwiIH0sXG4gICAgbGFiZWw6IERFRkFVTFRfVFlQRV9URVhULFxuXG4gICAgdGVsOiB7IGRlZmF1bHRUeXBlOiBcInBob25lLW51bWJlclwiIH0sXG4gICAgZW1haWw6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIG1haWxlcjogREVGQVVMVF9UWVBFX1RFWFQsXG5cbiAgICB0ejogeyBkZWZhdWx0VHlwZTogXCJ1dGMtb2Zmc2V0XCIsIGFsbG93ZWRUeXBlczogW1widXRjLW9mZnNldFwiLCBcInRleHRcIl0gfSxcbiAgICBnZW86IHsgZGVmYXVsdFR5cGU6IFwiZmxvYXRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiB9LFxuXG4gICAgdGl0bGU6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIHJvbGU6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIGxvZ286IHsgZGVmYXVsdFR5cGU6IFwiYmluYXJ5XCIsIGFsbG93ZWRUeXBlczogW1wiYmluYXJ5XCIsIFwidXJpXCJdIH0sXG4gICAgYWdlbnQ6IHsgZGVmYXVsdFR5cGU6IFwidmNhcmRcIiwgYWxsb3dlZFR5cGVzOiBbXCJ2Y2FyZFwiLCBcInRleHRcIiwgXCJ1cmlcIl0gfSxcbiAgICBvcmc6IERFRkFVTFRfVFlQRV9URVhUX1NUUlVDVFVSRUQsXG5cbiAgICBub3RlOiBERUZBVUxUX1RZUEVfVEVYVF9NVUxUSSxcbiAgICBwcm9kaWQ6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIHJldjoge1xuICAgICAgZGVmYXVsdFR5cGU6IFwiZGF0ZS10aW1lXCIsXG4gICAgICBhbGxvd2VkVHlwZXM6IFtcImRhdGUtdGltZVwiLCBcImRhdGVcIl0sXG4gICAgICBkZXRlY3RUeXBlOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIChzdHJpbmcuaW5kZXhPZignVCcpID09PSAtMSkgPyAnZGF0ZScgOiAnZGF0ZS10aW1lJztcbiAgICAgIH1cbiAgICB9LFxuICAgIFwic29ydC1zdHJpbmdcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgc291bmQ6IHsgZGVmYXVsdFR5cGU6IFwiYmluYXJ5XCIsIGFsbG93ZWRUeXBlczogW1wiYmluYXJ5XCIsIFwidXJpXCJdIH0sXG5cbiAgICBjbGFzczogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAga2V5OiB7IGRlZmF1bHRUeXBlOiBcImJpbmFyeVwiLCBhbGxvd2VkVHlwZXM6IFtcImJpbmFyeVwiLCBcInRleHRcIl0gfVxuICB9KTtcblxuICAvKipcbiAgICogaUNhbGVuZGFyIGRlc2lnbiBzZXRcbiAgICogQHR5cGUge0lDQUwuZGVzaWduLmRlc2lnblNldH1cbiAgICovXG4gIHZhciBpY2FsU2V0ID0ge1xuICAgIHZhbHVlOiBpY2FsVmFsdWVzLFxuICAgIHBhcmFtOiBpY2FsUGFyYW1zLFxuICAgIHByb3BlcnR5OiBpY2FsUHJvcGVydGllc1xuICB9O1xuXG4gIC8qKlxuICAgKiB2Q2FyZCA0LjAgZGVzaWduIHNldFxuICAgKiBAdHlwZSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fVxuICAgKi9cbiAgdmFyIHZjYXJkU2V0ID0ge1xuICAgIHZhbHVlOiB2Y2FyZFZhbHVlcyxcbiAgICBwYXJhbTogdmNhcmRQYXJhbXMsXG4gICAgcHJvcGVydHk6IHZjYXJkUHJvcGVydGllc1xuICB9O1xuXG4gIC8qKlxuICAgKiB2Q2FyZCAzLjAgZGVzaWduIHNldFxuICAgKiBAdHlwZSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fVxuICAgKi9cbiAgdmFyIHZjYXJkM1NldCA9IHtcbiAgICB2YWx1ZTogdmNhcmQzVmFsdWVzLFxuICAgIHBhcmFtOiB2Y2FyZDNQYXJhbXMsXG4gICAgcHJvcGVydHk6IHZjYXJkM1Byb3BlcnRpZXNcbiAgfTtcblxuICAvKipcbiAgICogVGhlIGRlc2lnbiBkYXRhLCB1c2VkIGJ5IHRoZSBwYXJzZXIgdG8gZGV0ZXJtaW5lIHR5cGVzIGZvciBwcm9wZXJ0aWVzIGFuZFxuICAgKiBvdGhlciBtZXRhZGF0YSBuZWVkZWQgdG8gcHJvZHVjZSBjb3JyZWN0IGpDYXJkL2pDYWwgZGF0YS5cbiAgICpcbiAgICogQGFsaWFzIElDQUwuZGVzaWduXG4gICAqIEBuYW1lc3BhY2VcbiAgICovXG4gIHZhciBkZXNpZ24gPSB7XG4gICAgLyoqXG4gICAgICogQSBkZXNpZ25TZXQgZGVzY3JpYmVzIHZhbHVlLCBwYXJhbWV0ZXIgYW5kIHByb3BlcnR5IGRhdGEuIEl0IGlzIHVzZWQgYnlcbiAgICAgKiB0aGVyIHBhcnNlciBhbmQgc3RyaW5naWZpZXIgaW4gY29tcG9uZW50cyBhbmQgcHJvcGVydGllcyB0byBkZXRlcm1pbmUgdGhleVxuICAgICAqIHNob3VsZCBiZSByZXByZXNlbnRlZC5cbiAgICAgKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IGRlc2lnblNldFxuICAgICAqIEBtZW1iZXJPZiBJQ0FMLmRlc2lnblxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSB2YWx1ZSAgICAgICBEZWZpbml0aW9ucyBmb3IgdmFsdWUgdHlwZXMsIGtleXMgYXJlIHR5cGUgbmFtZXNcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gcGFyYW0gICAgICAgRGVmaW5pdGlvbnMgZm9yIHBhcmFtcywga2V5cyBhcmUgcGFyYW0gbmFtZXNcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gcHJvcGVydHkgICAgRGVmaW50aW9ucyBmb3IgcHJvcGVydGllcywga2V5cyBhcmUgcHJvcGVydHkgbmFtZXNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENhbiBiZSBzZXQgdG8gZmFsc2UgdG8gbWFrZSB0aGUgcGFyc2VyIG1vcmUgbGVuaWVudC5cbiAgICAgKi9cbiAgICBzdHJpY3Q6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBzZXQgZm9yIG5ldyBwcm9wZXJ0aWVzIGFuZCBjb21wb25lbnRzIGlmIG5vbmUgaXMgc3BlY2lmaWVkLlxuICAgICAqIEB0eXBlIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9XG4gICAgICovXG4gICAgZGVmYXVsdFNldDogaWNhbFNldCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHR5cGUgZm9yIHVua25vd24gcHJvcGVydGllc1xuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZGVmYXVsdFR5cGU6ICd1bmtub3duJyxcblxuICAgIC8qKlxuICAgICAqIEhvbGRzIHRoZSBkZXNpZ24gc2V0IGZvciBrbm93biB0b3AtbGV2ZWwgY29tcG9uZW50c1xuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0lDQUwuZGVzaWduLmRlc2lnblNldH0gdmNhcmQgICAgICAgdkNhcmQgVkNBUkRcbiAgICAgKiBAcHJvcGVydHkge0lDQUwuZGVzaWduLmRlc2lnblNldH0gdmV2ZW50ICAgICAgaUNhbGVuZGFyIFZFVkVOVFxuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSB2dG9kbyAgICAgICBpQ2FsZW5kYXIgVlRPRE9cbiAgICAgKiBAcHJvcGVydHkge0lDQUwuZGVzaWduLmRlc2lnblNldH0gdmpvdXJuYWwgICAgaUNhbGVuZGFyIFZKT1VSTkFMXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IHZhbGFybSAgICAgIGlDYWxlbmRhciBWQUxBUk1cbiAgICAgKiBAcHJvcGVydHkge0lDQUwuZGVzaWduLmRlc2lnblNldH0gdnRpbWV6b25lICAgaUNhbGVuZGFyIFZUSU1FWk9ORVxuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSBkYXlsaWdodCAgICBpQ2FsZW5kYXIgREFZTElHSFRcbiAgICAgKiBAcHJvcGVydHkge0lDQUwuZGVzaWduLmRlc2lnblNldH0gc3RhbmRhcmQgICAgaUNhbGVuZGFyIFNUQU5EQVJEXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBwcm9wZXJ0eU5hbWUgPSAnZm4nO1xuICAgICAqIHZhciBjb21wb25lbnREZXNpZ24gPSBJQ0FMLmRlc2lnbi5jb21wb25lbnRzLnZjYXJkO1xuICAgICAqIHZhciBwcm9wZXJ0eURldGFpbHMgPSBjb21wb25lbnREZXNpZ24ucHJvcGVydHlbcHJvcGVydHlOYW1lXTtcbiAgICAgKiBpZiAocHJvcGVydHlEZXRhaWxzLmRlZmF1bHRUeXBlID09ICd0ZXh0Jykge1xuICAgICAqICAgLy8gWWVwLCBzdXJlIGlzLi4uXG4gICAgICogfVxuICAgICAqL1xuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIHZjYXJkOiB2Y2FyZFNldCxcbiAgICAgIHZjYXJkMzogdmNhcmQzU2V0LFxuICAgICAgdmV2ZW50OiBpY2FsU2V0LFxuICAgICAgdnRvZG86IGljYWxTZXQsXG4gICAgICB2am91cm5hbDogaWNhbFNldCxcbiAgICAgIHZhbGFybTogaWNhbFNldCxcbiAgICAgIHZ0aW1lem9uZTogaWNhbFNldCxcbiAgICAgIGRheWxpZ2h0OiBpY2FsU2V0LFxuICAgICAgc3RhbmRhcmQ6IGljYWxTZXRcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVzaWduIHNldCBmb3IgaUNhbGVuZGFyIChyZmM1NTQ1L3JmYzcyNjUpIGNvbXBvbmVudHMuXG4gICAgICogQHR5cGUge0lDQUwuZGVzaWduLmRlc2lnblNldH1cbiAgICAgKi9cbiAgICBpY2FsZW5kYXI6IGljYWxTZXQsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVzaWduIHNldCBmb3IgdkNhcmQgKHJmYzYzNTAvcmZjNzA5NSkgY29tcG9uZW50cy5cbiAgICAgKiBAdHlwZSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fVxuICAgICAqL1xuICAgIHZjYXJkOiB2Y2FyZFNldCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZXNpZ24gc2V0IGZvciB2Q2FyZCAocmZjMjQyNS9yZmMyNDI2L3JmYzcwOTUpIGNvbXBvbmVudHMuXG4gICAgICogQHR5cGUge0lDQUwuZGVzaWduLmRlc2lnblNldH1cbiAgICAgKi9cbiAgICB2Y2FyZDM6IHZjYXJkM1NldCxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRlc2lnbiBzZXQgZm9yIHRoZSBnaXZlbiBjb21wb25lbnQgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnROYW1lICAgICAgICBUaGUgbmFtZSBvZiB0aGUgY29tcG9uZW50XG4gICAgICogQHJldHVybiB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSAgICAgIFRoZSBkZXNpZ24gc2V0IGZvciB0aGUgY29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0RGVzaWduU2V0OiBmdW5jdGlvbihjb21wb25lbnROYW1lKSB7XG4gICAgICB2YXIgaXNJbkRlc2lnbiA9IGNvbXBvbmVudE5hbWUgJiYgY29tcG9uZW50TmFtZSBpbiBkZXNpZ24uY29tcG9uZW50cztcbiAgICAgIHJldHVybiBpc0luRGVzaWduID8gZGVzaWduLmNvbXBvbmVudHNbY29tcG9uZW50TmFtZV0gOiBkZXNpZ24uZGVmYXVsdFNldDtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGRlc2lnbjtcbn0oKSk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG5cbi8qKlxuICogQ29udGFpbnMgdmFyaW91cyBmdW5jdGlvbnMgdG8gY29udmVydCBqQ2FsIGFuZCBqQ2FyZCBkYXRhIGJhY2sgaW50b1xuICogaUNhbGVuZGFyIGFuZCB2Q2FyZC5cbiAqIEBuYW1lc3BhY2VcbiAqL1xuSUNBTC5zdHJpbmdpZnkgPSAoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgTElORV9FTkRJTkcgPSAnXFxyXFxuJztcbiAgdmFyIERFRkFVTFRfVkFMVUVfVFlQRSA9ICd1bmtub3duJztcblxuICB2YXIgZGVzaWduID0gSUNBTC5kZXNpZ247XG4gIHZhciBoZWxwZXJzID0gSUNBTC5oZWxwZXJzO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgZnVsbCBqQ2FsL2pDYXJkIGFycmF5IGludG8gYSBpQ2FsZW5kYXIvdkNhcmQgc3RyaW5nLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gSUNBTC5zdHJpbmdpZnlcbiAgICogQHZhcmlhdGlvbiBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fSBqQ2FsICAgIFRoZSBqQ2FsL2pDYXJkIGRvY3VtZW50XG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgVGhlIHN0cmluZ2lmaWVkIGlDYWxlbmRhci92Q2FyZCBkb2N1bWVudFxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5naWZ5KGpDYWwpIHtcbiAgICBpZiAodHlwZW9mIGpDYWxbMF0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgLy8gVGhpcyBpcyBhIHNpbmdsZSBjb21wb25lbnRcbiAgICAgIGpDYWwgPSBbakNhbF07XG4gICAgfVxuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBqQ2FsLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZXN1bHQgKz0gc3RyaW5naWZ5LmNvbXBvbmVudChqQ2FsW2ldKSArIExJTkVfRU5ESU5HO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYW4gakNhbCBjb21wb25lbnQgYXJyYXkgaW50byBhIElDQUwgc3RyaW5nLlxuICAgKiBSZWN1cnNpdmUgd2lsbCByZXNvbHZlIHN1Yi1jb21wb25lbnRzLlxuICAgKlxuICAgKiBFeGFjdCBjb21wb25lbnQvcHJvcGVydHkgb3JkZXIgaXMgbm90IHNhdmVkIGFsbFxuICAgKiBwcm9wZXJ0aWVzIHdpbGwgY29tZSBiZWZvcmUgc3ViY29tcG9uZW50cy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwuc3RyaW5naWZ5LmNvbXBvbmVudFxuICAgKiBAcGFyYW0ge0FycmF5fSBjb21wb25lbnRcbiAgICogICAgICAgIGpDYWwvakNhcmQgZnJhZ21lbnQgb2YgYSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IGRlc2lnblNldFxuICAgKiAgICAgICAgVGhlIGRlc2lnbiBkYXRhIHRvIHVzZSBmb3IgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICBUaGUgaUNhbGVuZGFyL3ZDYXJkIHN0cmluZ1xuICAgKi9cbiAgc3RyaW5naWZ5LmNvbXBvbmVudCA9IGZ1bmN0aW9uKGNvbXBvbmVudCwgZGVzaWduU2V0KSB7XG4gICAgdmFyIG5hbWUgPSBjb21wb25lbnRbMF0udG9VcHBlckNhc2UoKTtcbiAgICB2YXIgcmVzdWx0ID0gJ0JFR0lOOicgKyBuYW1lICsgTElORV9FTkRJTkc7XG5cbiAgICB2YXIgcHJvcHMgPSBjb21wb25lbnRbMV07XG4gICAgdmFyIHByb3BJZHggPSAwO1xuICAgIHZhciBwcm9wTGVuID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgdmFyIGRlc2lnblNldE5hbWUgPSBjb21wb25lbnRbMF07XG4gICAgLy8gcmZjNjM1MCByZXF1aXJlcyB0aGF0IGluIHZDYXJkIDQuMCB0aGUgZmlyc3QgY29tcG9uZW50IGlzIHRoZSBWRVJTSU9OXG4gICAgLy8gY29tcG9uZW50IHdpdGggYXMgdmFsdWUgNC4wLCBub3RlIHRoYXQgMy4wIGRvZXMgbm90IGhhdmUgdGhpcyByZXF1aXJlbWVudC5cbiAgICBpZiAoZGVzaWduU2V0TmFtZSA9PT0gJ3ZjYXJkJyAmJiBjb21wb25lbnRbMV0ubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgIShjb21wb25lbnRbMV1bMF1bMF0gPT09IFwidmVyc2lvblwiICYmIGNvbXBvbmVudFsxXVswXVszXSA9PT0gXCI0LjBcIikpIHtcbiAgICAgIGRlc2lnblNldE5hbWUgPSBcInZjYXJkM1wiO1xuICAgIH1cbiAgICBkZXNpZ25TZXQgPSBkZXNpZ25TZXQgfHwgZGVzaWduLmdldERlc2lnblNldChkZXNpZ25TZXROYW1lKTtcblxuICAgIGZvciAoOyBwcm9wSWR4IDwgcHJvcExlbjsgcHJvcElkeCsrKSB7XG4gICAgICByZXN1bHQgKz0gc3RyaW5naWZ5LnByb3BlcnR5KHByb3BzW3Byb3BJZHhdLCBkZXNpZ25TZXQpICsgTElORV9FTkRJTkc7XG4gICAgfVxuXG4gICAgLy8gSWdub3JlIHN1YmNvbXBvbmVudHMgaWYgbm9uZSBleGlzdCwgZS5nLiBpbiB2Q2FyZC5cbiAgICB2YXIgY29tcHMgPSBjb21wb25lbnRbMl0gfHwgW107XG4gICAgdmFyIGNvbXBJZHggPSAwO1xuICAgIHZhciBjb21wTGVuID0gY29tcHMubGVuZ3RoO1xuXG4gICAgZm9yICg7IGNvbXBJZHggPCBjb21wTGVuOyBjb21wSWR4KyspIHtcbiAgICAgIHJlc3VsdCArPSBzdHJpbmdpZnkuY29tcG9uZW50KGNvbXBzW2NvbXBJZHhdLCBkZXNpZ25TZXQpICsgTElORV9FTkRJTkc7XG4gICAgfVxuXG4gICAgcmVzdWx0ICs9ICdFTkQ6JyArIG5hbWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydHMgYSBzaW5nbGUgakNhbC9qQ2FyZCBwcm9wZXJ0eSB0byBhIGlDYWxlbmRhci92Q2FyZCBzdHJpbmcuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnN0cmluZ2lmeS5wcm9wZXJ0eVxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wZXJ0eVxuICAgKiAgICAgICAgakNhbC9qQ2FyZCBwcm9wZXJ0eSBhcnJheVxuICAgKiBAcGFyYW0ge0lDQUwuZGVzaWduLmRlc2lnblNldH0gZGVzaWduU2V0XG4gICAqICAgICAgICBUaGUgZGVzaWduIGRhdGEgdG8gdXNlIGZvciB0aGlzIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbm9Gb2xkXG4gICAqICAgICAgICBJZiB0cnVlLCB0aGUgbGluZSBpcyBub3QgZm9sZGVkXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgVGhlIGlDYWxlbmRhci92Q2FyZCBzdHJpbmdcbiAgICovXG4gIHN0cmluZ2lmeS5wcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3BlcnR5LCBkZXNpZ25TZXQsIG5vRm9sZCkge1xuICAgIHZhciBuYW1lID0gcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKTtcbiAgICB2YXIganNOYW1lID0gcHJvcGVydHlbMF07XG4gICAgdmFyIHBhcmFtcyA9IHByb3BlcnR5WzFdO1xuXG4gICAgdmFyIGxpbmUgPSBuYW1lO1xuXG4gICAgdmFyIHBhcmFtTmFtZTtcbiAgICBmb3IgKHBhcmFtTmFtZSBpbiBwYXJhbXMpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHBhcmFtc1twYXJhbU5hbWVdO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShwYXJhbU5hbWUpKSB7XG4gICAgICAgIHZhciBtdWx0aVZhbHVlID0gKHBhcmFtTmFtZSBpbiBkZXNpZ25TZXQucGFyYW0pICYmIGRlc2lnblNldC5wYXJhbVtwYXJhbU5hbWVdLm11bHRpVmFsdWU7XG4gICAgICAgIGlmIChtdWx0aVZhbHVlICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKGRlc2lnblNldC5wYXJhbVtwYXJhbU5hbWVdLm11bHRpVmFsdWVTZXBhcmF0ZURRdW90ZSkge1xuICAgICAgICAgICAgbXVsdGlWYWx1ZSA9ICdcIicgKyBtdWx0aVZhbHVlICsgJ1wiJztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoc3RyaW5naWZ5Ll9yZmM2ODY4VW5lc2NhcGUpO1xuICAgICAgICAgIHZhbHVlID0gc3RyaW5naWZ5Lm11bHRpVmFsdWUodmFsdWUsIG11bHRpVmFsdWUsIFwidW5rbm93blwiLCBudWxsLCBkZXNpZ25TZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gc3RyaW5naWZ5Ll9yZmM2ODY4VW5lc2NhcGUodmFsdWUpO1xuICAgICAgICB9XG5cblxuICAgICAgICBsaW5lICs9ICc7JyArIHBhcmFtTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBsaW5lICs9ICc9JyArIHN0cmluZ2lmeS5wcm9wZXJ0eVZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvcGVydHkubGVuZ3RoID09PSAzKSB7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gdmFsdWVzLCB3ZSBtdXN0IGFzc3VtZSBhIGJsYW5rIHZhbHVlXG4gICAgICByZXR1cm4gbGluZSArICc6JztcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVUeXBlID0gcHJvcGVydHlbMl07XG5cbiAgICBpZiAoIWRlc2lnblNldCkge1xuICAgICAgZGVzaWduU2V0ID0gZGVzaWduLmRlZmF1bHRTZXQ7XG4gICAgfVxuXG4gICAgdmFyIHByb3BEZXRhaWxzO1xuICAgIHZhciBtdWx0aVZhbHVlID0gZmFsc2U7XG4gICAgdmFyIHN0cnVjdHVyZWRWYWx1ZSA9IGZhbHNlO1xuICAgIHZhciBpc0RlZmF1bHQgPSBmYWxzZTtcblxuICAgIGlmIChqc05hbWUgaW4gZGVzaWduU2V0LnByb3BlcnR5KSB7XG4gICAgICBwcm9wRGV0YWlscyA9IGRlc2lnblNldC5wcm9wZXJ0eVtqc05hbWVdO1xuXG4gICAgICBpZiAoJ211bHRpVmFsdWUnIGluIHByb3BEZXRhaWxzKSB7XG4gICAgICAgIG11bHRpVmFsdWUgPSBwcm9wRGV0YWlscy5tdWx0aVZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoKCdzdHJ1Y3R1cmVkVmFsdWUnIGluIHByb3BEZXRhaWxzKSAmJiBBcnJheS5pc0FycmF5KHByb3BlcnR5WzNdKSkge1xuICAgICAgICBzdHJ1Y3R1cmVkVmFsdWUgPSBwcm9wRGV0YWlscy5zdHJ1Y3R1cmVkVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgnZGVmYXVsdFR5cGUnIGluIHByb3BEZXRhaWxzKSB7XG4gICAgICAgIGlmICh2YWx1ZVR5cGUgPT09IHByb3BEZXRhaWxzLmRlZmF1bHRUeXBlKSB7XG4gICAgICAgICAgaXNEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHZhbHVlVHlwZSA9PT0gREVGQVVMVF9WQUxVRV9UWVBFKSB7XG4gICAgICAgICAgaXNEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWVUeXBlID09PSBERUZBVUxUX1ZBTFVFX1RZUEUpIHtcbiAgICAgICAgaXNEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwdXNoIHRoZSBWQUxVRSBwcm9wZXJ0eSBpZiB0eXBlIGlzIG5vdCB0aGUgZGVmYXVsdFxuICAgIC8vIGZvciB0aGUgY3VycmVudCBwcm9wZXJ0eS5cbiAgICBpZiAoIWlzRGVmYXVsdCkge1xuICAgICAgLy8gdmFsdWUgd2lsbCBuZXZlciBjb250YWluIDsvOi8sIHNvIHdlIGRvbid0IGVzY2FwZSBpdCBoZXJlLlxuICAgICAgbGluZSArPSAnO1ZBTFVFPScgKyB2YWx1ZVR5cGUudG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICBsaW5lICs9ICc6JztcblxuICAgIGlmIChtdWx0aVZhbHVlICYmIHN0cnVjdHVyZWRWYWx1ZSkge1xuICAgICAgbGluZSArPSBzdHJpbmdpZnkubXVsdGlWYWx1ZShcbiAgICAgICAgcHJvcGVydHlbM10sIHN0cnVjdHVyZWRWYWx1ZSwgdmFsdWVUeXBlLCBtdWx0aVZhbHVlLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKG11bHRpVmFsdWUpIHtcbiAgICAgIGxpbmUgKz0gc3RyaW5naWZ5Lm11bHRpVmFsdWUoXG4gICAgICAgIHByb3BlcnR5LnNsaWNlKDMpLCBtdWx0aVZhbHVlLCB2YWx1ZVR5cGUsIG51bGwsIGRlc2lnblNldCwgZmFsc2VcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChzdHJ1Y3R1cmVkVmFsdWUpIHtcbiAgICAgIGxpbmUgKz0gc3RyaW5naWZ5Lm11bHRpVmFsdWUoXG4gICAgICAgIHByb3BlcnR5WzNdLCBzdHJ1Y3R1cmVkVmFsdWUsIHZhbHVlVHlwZSwgbnVsbCwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWVcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmUgKz0gc3RyaW5naWZ5LnZhbHVlKHByb3BlcnR5WzNdLCB2YWx1ZVR5cGUsIGRlc2lnblNldCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBub0ZvbGQgPyBsaW5lIDogSUNBTC5oZWxwZXJzLmZvbGRsaW5lKGxpbmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGVzY2FwaW5nIG9mIHByb3BlcnR5IHZhbHVlcyB0aGF0IG1heSBjb250YWluOlxuICAgKlxuICAgKiAgICBDT0xPTiAoOiksIFNFTUlDT0xPTiAoOyksIG9yIENPTU1BICgsKVxuICAgKlxuICAgKiBJZiBhbnkgb2YgdGhlIGFib3ZlIGFyZSBwcmVzZW50IHRoZSByZXN1bHQgaXMgd3JhcHBlZFxuICAgKiBpbiBkb3VibGUgcXVvdGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gSUNBTC5zdHJpbmdpZnkucHJvcGVydHlWYWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgICAgICBSYXcgcHJvcGVydHkgdmFsdWVcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgR2l2ZW4gb3IgZXNjYXBlZCB2YWx1ZSB3aGVuIG5lZWRlZFxuICAgKi9cbiAgc3RyaW5naWZ5LnByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXG4gICAgaWYgKChoZWxwZXJzLnVuZXNjYXBlZEluZGV4T2YodmFsdWUsICcsJykgPT09IC0xKSAmJlxuICAgICAgICAoaGVscGVycy51bmVzY2FwZWRJbmRleE9mKHZhbHVlLCAnOicpID09PSAtMSkgJiZcbiAgICAgICAgKGhlbHBlcnMudW5lc2NhcGVkSW5kZXhPZih2YWx1ZSwgJzsnKSA9PT0gLTEpKSB7XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gJ1wiJyArIHZhbHVlICsgJ1wiJztcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydHMgYW4gYXJyYXkgb2YgaWNhbCB2YWx1ZXMgaW50byBhIHNpbmdsZVxuICAgKiBzdHJpbmcgYmFzZWQgb24gYSB0eXBlIGFuZCBhIGRlbGltaXRlciB2YWx1ZSAobGlrZSBcIixcIikuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnN0cmluZ2lmeS5tdWx0aVZhbHVlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyAgICAgIExpc3Qgb2YgdmFsdWVzIHRvIGNvbnZlcnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRlbGltICAgICAgVXNlZCB0byBqb2luIHRoZSB2YWx1ZXMgKFwiLFwiLCBcIjtcIiwgXCI6XCIpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlICAgICAgIExvd2VjYXNlIGljYWwgdmFsdWUgdHlwZVxuICAgKiAgICAgICAgKGxpa2UgYm9vbGVhbiwgZGF0ZS10aW1lLCBldGMuLilcbiAgICogQHBhcmFtIHs/U3RyaW5nfSBpbm5lck11bHRpIElmIHNldCwgZWFjaCB2YWx1ZSB3aWxsIGFnYWluIGJlIHByb2Nlc3NlZFxuICAgKiAgICAgICAgVXNlZCBmb3Igc3RydWN0dXJlZCB2YWx1ZXNcbiAgICogQHBhcmFtIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IGRlc2lnblNldFxuICAgKiAgICAgICAgVGhlIGRlc2lnbiBkYXRhIHRvIHVzZSBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBpQ2FsZW5kYXIvdkNhcmQgc3RyaW5nIGZvciB2YWx1ZVxuICAgKi9cbiAgc3RyaW5naWZ5Lm11bHRpVmFsdWUgPSBmdW5jdGlvbih2YWx1ZXMsIGRlbGltLCB0eXBlLCBpbm5lck11bHRpLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoaW5uZXJNdWx0aSAmJiBBcnJheS5pc0FycmF5KHZhbHVlc1tpXSkpIHtcbiAgICAgICAgcmVzdWx0ICs9IHN0cmluZ2lmeS5tdWx0aVZhbHVlKHZhbHVlc1tpXSwgaW5uZXJNdWx0aSwgdHlwZSwgbnVsbCwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ICs9IHN0cmluZ2lmeS52YWx1ZSh2YWx1ZXNbaV0sIHR5cGUsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgIT09IChsZW4gLSAxKSkge1xuICAgICAgICByZXN1bHQgKz0gZGVsaW07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogUHJvY2Vzc2VzIGEgc2luZ2xlIGljYWwgdmFsdWUgcnVucyB0aGUgYXNzb2NpYXRlZCBcInRvSUNBTFwiIG1ldGhvZCBmcm9tIHRoZVxuICAgKiBkZXNpZ24gdmFsdWUgdHlwZSBpZiBhdmFpbGFibGUgdG8gY29udmVydCB0aGUgdmFsdWUuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnN0cmluZ2lmeS52YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbHVlICAgICAgIEEgZm9ybWF0dGVkIHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlICAgICAgICAgICAgICAgTG93ZXJjYXNlIGlDYWxlbmRhci92Q2FyZCB2YWx1ZSB0eXBlXG4gICAqICAobGlrZSBib29sZWFuLCBkYXRlLXRpbWUsIGV0Yy4uKVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgICAgICAgIGlDYWxlbmRhci92Q2FyZCB2YWx1ZSBmb3Igc2luZ2xlIHZhbHVlXG4gICAqL1xuICBzdHJpbmdpZnkudmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgdHlwZSwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpIHtcbiAgICBpZiAodHlwZSBpbiBkZXNpZ25TZXQudmFsdWUgJiYgJ3RvSUNBTCcgaW4gZGVzaWduU2V0LnZhbHVlW3R5cGVdKSB7XG4gICAgICByZXR1cm4gZGVzaWduU2V0LnZhbHVlW3R5cGVdLnRvSUNBTCh2YWx1ZSwgc3RydWN0dXJlZFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBoZWxwZXIgZm9yIHJmYzY4NjguIEV4cG9zaW5nIHRoaXMgb24gSUNBTC5zdHJpbmdpZnkgc28gdGhhdFxuICAgKiBoYWNrZXJzIGNhbiBkaXNhYmxlIHRoZSByZmM2ODY4IHBhcnNpbmcgaWYgdGhlIHJlYWxseSBuZWVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsICAgICAgICBUaGUgdmFsdWUgdG8gdW5lc2NhcGVcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgVGhlIGVzY2FwZWQgdmFsdWVcbiAgICovXG4gIHN0cmluZ2lmeS5fcmZjNjg2OFVuZXNjYXBlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuIHZhbC5yZXBsYWNlKC9bXFxuXlwiXS9nLCBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gUkZDNjg2OF9SRVBMQUNFX01BUFt4XTtcbiAgICB9KTtcbiAgfTtcbiAgdmFyIFJGQzY4NjhfUkVQTEFDRV9NQVAgPSB7ICdcIic6IFwiXidcIiwgXCJcXG5cIjogXCJeblwiLCBcIl5cIjogXCJeXlwiIH07XG5cbiAgcmV0dXJuIHN0cmluZ2lmeTtcbn0oKSk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG5cbi8qKlxuICogQ29udGFpbnMgdmFyaW91cyBmdW5jdGlvbnMgdG8gcGFyc2UgaUNhbGVuZGFyIGFuZCB2Q2FyZCBkYXRhLlxuICogQG5hbWVzcGFjZVxuICovXG5JQ0FMLnBhcnNlID0gKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIENIQVIgPSAvW14gXFx0XS87XG4gIHZhciBNVUxUSVZBTFVFX0RFTElNSVRFUiA9ICcsJztcbiAgdmFyIFZBTFVFX0RFTElNSVRFUiA9ICc6JztcbiAgdmFyIFBBUkFNX0RFTElNSVRFUiA9ICc7JztcbiAgdmFyIFBBUkFNX05BTUVfREVMSU1JVEVSID0gJz0nO1xuICB2YXIgREVGQVVMVF9WQUxVRV9UWVBFID0gJ3Vua25vd24nO1xuICB2YXIgREVGQVVMVF9QQVJBTV9UWVBFID0gJ3RleHQnO1xuXG4gIHZhciBkZXNpZ24gPSBJQ0FMLmRlc2lnbjtcbiAgdmFyIGhlbHBlcnMgPSBJQ0FMLmhlbHBlcnM7XG5cbiAgLyoqXG4gICAqIEFuIGVycm9yIHRoYXQgb2NjdXJyZWQgZHVyaW5nIHBhcnNpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlICAgICAgICBUaGUgZXJyb3IgbWVzc2FnZVxuICAgKiBAbWVtYmVyb2YgSUNBTC5wYXJzZVxuICAgKiBAZXh0ZW5kcyB7RXJyb3J9XG4gICAqIEBjbGFzc1xuICAgKi9cbiAgZnVuY3Rpb24gUGFyc2VyRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5uYW1lID0gJ1BhcnNlckVycm9yJztcblxuICAgIHRyeSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5zdGFjaykge1xuICAgICAgICB2YXIgc3BsaXQgPSBlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgc3BsaXQuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5zdGFjayA9IHNwbGl0LmpvaW4oJ1xcbicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFBhcnNlckVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICAvKipcbiAgICogUGFyc2VzIGlDYWxlbmRhciBvciB2Q2FyZCBkYXRhIGludG8gYSByYXcgakNhbCBvYmplY3QuIENvbnN1bHRcbiAgICogZG9jdW1lbnRhdGlvbiBvbiB0aGUge0B0dXRvcmlhbCBsYXllcnN8bGF5ZXJzIG9mIHBhcnNpbmd9IGZvciBtb3JlXG4gICAqIGRldGFpbHMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlXG4gICAqIEB2YXJpYXRpb24gZnVuY3Rpb25cbiAgICogQHRvZG8gRml4IHRoZSBBUEkgdG8gYmUgbW9yZSBjbGVhciBvbiB0aGUgcmV0dXJuIHR5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0ICAgICAgVGhlIHN0cmluZyBkYXRhIHRvIHBhcnNlXG4gICAqIEByZXR1cm4ge09iamVjdHxPYmplY3RbXX0gIEEgc2luZ2xlIGpDYWwgb2JqZWN0LCBvciBhbiBhcnJheSB0aGVyZW9mXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZXIoaW5wdXQpIHtcbiAgICB2YXIgc3RhdGUgPSB7fTtcbiAgICB2YXIgcm9vdCA9IHN0YXRlLmNvbXBvbmVudCA9IFtdO1xuXG4gICAgc3RhdGUuc3RhY2sgPSBbcm9vdF07XG5cbiAgICBwYXJzZXIuX2VhY2hMaW5lKGlucHV0LCBmdW5jdGlvbihlcnIsIGxpbmUpIHtcbiAgICAgIHBhcnNlci5faGFuZGxlQ29udGVudExpbmUobGluZSwgc3RhdGUpO1xuICAgIH0pO1xuXG5cbiAgICAvLyB3aGVuIHRoZXJlIGFyZSBzdGlsbCBpdGVtcyBvbiB0aGUgc3RhY2tcbiAgICAvLyB0aHJvdyBhIGZhdGFsIGVycm9yLCBhIGNvbXBvbmVudCB3YXMgbm90IGNsb3NlZFxuICAgIC8vIGNvcnJlY3RseSBpbiB0aGF0IGNhc2UuXG4gICAgaWYgKHN0YXRlLnN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZXJFcnJvcihcbiAgICAgICAgJ2ludmFsaWQgaWNhbCBib2R5LiBjb21wb25lbnQgYmVnYW4gYnV0IGRpZCBub3QgZW5kJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0ZSA9IG51bGw7XG5cbiAgICByZXR1cm4gKHJvb3QubGVuZ3RoID09IDEgPyByb290WzBdIDogcm9vdCk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYW4gaUNhbGVuZGFyIHByb3BlcnR5IHZhbHVlIGludG8gdGhlIGpDYWwgZm9yIGEgc2luZ2xlIHByb3BlcnR5XG4gICAqXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLnByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICogICBUaGUgaUNhbGVuZGFyIHByb3BlcnR5IHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0lDQUwuZGVzaWduLmRlc2lnblNldD19IGRlc2lnblNldFxuICAgKiAgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgcHJvcGVydHlcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgIFRoZSBqQ2FsIE9iamVjdCBjb250YWluaW5nIHRoZSBwcm9wZXJ0eVxuICAgKi9cbiAgcGFyc2VyLnByb3BlcnR5ID0gZnVuY3Rpb24oc3RyLCBkZXNpZ25TZXQpIHtcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBjb21wb25lbnQ6IFtbXSwgW11dLFxuICAgICAgZGVzaWduU2V0OiBkZXNpZ25TZXQgfHwgZGVzaWduLmRlZmF1bHRTZXRcbiAgICB9O1xuICAgIHBhcnNlci5faGFuZGxlQ29udGVudExpbmUoc3RyLCBzdGF0ZSk7XG4gICAgcmV0dXJuIHN0YXRlLmNvbXBvbmVudFsxXVswXTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHBhcnNlIGEgY29tcG9uZW50LiBZb3UgY2FuIHVzZSBJQ0FMLnBhcnNlKCkgZGlyZWN0bHlcbiAgICogaW5zdGVhZC5cbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwucGFyc2UuY29tcG9uZW50XG4gICAqIEBzZWUgSUNBTC5wYXJzZShmdW5jdGlvbilcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAgICBUaGUgaUNhbGVuZGFyIGNvbXBvbmVudCBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICBUaGUgakNhbCBPYmplY3QgY29udGFpbmluZyB0aGUgY29tcG9uZW50XG4gICAqL1xuICBwYXJzZXIuY29tcG9uZW50ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHBhcnNlcihzdHIpO1xuICB9O1xuXG4gIC8vIGNsYXNzZXMgJiBjb25zdGFudHNcbiAgcGFyc2VyLlBhcnNlckVycm9yID0gUGFyc2VyRXJyb3I7XG5cbiAgLyoqXG4gICAqIFRoZSBzdGF0ZSBmb3IgcGFyc2luZyBjb250ZW50IGxpbmVzIGZyb20gYW4gaUNhbGVuZGFyL3ZDYXJkIHN0cmluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1lbWJlcm9mIElDQUwucGFyc2VcbiAgICogQHR5cGVkZWYge09iamVjdH0gcGFyc2VyU3RhdGVcbiAgICogQHByb3BlcnR5IHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IGRlc2lnblNldCAgICBUaGUgZGVzaWduIHNldCB0byB1c2UgZm9yIHBhcnNpbmdcbiAgICogQHByb3BlcnR5IHtJQ0FMLkNvbXBvbmVudFtdfSBzdGFjayAgICAgICAgICAgICBUaGUgc3RhY2sgb2YgY29tcG9uZW50cyBiZWluZyBwcm9jZXNzZWRcbiAgICogQHByb3BlcnR5IHtJQ0FMLkNvbXBvbmVudH0gY29tcG9uZW50ICAgICAgICAgICBUaGUgY3VycmVudGx5IGFjdGl2ZSBjb21wb25lbnRcbiAgICovXG5cblxuICAvKipcbiAgICogSGFuZGxlcyBhIHNpbmdsZSBsaW5lIG9mIGlDYWxlbmRhci92Q2FyZCwgdXBkYXRpbmcgdGhlIHN0YXRlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb24gSUNBTC5wYXJzZS5faGFuZGxlQ29udGVudExpbmVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmUgICAgICAgICAgICAgICBUaGUgY29udGVudCBsaW5lIHRvIHByb2Nlc3NcbiAgICogQHBhcmFtIHtJQ0FMLnBhcnNlLnBhcnNlclN0YXRlfSAgICBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgbGluZSBwYXJzaW5nXG4gICAqL1xuICBwYXJzZXIuX2hhbmRsZUNvbnRlbnRMaW5lID0gZnVuY3Rpb24obGluZSwgc3RhdGUpIHtcbiAgICAvLyBicmVhayB1cCB0aGUgcGFydHMgb2YgdGhlIGxpbmVcbiAgICB2YXIgdmFsdWVQb3MgPSBsaW5lLmluZGV4T2YoVkFMVUVfREVMSU1JVEVSKTtcbiAgICB2YXIgcGFyYW1Qb3MgPSBsaW5lLmluZGV4T2YoUEFSQU1fREVMSU1JVEVSKTtcblxuICAgIHZhciBsYXN0UGFyYW1JbmRleDtcbiAgICB2YXIgbGFzdFZhbHVlUG9zO1xuXG4gICAgLy8gbmFtZSBvZiBwcm9wZXJ0eSBvciBiZWdpbi9lbmRcbiAgICB2YXIgbmFtZTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gcGFyYW1zIGlzIG9ubHkgb3ZlcnJpZGRlbiBpZiBwYXJhbVBvcyAhPT0gLTEuXG4gICAgLy8gd2UgY2FuJ3QgZG8gcGFyYW1zID0gcGFyYW1zIHx8IHt9IGxhdGVyIG9uXG4gICAgLy8gYmVjYXVzZSBpdCBzYWNyaWZpY2VzIG9wcy5cbiAgICB2YXIgcGFyYW1zID0ge307XG5cbiAgICAvKipcbiAgICAgKiBEaWZmZXJlbnQgcHJvcGVydHkgY2FzZXNcbiAgICAgKlxuICAgICAqXG4gICAgICogMS4gUlJVTEU6RlJFUT1mb29cbiAgICAgKiAgICAvLyBGUkVRPSBpcyBub3QgYSBwYXJhbSBidXQgdGhlIHZhbHVlXG4gICAgICpcbiAgICAgKiAyLiBBVFRFTkRFRTtST0xFPVJFUS1QQVJUSUNJUEFOVDtcbiAgICAgKiAgICAvLyBST0xFPSBpcyBhIHBhcmFtIGJlY2F1c2UgOiBoYXMgbm90IGhhcHBlbmVkIHlldFxuICAgICAqL1xuICAgICAgLy8gd2hlbiB0aGUgcGFyYW1ldGVyIGRlbGltaXRlciBpcyBhZnRlciB0aGVcbiAgICAgIC8vIHZhbHVlIGRlbGltaXRlciB0aGVuIGl0IGlzIG5vdCBhIHBhcmFtZXRlci5cblxuICAgIGlmICgocGFyYW1Qb3MgIT09IC0xICYmIHZhbHVlUG9zICE9PSAtMSkpIHtcbiAgICAgIC8vIHdoZW4gdGhlIHBhcmFtZXRlciBkZWxpbWl0ZXIgaXMgYWZ0ZXIgdGhlXG4gICAgICAvLyB2YWx1ZSBkZWxpbWl0ZXIgdGhlbiBpdCBpcyBub3QgYSBwYXJhbWV0ZXIuXG4gICAgICBpZiAocGFyYW1Qb3MgPiB2YWx1ZVBvcykge1xuICAgICAgICBwYXJhbVBvcyA9IC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwYXJzZWRQYXJhbXM7XG4gICAgaWYgKHBhcmFtUG9zICE9PSAtMSkge1xuICAgICAgbmFtZSA9IGxpbmUuc3Vic3RyaW5nKDAsIHBhcmFtUG9zKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcGFyc2VkUGFyYW1zID0gcGFyc2VyLl9wYXJzZVBhcmFtZXRlcnMobGluZS5zdWJzdHJpbmcocGFyYW1Qb3MpLCAwLCBzdGF0ZS5kZXNpZ25TZXQpO1xuICAgICAgaWYgKHBhcnNlZFBhcmFtc1syXSA9PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VyRXJyb3IoXCJJbnZhbGlkIHBhcmFtZXRlcnMgaW4gJ1wiICsgbGluZSArIFwiJ1wiKTtcbiAgICAgIH1cbiAgICAgIHBhcmFtcyA9IHBhcnNlZFBhcmFtc1swXTtcbiAgICAgIGxhc3RQYXJhbUluZGV4ID0gcGFyc2VkUGFyYW1zWzFdLmxlbmd0aCArIHBhcnNlZFBhcmFtc1syXSArIHBhcmFtUG9zO1xuICAgICAgaWYgKChsYXN0VmFsdWVQb3MgPVxuICAgICAgICBsaW5lLnN1YnN0cmluZyhsYXN0UGFyYW1JbmRleCkuaW5kZXhPZihWQUxVRV9ERUxJTUlURVIpKSAhPT0gLTEpIHtcbiAgICAgICAgdmFsdWUgPSBsaW5lLnN1YnN0cmluZyhsYXN0UGFyYW1JbmRleCArIGxhc3RWYWx1ZVBvcyArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlckVycm9yKFwiTWlzc2luZyBwYXJhbWV0ZXIgdmFsdWUgaW4gJ1wiICsgbGluZSArIFwiJ1wiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlUG9zICE9PSAtMSkge1xuICAgICAgLy8gd2l0aG91dCBwYXJtZXRlcnMgKEJFR0lOOlZDQUVOREFSLCBDTEFTUzpQVUJMSUMpXG4gICAgICBuYW1lID0gbGluZS5zdWJzdHJpbmcoMCwgdmFsdWVQb3MpLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YWx1ZSA9IGxpbmUuc3Vic3RyaW5nKHZhbHVlUG9zICsgMSk7XG5cbiAgICAgIGlmIChuYW1lID09PSAnYmVnaW4nKSB7XG4gICAgICAgIHZhciBuZXdDb21wb25lbnQgPSBbdmFsdWUudG9Mb3dlckNhc2UoKSwgW10sIFtdXTtcbiAgICAgICAgaWYgKHN0YXRlLnN0YWNrLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHN0YXRlLmNvbXBvbmVudC5wdXNoKG5ld0NvbXBvbmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUuY29tcG9uZW50WzJdLnB1c2gobmV3Q29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5zdGFjay5wdXNoKHN0YXRlLmNvbXBvbmVudCk7XG4gICAgICAgIHN0YXRlLmNvbXBvbmVudCA9IG5ld0NvbXBvbmVudDtcbiAgICAgICAgaWYgKCFzdGF0ZS5kZXNpZ25TZXQpIHtcbiAgICAgICAgICBzdGF0ZS5kZXNpZ25TZXQgPSBkZXNpZ24uZ2V0RGVzaWduU2V0KHN0YXRlLmNvbXBvbmVudFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnZW5kJykge1xuICAgICAgICBzdGF0ZS5jb21wb25lbnQgPSBzdGF0ZS5zdGFjay5wb3AoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gSWYgaXQgaXMgbm90IGJlZ2luL2VuZCwgdGhlbiB0aGlzIGlzIGEgcHJvcGVydHkgd2l0aCBhbiBlbXB0eSB2YWx1ZSxcbiAgICAgIC8vIHdoaWNoIHNob3VsZCBiZSBjb25zaWRlcmVkIHZhbGlkLlxuICAgIH0gZWxzZSB7XG4gICAgICAvKipcbiAgICAgICAqIEludmFsaWQgbGluZS5cbiAgICAgICAqIFRoZSByYXRpb25hbCB0byB0aHJvdyBhbiBlcnJvciBpcyB3ZSB3aWxsXG4gICAgICAgKiBuZXZlciBiZSBjZXJ0YWluIHRoYXQgdGhlIHJlc3Qgb2YgdGhlIGZpbGVcbiAgICAgICAqIGlzIHNhbmUgYW5kIGl0IGlzIHVubGlrZWx5IHRoYXQgd2UgY2FuIHNlcmlhbGl6ZVxuICAgICAgICogdGhlIHJlc3VsdCBjb3JyZWN0bHkgZWl0aGVyLlxuICAgICAgICovXG4gICAgICB0aHJvdyBuZXcgUGFyc2VyRXJyb3IoXG4gICAgICAgICdpbnZhbGlkIGxpbmUgKG5vIHRva2VuIFwiO1wiIG9yIFwiOlwiKSBcIicgKyBsaW5lICsgJ1wiJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVUeXBlO1xuICAgIHZhciBtdWx0aVZhbHVlID0gZmFsc2U7XG4gICAgdmFyIHN0cnVjdHVyZWRWYWx1ZSA9IGZhbHNlO1xuICAgIHZhciBwcm9wZXJ0eURldGFpbHM7XG5cbiAgICBpZiAobmFtZSBpbiBzdGF0ZS5kZXNpZ25TZXQucHJvcGVydHkpIHtcbiAgICAgIHByb3BlcnR5RGV0YWlscyA9IHN0YXRlLmRlc2lnblNldC5wcm9wZXJ0eVtuYW1lXTtcblxuICAgICAgaWYgKCdtdWx0aVZhbHVlJyBpbiBwcm9wZXJ0eURldGFpbHMpIHtcbiAgICAgICAgbXVsdGlWYWx1ZSA9IHByb3BlcnR5RGV0YWlscy5tdWx0aVZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ3N0cnVjdHVyZWRWYWx1ZScgaW4gcHJvcGVydHlEZXRhaWxzKSB7XG4gICAgICAgIHN0cnVjdHVyZWRWYWx1ZSA9IHByb3BlcnR5RGV0YWlscy5zdHJ1Y3R1cmVkVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSAmJiAnZGV0ZWN0VHlwZScgaW4gcHJvcGVydHlEZXRhaWxzKSB7XG4gICAgICAgIHZhbHVlVHlwZSA9IHByb3BlcnR5RGV0YWlscy5kZXRlY3RUeXBlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhdHRlbXB0IHRvIGRldGVybWluZSB2YWx1ZVxuICAgIGlmICghdmFsdWVUeXBlKSB7XG4gICAgICBpZiAoISgndmFsdWUnIGluIHBhcmFtcykpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5RGV0YWlscykge1xuICAgICAgICAgIHZhbHVlVHlwZSA9IHByb3BlcnR5RGV0YWlscy5kZWZhdWx0VHlwZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZVR5cGUgPSBERUZBVUxUX1ZBTFVFX1RZUEU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHBvc3NpYmxlIHRvIGF2b2lkIHRoaXM/XG4gICAgICAgIHZhbHVlVHlwZSA9IHBhcmFtcy52YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlbGV0ZSBwYXJhbXMudmFsdWU7XG5cbiAgICAvKipcbiAgICAgKiBOb3RlIG9uIGB2YXIgcmVzdWx0YCBqdWdnbGluZzpcbiAgICAgKlxuICAgICAqIEkgb2JzZXJ2ZWQgdGhhdCBidWlsZGluZyB0aGUgYXJyYXkgaW4gcGllY2VzIGhhcyBhZHZlcnNlXG4gICAgICogZWZmZWN0cyBvbiBwZXJmb3JtYW5jZSwgc28gd2hlcmUgcG9zc2libGUgd2UgaW5saW5lIHRoZSBjcmVhdGlvbi5cbiAgICAgKiBJdCBpcyBhIGxpdHRsZSB1Z2x5IGJ1dCByZXN1bHRlZCBpbiB+MjAwMCBhZGRpdGlvbmFsIG9wcy9zZWMuXG4gICAgICovXG5cbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChtdWx0aVZhbHVlICYmIHN0cnVjdHVyZWRWYWx1ZSkge1xuICAgICAgdmFsdWUgPSBwYXJzZXIuX3BhcnNlTXVsdGlWYWx1ZSh2YWx1ZSwgc3RydWN0dXJlZFZhbHVlLCB2YWx1ZVR5cGUsIFtdLCBtdWx0aVZhbHVlLCBzdGF0ZS5kZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgICByZXN1bHQgPSBbbmFtZSwgcGFyYW1zLCB2YWx1ZVR5cGUsIHZhbHVlXTtcbiAgICB9IGVsc2UgaWYgKG11bHRpVmFsdWUpIHtcbiAgICAgIHJlc3VsdCA9IFtuYW1lLCBwYXJhbXMsIHZhbHVlVHlwZV07XG4gICAgICBwYXJzZXIuX3BhcnNlTXVsdGlWYWx1ZSh2YWx1ZSwgbXVsdGlWYWx1ZSwgdmFsdWVUeXBlLCByZXN1bHQsIG51bGwsIHN0YXRlLmRlc2lnblNldCwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoc3RydWN0dXJlZFZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlci5fcGFyc2VNdWx0aVZhbHVlKHZhbHVlLCBzdHJ1Y3R1cmVkVmFsdWUsIHZhbHVlVHlwZSwgW10sIG51bGwsIHN0YXRlLmRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKTtcbiAgICAgIHJlc3VsdCA9IFtuYW1lLCBwYXJhbXMsIHZhbHVlVHlwZSwgdmFsdWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlci5fcGFyc2VWYWx1ZSh2YWx1ZSwgdmFsdWVUeXBlLCBzdGF0ZS5kZXNpZ25TZXQsIGZhbHNlKTtcbiAgICAgIHJlc3VsdCA9IFtuYW1lLCBwYXJhbXMsIHZhbHVlVHlwZSwgdmFsdWVdO1xuICAgIH1cbiAgICAvLyByZmM2MzUwIHJlcXVpcmVzIHRoYXQgaW4gdkNhcmQgNC4wIHRoZSBmaXJzdCBjb21wb25lbnQgaXMgdGhlIFZFUlNJT05cbiAgICAvLyBjb21wb25lbnQgd2l0aCBhcyB2YWx1ZSA0LjAsIG5vdGUgdGhhdCAzLjAgZG9lcyBub3QgaGF2ZSB0aGlzIHJlcXVpcmVtZW50LlxuICAgIGlmIChzdGF0ZS5jb21wb25lbnRbMF0gPT09ICd2Y2FyZCcgJiYgc3RhdGUuY29tcG9uZW50WzFdLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgIShuYW1lID09PSAndmVyc2lvbicgJiYgdmFsdWUgPT09ICc0LjAnKSkge1xuICAgICAgc3RhdGUuZGVzaWduU2V0ID0gZGVzaWduLmdldERlc2lnblNldChcInZjYXJkM1wiKTtcbiAgICB9XG4gICAgc3RhdGUuY29tcG9uZW50WzFdLnB1c2gocmVzdWx0KTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2UgYSB2YWx1ZSBmcm9tIHRoZSByYXcgdmFsdWUgaW50byB0aGUgakNhcmQvakNhbCB2YWx1ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGZ1bmN0aW9uIElDQUwucGFyc2UuX3BhcnNlVmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlICAgICAgICAgIE9yaWdpbmFsIHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlICAgICAgICAgICBUeXBlIG9mIHZhbHVlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXNpZ25TZXQgICAgICBUaGUgZGVzaWduIGRhdGEgdG8gdXNlIGZvciB0aGlzIHZhbHVlXG4gICAqIEByZXR1cm4ge09iamVjdH0gdmFyaWVzIG9uIHR5cGVcbiAgICovXG4gIHBhcnNlci5fcGFyc2VWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlLCB0eXBlLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSkge1xuICAgIGlmICh0eXBlIGluIGRlc2lnblNldC52YWx1ZSAmJiAnZnJvbUlDQUwnIGluIGRlc2lnblNldC52YWx1ZVt0eXBlXSkge1xuICAgICAgcmV0dXJuIGRlc2lnblNldC52YWx1ZVt0eXBlXS5mcm9tSUNBTCh2YWx1ZSwgc3RydWN0dXJlZFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSBwYXJhbWV0ZXJzIGZyb20gYSBzdHJpbmcgdG8gb2JqZWN0LlxuICAgKlxuICAgKiBAZnVuY3Rpb24gSUNBTC5wYXJzZS5fcGFyc2VQYXJhbWV0ZXJzXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lICAgICAgICAgICBBIHNpbmdsZSB1bmZvbGRlZCBsaW5lXG4gICAqIEBwYXJhbSB7TnVtZXJpY30gc3RhcnQgICAgICAgICBQb3NpdGlvbiB0byBzdGFydCBsb29raW5nIGZvciBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXNpZ25TZXQgICAgICBUaGUgZGVzaWduIGRhdGEgdG8gdXNlIGZvciB0aGlzIHByb3BlcnR5XG4gICAqIEByZXR1cm4ge09iamVjdH0ga2V5L3ZhbHVlIHBhaXJzXG4gICAqL1xuICBwYXJzZXIuX3BhcnNlUGFyYW1ldGVycyA9IGZ1bmN0aW9uKGxpbmUsIHN0YXJ0LCBkZXNpZ25TZXQpIHtcbiAgICB2YXIgbGFzdFBhcmFtID0gc3RhcnQ7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgdmFyIGRlbGltID0gUEFSQU1fTkFNRV9ERUxJTUlURVI7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBuYW1lLCBsY25hbWU7XG4gICAgdmFyIHZhbHVlLCB2YWx1ZVBvcyA9IC0xO1xuICAgIHZhciB0eXBlLCBtdWx0aVZhbHVlLCBtdmRlbGltO1xuXG4gICAgLy8gZmluZCB0aGUgbmV4dCAnPScgc2lnblxuICAgIC8vIHVzZSBsYXN0UGFyYW0gYW5kIHBvcyB0byBmaW5kIG5hbWVcbiAgICAvLyBjaGVjayBpZiBcIiBpcyB1c2VkIGlmIHNvIGdldCB2YWx1ZSBmcm9tIFwiLT5cIlxuICAgIC8vIHRoZW4gaW5jcmVtZW50IHBvcyB0byBmaW5kIG5leHQgO1xuXG4gICAgd2hpbGUgKChwb3MgIT09IGZhbHNlKSAmJlxuICAgICAgICAgICAocG9zID0gaGVscGVycy51bmVzY2FwZWRJbmRleE9mKGxpbmUsIGRlbGltLCBwb3MgKyAxKSkgIT09IC0xKSB7XG5cbiAgICAgIG5hbWUgPSBsaW5lLnN1YnN0cihsYXN0UGFyYW0gKyAxLCBwb3MgLSBsYXN0UGFyYW0gLSAxKTtcbiAgICAgIGlmIChuYW1lLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZXJFcnJvcihcIkVtcHR5IHBhcmFtZXRlciBuYW1lIGluICdcIiArIGxpbmUgKyBcIidcIik7XG4gICAgICB9XG4gICAgICBsY25hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBtdmRlbGltID0gZmFsc2U7XG4gICAgICBtdWx0aVZhbHVlID0gZmFsc2U7XG5cbiAgICAgIGlmIChsY25hbWUgaW4gZGVzaWduU2V0LnBhcmFtICYmIGRlc2lnblNldC5wYXJhbVtsY25hbWVdLnZhbHVlVHlwZSkge1xuICAgICAgICB0eXBlID0gZGVzaWduU2V0LnBhcmFtW2xjbmFtZV0udmFsdWVUeXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IERFRkFVTFRfUEFSQU1fVFlQRTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxjbmFtZSBpbiBkZXNpZ25TZXQucGFyYW0pIHtcbiAgICAgICAgbXVsdGlWYWx1ZSA9IGRlc2lnblNldC5wYXJhbVtsY25hbWVdLm11bHRpVmFsdWU7XG4gICAgICAgIGlmIChkZXNpZ25TZXQucGFyYW1bbGNuYW1lXS5tdWx0aVZhbHVlU2VwYXJhdGVEUXVvdGUpIHtcbiAgICAgICAgICBtdmRlbGltID0gcGFyc2VyLl9yZmM2ODY4RXNjYXBlKCdcIicgKyBtdWx0aVZhbHVlICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5leHRDaGFyID0gbGluZVtwb3MgKyAxXTtcbiAgICAgIGlmIChuZXh0Q2hhciA9PT0gJ1wiJykge1xuICAgICAgICB2YWx1ZVBvcyA9IHBvcyArIDI7XG4gICAgICAgIHBvcyA9IGhlbHBlcnMudW5lc2NhcGVkSW5kZXhPZihsaW5lLCAnXCInLCB2YWx1ZVBvcyk7XG4gICAgICAgIGlmIChtdWx0aVZhbHVlICYmIHBvcyAhPSAtMSkge1xuICAgICAgICAgICAgdmFyIGV4dGVuZGVkVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKGV4dGVuZGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKGxpbmVbcG9zICsgMV0gPT0gbXVsdGlWYWx1ZSAmJiBsaW5lW3BvcyArIDJdID09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBwb3MgPSBoZWxwZXJzLnVuZXNjYXBlZEluZGV4T2YobGluZSwgJ1wiJywgcG9zICsgMyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5kZWRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZXJFcnJvcihcbiAgICAgICAgICAgICdpbnZhbGlkIGxpbmUgKG5vIG1hdGNoaW5nIGRvdWJsZSBxdW90ZSkgXCInICsgbGluZSArICdcIidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gbGluZS5zdWJzdHIodmFsdWVQb3MsIHBvcyAtIHZhbHVlUG9zKTtcbiAgICAgICAgbGFzdFBhcmFtID0gaGVscGVycy51bmVzY2FwZWRJbmRleE9mKGxpbmUsIFBBUkFNX0RFTElNSVRFUiwgcG9zKTtcbiAgICAgICAgaWYgKGxhc3RQYXJhbSA9PT0gLTEpIHtcbiAgICAgICAgICBwb3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVQb3MgPSBwb3MgKyAxO1xuXG4gICAgICAgIC8vIG1vdmUgdG8gbmV4dCBcIjtcIlxuICAgICAgICB2YXIgbmV4dFBvcyA9IGhlbHBlcnMudW5lc2NhcGVkSW5kZXhPZihsaW5lLCBQQVJBTV9ERUxJTUlURVIsIHZhbHVlUG9zKTtcbiAgICAgICAgdmFyIHByb3BWYWx1ZVBvcyA9IGhlbHBlcnMudW5lc2NhcGVkSW5kZXhPZihsaW5lLCBWQUxVRV9ERUxJTUlURVIsIHZhbHVlUG9zKTtcbiAgICAgICAgaWYgKHByb3BWYWx1ZVBvcyAhPT0gLTEgJiYgbmV4dFBvcyA+IHByb3BWYWx1ZVBvcykge1xuICAgICAgICAgIC8vIHRoaXMgaXMgYSBkZWxpbWl0ZXIgaW4gdGhlIHByb3BlcnR5IHZhbHVlLCBsZXQncyBzdG9wIGhlcmVcbiAgICAgICAgICBuZXh0UG9zID0gcHJvcFZhbHVlUG9zO1xuICAgICAgICAgIHBvcyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKG5leHRQb3MgPT09IC0xKSB7XG4gICAgICAgICAgLy8gbm8gXCI7XCJcbiAgICAgICAgICBpZiAocHJvcFZhbHVlUG9zID09PSAtMSkge1xuICAgICAgICAgICAgbmV4dFBvcyA9IGxpbmUubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0UG9zID0gcHJvcFZhbHVlUG9zO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3MgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0UGFyYW0gPSBuZXh0UG9zO1xuICAgICAgICAgIHBvcyA9IG5leHRQb3M7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IGxpbmUuc3Vic3RyKHZhbHVlUG9zLCBuZXh0UG9zIC0gdmFsdWVQb3MpO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IHBhcnNlci5fcmZjNjg2OEVzY2FwZSh2YWx1ZSk7XG4gICAgICBpZiAobXVsdGlWYWx1ZSkge1xuICAgICAgICB2YXIgZGVsaW1pdGVyID0gbXZkZWxpbSB8fCBtdWx0aVZhbHVlO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlci5fcGFyc2VNdWx0aVZhbHVlKHZhbHVlLCBkZWxpbWl0ZXIsIHR5cGUsIFtdLCBudWxsLCBkZXNpZ25TZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBwYXJzZXIuX3BhcnNlVmFsdWUodmFsdWUsIHR5cGUsIGRlc2lnblNldCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtdWx0aVZhbHVlICYmIChsY25hbWUgaW4gcmVzdWx0KSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHRbbGNuYW1lXSkpIHtcbiAgICAgICAgICByZXN1bHRbbGNuYW1lXS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbbGNuYW1lXSA9IFtcbiAgICAgICAgICAgIHJlc3VsdFtsY25hbWVdLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbbGNuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3Jlc3VsdCwgdmFsdWUsIHZhbHVlUG9zXTtcbiAgfTtcblxuICAvKipcbiAgICogSW50ZXJuYWwgaGVscGVyIGZvciByZmM2ODY4LiBFeHBvc2luZyB0aGlzIG9uIElDQUwucGFyc2Ugc28gdGhhdFxuICAgKiBoYWNrZXJzIGNhbiBkaXNhYmxlIHRoZSByZmM2ODY4IHBhcnNpbmcgaWYgdGhlIHJlYWxseSBuZWVkIHRvLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gSUNBTC5wYXJzZS5fcmZjNjg2OEVzY2FwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsICAgICAgICBUaGUgdmFsdWUgdG8gZXNjYXBlXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgIFRoZSBlc2NhcGVkIHZhbHVlXG4gICAqL1xuICBwYXJzZXIuX3JmYzY4NjhFc2NhcGUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICByZXR1cm4gdmFsLnJlcGxhY2UoL1xcXlsnbl5dL2csIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBSRkM2ODY4X1JFUExBQ0VfTUFQW3hdO1xuICAgIH0pO1xuICB9O1xuICB2YXIgUkZDNjg2OF9SRVBMQUNFX01BUCA9IHsgXCJeJ1wiOiAnXCInLCBcIl5uXCI6IFwiXFxuXCIsIFwiXl5cIjogXCJeXCIgfTtcblxuICAvKipcbiAgICogUGFyc2UgYSBtdWx0aSB2YWx1ZSBzdHJpbmcuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBlaXRoZXIgZm9yIHBhcnNpbmdcbiAgICogYWN0dWFsIG11bHRpLXZhbHVlIHByb3BlcnR5J3MgdmFsdWVzLCBvciBmb3IgaGFuZGxpbmcgcGFyYW1ldGVyIHZhbHVlcy4gSXRcbiAgICogY2FuIGJlIHVzZWQgZm9yIGJvdGggbXVsdGktdmFsdWUgcHJvcGVydGllcyBhbmQgc3RydWN0dXJlZCB2YWx1ZSBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb24gSUNBTC5wYXJzZS5fcGFyc2VNdWx0aVZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBidWZmZXIgICAgIFRoZSBidWZmZXIgY29udGFpbmluZyB0aGUgZnVsbCB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGVsaW0gICAgICBUaGUgbXVsdGktdmFsdWUgZGVsaW1pdGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlICAgICAgIFRoZSB2YWx1ZSB0eXBlIHRvIGJlIHBhcnNlZFxuICAgKiBAcGFyYW0ge0FycmF5Ljw/Pn0gcmVzdWx0ICAgICAgICBUaGUgYXJyYXkgdG8gYXBwZW5kIHJlc3VsdHMgdG8sIHZhcmllcyBvbiB2YWx1ZSB0eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbm5lck11bHRpIFRoZSBpbm5lciBkZWxpbWl0ZXIgdG8gc3BsaXQgZWFjaCB2YWx1ZSB3aXRoXG4gICAqIEBwYXJhbSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSBkZXNpZ25TZXQgICBUaGUgZGVzaWduIGRhdGEgZm9yIHRoaXMgdmFsdWVcbiAgICogQHJldHVybiB7P3xBcnJheS48Pz59ICAgICAgICAgICAgRWl0aGVyIGFuIGFycmF5IG9mIHJlc3VsdHMsIG9yIHRoZSBmaXJzdCByZXN1bHRcbiAgICovXG4gIHBhcnNlci5fcGFyc2VNdWx0aVZhbHVlID0gZnVuY3Rpb24oYnVmZmVyLCBkZWxpbSwgdHlwZSwgcmVzdWx0LCBpbm5lck11bHRpLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSkge1xuICAgIHZhciBwb3MgPSAwO1xuICAgIHZhciBsYXN0UG9zID0gMDtcbiAgICB2YXIgdmFsdWU7XG4gICAgaWYgKGRlbGltLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG5cbiAgICAvLyBzcGxpdCBlYWNoIHBpZWNlXG4gICAgd2hpbGUgKChwb3MgPSBoZWxwZXJzLnVuZXNjYXBlZEluZGV4T2YoYnVmZmVyLCBkZWxpbSwgbGFzdFBvcykpICE9PSAtMSkge1xuICAgICAgdmFsdWUgPSBidWZmZXIuc3Vic3RyKGxhc3RQb3MsIHBvcyAtIGxhc3RQb3MpO1xuICAgICAgaWYgKGlubmVyTXVsdGkpIHtcbiAgICAgICAgdmFsdWUgPSBwYXJzZXIuX3BhcnNlTXVsdGlWYWx1ZSh2YWx1ZSwgaW5uZXJNdWx0aSwgdHlwZSwgW10sIG51bGwsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gcGFyc2VyLl9wYXJzZVZhbHVlKHZhbHVlLCB0eXBlLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICBsYXN0UG9zID0gcG9zICsgZGVsaW0ubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIG9uIHRoZSBsYXN0IHBpZWNlIHRha2UgdGhlIHJlc3Qgb2Ygc3RyaW5nXG4gICAgdmFsdWUgPSBidWZmZXIuc3Vic3RyKGxhc3RQb3MpO1xuICAgIGlmIChpbm5lck11bHRpKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlci5fcGFyc2VNdWx0aVZhbHVlKHZhbHVlLCBpbm5lck11bHRpLCB0eXBlLCBbXSwgbnVsbCwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlci5fcGFyc2VWYWx1ZSh2YWx1ZSwgdHlwZSwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG5cbiAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PSAxID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGEgY29tcGxldGUgYnVmZmVyIG9mIGlDYWxlbmRhci92Q2FyZCBkYXRhIGxpbmUgYnkgbGluZSwgY29ycmVjdGx5XG4gICAqIHVuZm9sZGluZyBjb250ZW50LiBFYWNoIGxpbmUgd2lsbCBiZSBwcm9jZXNzZWQgd2l0aCB0aGUgZ2l2ZW4gY2FsbGJhY2tcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGZ1bmN0aW9uIElDQUwucGFyc2UuX2VhY2hMaW5lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBidWZmZXIgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGJ1ZmZlciB0byBwcm9jZXNzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oP1N0cmluZywgU3RyaW5nKX0gY2FsbGJhY2sgICAgVGhlIGNhbGxiYWNrIGZvciBlYWNoIGxpbmVcbiAgICovXG4gIHBhcnNlci5fZWFjaExpbmUgPSBmdW5jdGlvbihidWZmZXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGxlbiA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgdmFyIGxhc3RQb3MgPSBidWZmZXIuc2VhcmNoKENIQVIpO1xuICAgIHZhciBwb3MgPSBsYXN0UG9zO1xuICAgIHZhciBsaW5lO1xuICAgIHZhciBmaXJzdENoYXI7XG5cbiAgICB2YXIgbmV3bGluZU9mZnNldDtcblxuICAgIGRvIHtcbiAgICAgIHBvcyA9IGJ1ZmZlci5pbmRleE9mKCdcXG4nLCBsYXN0UG9zKSArIDE7XG5cbiAgICAgIGlmIChwb3MgPiAxICYmIGJ1ZmZlcltwb3MgLSAyXSA9PT0gJ1xccicpIHtcbiAgICAgICAgbmV3bGluZU9mZnNldCA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdsaW5lT2Zmc2V0ID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvcyA9PT0gMCkge1xuICAgICAgICBwb3MgPSBsZW47XG4gICAgICAgIG5ld2xpbmVPZmZzZXQgPSAwO1xuICAgICAgfVxuXG4gICAgICBmaXJzdENoYXIgPSBidWZmZXJbbGFzdFBvc107XG5cbiAgICAgIGlmIChmaXJzdENoYXIgPT09ICcgJyB8fCBmaXJzdENoYXIgPT09ICdcXHQnKSB7XG4gICAgICAgIC8vIGFkZCB0byBsaW5lXG4gICAgICAgIGxpbmUgKz0gYnVmZmVyLnN1YnN0cihcbiAgICAgICAgICBsYXN0UG9zICsgMSxcbiAgICAgICAgICBwb3MgLSBsYXN0UG9zIC0gKG5ld2xpbmVPZmZzZXQgKyAxKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxpbmUpXG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgbGluZSk7XG4gICAgICAgIC8vIHB1c2ggbGluZVxuICAgICAgICBsaW5lID0gYnVmZmVyLnN1YnN0cihcbiAgICAgICAgICBsYXN0UG9zLFxuICAgICAgICAgIHBvcyAtIGxhc3RQb3MgLSBuZXdsaW5lT2Zmc2V0XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGxhc3RQb3MgPSBwb3M7XG4gICAgfSB3aGlsZSAocG9zICE9PSBsZW4pO1xuXG4gICAgLy8gZXh0cmEgZW5kaW5nIGxpbmVcbiAgICBsaW5lID0gbGluZS50cmltKCk7XG5cbiAgICBpZiAobGluZS5sZW5ndGgpXG4gICAgICBjYWxsYmFjayhudWxsLCBsaW5lKTtcbiAgfTtcblxuICByZXR1cm4gcGFyc2VyO1xuXG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG4vKipcbiAqIFRoaXMgc3ltYm9sIGlzIGZ1cnRoZXIgZGVzY3JpYmVkIGxhdGVyIG9uXG4gKiBAaWdub3JlXG4gKi9cbklDQUwuQ29tcG9uZW50ID0gKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIFBST1BFUlRZX0lOREVYID0gMTtcbiAgdmFyIENPTVBPTkVOVF9JTkRFWCA9IDI7XG4gIHZhciBOQU1FX0lOREVYID0gMDtcblxuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBXcmFwcyBhIGpDYWwgY29tcG9uZW50LCBhZGRpbmcgY29udmVuaWVuY2UgbWV0aG9kcyB0byBhZGQsIHJlbW92ZSBhbmRcbiAgICogdXBkYXRlIHN1YmNvbXBvbmVudHMgYW5kIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAYWxpYXMgSUNBTC5Db21wb25lbnRcbiAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGpDYWwgICAgICAgICBSYXcgakNhbCBjb21wb25lbnQgZGF0YSBPUiBuYW1lIG9mIG5ld1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnR9IHBhcmVudCAgICAgUGFyZW50IGNvbXBvbmVudCB0byBhc3NvY2lhdGVcbiAgICovXG4gIGZ1bmN0aW9uIENvbXBvbmVudChqQ2FsLCBwYXJlbnQpIHtcbiAgICBpZiAodHlwZW9mKGpDYWwpID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gakNhbCBzcGVjIChuYW1lLCBwcm9wZXJ0aWVzLCBjb21wb25lbnRzKVxuICAgICAgakNhbCA9IFtqQ2FsLCBbXSwgW11dO1xuICAgIH1cblxuICAgIC8vIG1vc3RseSBmb3IgbGVnYWN5IHJlYXNvbnMuXG4gICAgdGhpcy5qQ2FsID0gakNhbDtcblxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gIH1cblxuICBDb21wb25lbnQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEh5ZHJhdGVkIHByb3BlcnRpZXMgYXJlIGluc2VydGVkIGludG8gdGhlIF9wcm9wZXJ0aWVzIGFycmF5IGF0IHRoZSBzYW1lXG4gICAgICogcG9zaXRpb24gYXMgaW4gdGhlIGpDYWwgYXJyYXksIHNvIGl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlIGFycmF5IGNvbnRhaW5zXG4gICAgICogdW5kZWZpbmVkIHZhbHVlcyBmb3IgdW5oeWRyZGF0ZWQgcHJvcGVydGllcy4gVG8gYXZvaWQgaXRlcmF0aW5nIHRoZVxuICAgICAqIGFycmF5IHdoZW4gY2hlY2tpbmcgaWYgYWxsIHByb3BlcnRpZXMgaGF2ZSBiZWVuIGh5ZHJhdGVkLCB3ZSBzYXZlIHRoZVxuICAgICAqIGNvdW50IGhlcmUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2h5ZHJhdGVkUHJvcGVydHlDb3VudDogMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGNvdW50IGFzIGZvciBfaHlkcmF0ZWRQcm9wZXJ0eUNvdW50LCBidXQgZm9yIHN1YmNvbXBvbmVudHNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaHlkcmF0ZWRDb21wb25lbnRDb3VudDogMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoaXMgY29tcG9uZW50XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5qQ2FsW05BTUVfSU5ERVhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVzaWduIHNldCBmb3IgdGhpcyBjb21wb25lbnQsIGUuZy4gaWNhbGVuZGFyIHZzIHZjYXJkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0IF9kZXNpZ25TZXQoKSB7XG4gICAgICB2YXIgcGFyZW50RGVzaWduID0gdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuX2Rlc2lnblNldDtcbiAgICAgIHJldHVybiBwYXJlbnREZXNpZ24gfHwgSUNBTC5kZXNpZ24uZ2V0RGVzaWduU2V0KHRoaXMubmFtZSk7XG4gICAgfSxcblxuICAgIF9oeWRyYXRlQ29tcG9uZW50OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaWYgKCF0aGlzLl9jb21wb25lbnRzKSB7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5faHlkcmF0ZWRDb21wb25lbnRDb3VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9jb21wb25lbnRzW2luZGV4XSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c1tpbmRleF07XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wID0gbmV3IENvbXBvbmVudChcbiAgICAgICAgdGhpcy5qQ2FsW0NPTVBPTkVOVF9JTkRFWF1baW5kZXhdLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuXG4gICAgICB0aGlzLl9oeWRyYXRlZENvbXBvbmVudENvdW50Kys7XG4gICAgICByZXR1cm4gKHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdID0gY29tcCk7XG4gICAgfSxcblxuICAgIF9oeWRyYXRlUHJvcGVydHk6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuX3Byb3BlcnRpZXMpIHtcbiAgICAgICAgdGhpcy5fcHJvcGVydGllcyA9IFtdO1xuICAgICAgICB0aGlzLl9oeWRyYXRlZFByb3BlcnR5Q291bnQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcHJvcGVydGllc1tpbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXNbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcCA9IG5ldyBJQ0FMLlByb3BlcnR5KFxuICAgICAgICB0aGlzLmpDYWxbUFJPUEVSVFlfSU5ERVhdW2luZGV4XSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcblxuICAgICAgdGhpcy5faHlkcmF0ZWRQcm9wZXJ0eUNvdW50Kys7XG4gICAgICByZXR1cm4gKHRoaXMuX3Byb3BlcnRpZXNbaW5kZXhdID0gcHJvcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGZpcnN0IHN1YiBjb21wb25lbnQsIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nPX0gbmFtZSAgICAgICAgT3B0aW9uYWwgbmFtZSB0byBmaWx0ZXIgYnlcbiAgICAgKiBAcmV0dXJuIHs/SUNBTC5Db21wb25lbnR9ICAgICBUaGUgZm91bmQgc3ViY29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0Rmlyc3RTdWJjb21wb25lbnQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGNvbXBzID0gdGhpcy5qQ2FsW0NPTVBPTkVOVF9JTkRFWF07XG4gICAgICAgIHZhciBsZW4gPSBjb21wcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChjb21wc1tpXVtOQU1FX0lOREVYXSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2h5ZHJhdGVDb21wb25lbnQoaSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuakNhbFtDT01QT05FTlRfSU5ERVhdLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9oeWRyYXRlQ29tcG9uZW50KDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGVuc3VyZSB3ZSByZXR1cm4gYSB2YWx1ZSAoc3RyaWN0IG1vZGUpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgYWxsIHN1YiBjb21wb25lbnRzLCBvcHRpb25hbGx5IGZpbHRlcmluZyBieSBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmc9fSBuYW1lICAgICAgICAgICAgT3B0aW9uYWwgbmFtZSB0byBmaWx0ZXIgYnlcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLkNvbXBvbmVudFtdfSAgICAgICBUaGUgZm91bmQgc3ViIGNvbXBvbmVudHNcbiAgICAgKi9cbiAgICBnZXRBbGxTdWJjb21wb25lbnRzOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgakNhbExlbiA9IHRoaXMuakNhbFtDT01QT05FTlRfSU5ERVhdLmxlbmd0aDtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgdmFyIGNvbXBzID0gdGhpcy5qQ2FsW0NPTVBPTkVOVF9JTkRFWF07XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBmb3IgKDsgaSA8IGpDYWxMZW47IGkrKykge1xuICAgICAgICAgIGlmIChuYW1lID09PSBjb21wc1tpXVtOQU1FX0lOREVYXSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgIHRoaXMuX2h5ZHJhdGVDb21wb25lbnQoaSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbXBvbmVudHMgfHxcbiAgICAgICAgICAgICh0aGlzLl9oeWRyYXRlZENvbXBvbmVudENvdW50ICE9PSBqQ2FsTGVuKSkge1xuICAgICAgICAgIGZvciAoOyBpIDwgakNhbExlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9oeWRyYXRlQ29tcG9uZW50KGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzIHx8IFtdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgd2hlbiBhIG5hbWVkIHByb3BlcnR5IGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lICAgICBUaGUgcHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBUcnVlLCB3aGVuIHByb3BlcnR5IGlzIGZvdW5kXG4gICAgICovXG4gICAgaGFzUHJvcGVydHk6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBwcm9wcyA9IHRoaXMuakNhbFtQUk9QRVJUWV9JTkRFWF07XG4gICAgICB2YXIgbGVuID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIDAgaXMgcHJvcGVydHkgbmFtZVxuICAgICAgICBpZiAocHJvcHNbaV1bTkFNRV9JTkRFWF0gPT09IG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBmaXJzdCBwcm9wZXJ0eSwgb3B0aW9uYWxseSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmc9fSBuYW1lICAgICAgICBMb3dlcmNhc2UgcHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4gez9JQ0FMLlByb3BlcnR5fSAgICAgVGhlIGZvdW5kIHByb3BlcnR5XG4gICAgICovXG4gICAgZ2V0Rmlyc3RQcm9wZXJ0eTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLmpDYWxbUFJPUEVSVFlfSU5ERVhdO1xuICAgICAgICB2YXIgbGVuID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAocHJvcHNbaV1bTkFNRV9JTkRFWF0gPT09IG5hbWUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9oeWRyYXRlUHJvcGVydHkoaSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuakNhbFtQUk9QRVJUWV9JTkRFWF0ubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2h5ZHJhdGVQcm9wZXJ0eSgwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmaXJzdCBwcm9wZXJ0eSdzIHZhbHVlLCBpZiBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZz19IG5hbWUgICAgTG93ZXJjYXNlIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/U3RyaW5nfSAgICAgICAgVGhlIGZvdW5kIHByb3BlcnR5IHZhbHVlLlxuICAgICAqL1xuICAgIGdldEZpcnN0UHJvcGVydHlWYWx1ZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIHByb3AgPSB0aGlzLmdldEZpcnN0UHJvcGVydHkobmFtZSk7XG4gICAgICBpZiAocHJvcCkge1xuICAgICAgICByZXR1cm4gcHJvcC5nZXRGaXJzdFZhbHVlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHByb3BlcnRpZXMgaW4gdGhlIGNvbXBvbmVudCwgb3B0aW9uYWxseSBmaWx0ZXJlZCBieSBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmc9fSBuYW1lICAgICAgICBMb3dlcmNhc2UgcHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4ge0lDQUwuUHJvcGVydHlbXX0gICAgTGlzdCBvZiBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ2V0QWxsUHJvcGVydGllczogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGpDYWxMZW4gPSB0aGlzLmpDYWxbUFJPUEVSVFlfSU5ERVhdLmxlbmd0aDtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5qQ2FsW1BST1BFUlRZX0lOREVYXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGZvciAoOyBpIDwgakNhbExlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09IHByb3BzW2ldW05BTUVfSU5ERVhdKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgdGhpcy5faHlkcmF0ZVByb3BlcnR5KGkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcm9wZXJ0aWVzIHx8XG4gICAgICAgICAgICAodGhpcy5faHlkcmF0ZWRQcm9wZXJ0eUNvdW50ICE9PSBqQ2FsTGVuKSkge1xuICAgICAgICAgIGZvciAoOyBpIDwgakNhbExlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9oeWRyYXRlUHJvcGVydHkoaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXMgfHwgW107XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9yZW1vdmVPYmplY3RCeUluZGV4OiBmdW5jdGlvbihqQ2FsSW5kZXgsIGNhY2hlLCBpbmRleCkge1xuICAgICAgY2FjaGUgPSBjYWNoZSB8fCBbXTtcbiAgICAgIC8vIHJlbW92ZSBjYWNoZWQgdmVyc2lvblxuICAgICAgaWYgKGNhY2hlW2luZGV4XSkge1xuICAgICAgICB2YXIgb2JqID0gY2FjaGVbaW5kZXhdO1xuICAgICAgICBpZiAoXCJwYXJlbnRcIiBpbiBvYmopIHtcbiAgICAgICAgICAgIG9iai5wYXJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhY2hlLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgIC8vIHJlbW92ZSBpdCBmcm9tIHRoZSBqQ2FsXG4gICAgICB0aGlzLmpDYWxbakNhbEluZGV4XS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlT2JqZWN0OiBmdW5jdGlvbihqQ2FsSW5kZXgsIGNhY2hlLCBuYW1lT3JPYmplY3QpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBvYmplY3RzID0gdGhpcy5qQ2FsW2pDYWxJbmRleF07XG4gICAgICB2YXIgbGVuID0gb2JqZWN0cy5sZW5ndGg7XG4gICAgICB2YXIgY2FjaGVkID0gdGhpc1tjYWNoZV07XG5cbiAgICAgIGlmICh0eXBlb2YobmFtZU9yT2JqZWN0KSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChvYmplY3RzW2ldW05BTUVfSU5ERVhdID09PSBuYW1lT3JPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZU9iamVjdEJ5SW5kZXgoakNhbEluZGV4LCBjYWNoZWQsIGkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNhY2hlZCkge1xuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNhY2hlZFtpXSAmJiBjYWNoZWRbaV0gPT09IG5hbWVPck9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlT2JqZWN0QnlJbmRleChqQ2FsSW5kZXgsIGNhY2hlZCwgaSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlQWxsT2JqZWN0czogZnVuY3Rpb24oakNhbEluZGV4LCBjYWNoZSwgbmFtZSkge1xuICAgICAgdmFyIGNhY2hlZCA9IHRoaXNbY2FjaGVdO1xuXG4gICAgICAvLyBVbmZvcnR1bmF0ZWx5IHdlIGhhdmUgdG8gcnVuIHRocm91Z2ggYWxsIGNoaWxkcmVuIHRvIHJlc2V0IHRoZWlyXG4gICAgICAvLyBwYXJlbnQgcHJvcGVydHkuXG4gICAgICB2YXIgb2JqZWN0cyA9IHRoaXMuakNhbFtqQ2FsSW5kZXhdO1xuICAgICAgdmFyIGkgPSBvYmplY3RzLmxlbmd0aCAtIDE7XG5cbiAgICAgIC8vIGRlc2NlbmRpbmcgc2VhcmNoIHJlcXVpcmVkIGJlY2F1c2Ugc3BsaWNlXG4gICAgICAvLyBpcyB1c2VkIGFuZCB3aWxsIGVmZmVjdCB0aGUgaW5kaWNlcy5cbiAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoIW5hbWUgfHwgb2JqZWN0c1tpXVtOQU1FX0lOREVYXSA9PT0gbmFtZSkge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZU9iamVjdEJ5SW5kZXgoakNhbEluZGV4LCBjYWNoZWQsIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzaW5nbGUgc3ViIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnR9IGNvbXBvbmVudCAgICAgICAgVGhlIGNvbXBvbmVudCB0byBhZGRcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLkNvbXBvbmVudH0gICAgICAgICAgICAgICAgIFRoZSBwYXNzZWQgaW4gY29tcG9uZW50XG4gICAgICovXG4gICAgYWRkU3ViY29tcG9uZW50OiBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgIGlmICghdGhpcy5fY29tcG9uZW50cykge1xuICAgICAgICB0aGlzLl9jb21wb25lbnRzID0gW107XG4gICAgICAgIHRoaXMuX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tcG9uZW50LnBhcmVudCkge1xuICAgICAgICBjb21wb25lbnQucGFyZW50LnJlbW92ZVN1YmNvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWR4ID0gdGhpcy5qQ2FsW0NPTVBPTkVOVF9JTkRFWF0ucHVzaChjb21wb25lbnQuakNhbCk7XG4gICAgICB0aGlzLl9jb21wb25lbnRzW2lkeCAtIDFdID0gY29tcG9uZW50O1xuICAgICAgdGhpcy5faHlkcmF0ZWRDb21wb25lbnRDb3VudCsrO1xuICAgICAgY29tcG9uZW50LnBhcmVudCA9IHRoaXM7XG4gICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgc2luZ2xlIGNvbXBvbmVudCBieSBuYW1lIG9yIHRoZSBpbnN0YW5jZSBvZiBhIHNwZWNpZmljXG4gICAgICogY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudHxTdHJpbmd9IG5hbWVPckNvbXAgICAgTmFtZSBvZiBjb21wb25lbnQsIG9yIGNvbXBvbmVudFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRydWUgd2hlbiBjb21wIGlzIHJlbW92ZWRcbiAgICAgKi9cbiAgICByZW1vdmVTdWJjb21wb25lbnQ6IGZ1bmN0aW9uKG5hbWVPckNvbXApIHtcbiAgICAgIHZhciByZW1vdmVkID0gdGhpcy5fcmVtb3ZlT2JqZWN0KENPTVBPTkVOVF9JTkRFWCwgJ19jb21wb25lbnRzJywgbmFtZU9yQ29tcCk7XG4gICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICB0aGlzLl9oeWRyYXRlZENvbXBvbmVudENvdW50LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgY29tcG9uZW50cyBvciAoaWYgZ2l2ZW4pIGFsbCBjb21wb25lbnRzIGJ5IGEgcGFydGljdWxhclxuICAgICAqIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZz19IG5hbWUgICAgICAgICAgICBMb3dlcmNhc2UgY29tcG9uZW50IG5hbWVcbiAgICAgKi9cbiAgICByZW1vdmVBbGxTdWJjb21wb25lbnRzOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMuX3JlbW92ZUFsbE9iamVjdHMoQ09NUE9ORU5UX0lOREVYLCAnX2NvbXBvbmVudHMnLCBuYW1lKTtcbiAgICAgIHRoaXMuX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQgPSAwO1xuICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4ge0BsaW5rIElDQUwuUHJvcGVydHl9IHRvIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuUHJvcGVydHl9IHByb3BlcnR5ICAgICAgVGhlIHByb3BlcnR5IHRvIGFkZFxuICAgICAqIEByZXR1cm4ge0lDQUwuUHJvcGVydHl9ICAgICAgICAgICAgICBUaGUgcGFzc2VkIGluIHByb3BlcnR5XG4gICAgICovXG4gICAgYWRkUHJvcGVydHk6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICBpZiAoIShwcm9wZXJ0eSBpbnN0YW5jZW9mIElDQUwuUHJvcGVydHkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3QgaW5zdGFuY2Ugb2YgSUNBTC5Qcm9wZXJ0eScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX3Byb3BlcnRpZXMpIHtcbiAgICAgICAgdGhpcy5fcHJvcGVydGllcyA9IFtdO1xuICAgICAgICB0aGlzLl9oeWRyYXRlZFByb3BlcnR5Q291bnQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcGVydHkucGFyZW50KSB7XG4gICAgICAgIHByb3BlcnR5LnBhcmVudC5yZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpZHggPSB0aGlzLmpDYWxbUFJPUEVSVFlfSU5ERVhdLnB1c2gocHJvcGVydHkuakNhbCk7XG4gICAgICB0aGlzLl9wcm9wZXJ0aWVzW2lkeCAtIDFdID0gcHJvcGVydHk7XG4gICAgICB0aGlzLl9oeWRyYXRlZFByb3BlcnR5Q291bnQrKztcbiAgICAgIHByb3BlcnR5LnBhcmVudCA9IHRoaXM7XG4gICAgICByZXR1cm4gcHJvcGVydHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gYWRkIGEgcHJvcGVydHkgd2l0aCBhIHZhbHVlIHRvIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgICAgICBuYW1lICAgICAgICAgUHJvcGVydHkgbmFtZSB0byBhZGRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8T2JqZWN0fSB2YWx1ZSAgICAgICAgUHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlByb3BlcnR5fSAgICAgICAgICAgICAgICAgICAgVGhlIGNyZWF0ZWQgcHJvcGVydHlcbiAgICAgKi9cbiAgICBhZGRQcm9wZXJ0eVdpdGhWYWx1ZTogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBwcm9wID0gbmV3IElDQUwuUHJvcGVydHkobmFtZSk7XG4gICAgICBwcm9wLnNldFZhbHVlKHZhbHVlKTtcblxuICAgICAgdGhpcy5hZGRQcm9wZXJ0eShwcm9wKTtcblxuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdGhhdCB3aWxsIHVwZGF0ZSBvciBjcmVhdGUgYSBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW4gbmFtZVxuICAgICAqIGFuZCBzZXRzIGl0cyB2YWx1ZS4gSWYgbXVsdGlwbGUgcHJvcGVydGllcyB3aXRoIHRoZSBnaXZlbiBuYW1lIGV4aXN0LFxuICAgICAqIG9ubHkgdGhlIGZpcnN0IGlzIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgICAgICBuYW1lICAgICAgICAgUHJvcGVydHkgbmFtZSB0byB1cGRhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8T2JqZWN0fSB2YWx1ZSAgICAgICAgUHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlByb3BlcnR5fSAgICAgICAgICAgICAgICAgICAgVGhlIGNyZWF0ZWQgcHJvcGVydHlcbiAgICAgKi9cbiAgICB1cGRhdGVQcm9wZXJ0eVdpdGhWYWx1ZTogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBwcm9wID0gdGhpcy5nZXRGaXJzdFByb3BlcnR5KG5hbWUpO1xuXG4gICAgICBpZiAocHJvcCkge1xuICAgICAgICBwcm9wLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AgPSB0aGlzLmFkZFByb3BlcnR5V2l0aFZhbHVlKG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBzaW5nbGUgcHJvcGVydHkgYnkgbmFtZSBvciB0aGUgaW5zdGFuY2Ugb2YgdGhlIHNwZWNpZmljXG4gICAgICogcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xJQ0FMLlByb3BlcnR5fSBuYW1lT3JQcm9wICAgICBQcm9wZXJ0eSBuYW1lIG9yIGluc3RhbmNlIHRvIHJlbW92ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRydWUsIHdoZW4gZGVsZXRlZFxuICAgICAqL1xuICAgIHJlbW92ZVByb3BlcnR5OiBmdW5jdGlvbihuYW1lT3JQcm9wKSB7XG4gICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMuX3JlbW92ZU9iamVjdChQUk9QRVJUWV9JTkRFWCwgJ19wcm9wZXJ0aWVzJywgbmFtZU9yUHJvcCk7XG4gICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICB0aGlzLl9oeWRyYXRlZFByb3BlcnR5Q291bnQtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBwcm9wZXJ0aWVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbXBvbmVudCwgb3B0aW9uYWxseVxuICAgICAqIGZpbHRlcmVkIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZz19IG5hbWUgICAgICAgIExvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICBUcnVlLCB3aGVuIGRlbGV0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVBbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMuX3JlbW92ZUFsbE9iamVjdHMoUFJPUEVSVFlfSU5ERVgsICdfcHJvcGVydGllcycsIG5hbWUpO1xuICAgICAgdGhpcy5faHlkcmF0ZWRQcm9wZXJ0eUNvdW50ID0gMDtcbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb21wb25lbnQuIFRoZSByZXR1cm5lZCBvYmplY3RcbiAgICAgKiBpcyBhIGxpdmUgakNhbCBvYmplY3QgYW5kIHNob3VsZCBiZSBjbG9uZWQgaWYgbW9kaWZpZWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5qQ2FsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29tcG9uZW50LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gSUNBTC5zdHJpbmdpZnkuY29tcG9uZW50KFxuICAgICAgICB0aGlzLmpDYWwsIHRoaXMuX2Rlc2lnblNldFxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiB7QGxpbmsgSUNBTC5Db21wb25lbnR9IGJ5IHBhcnNpbmcgdGhlIHBhc3NlZCBpQ2FsZW5kYXIgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyICAgICAgICBUaGUgaUNhbGVuZGFyIHN0cmluZyB0byBwYXJzZVxuICAgKi9cbiAgQ29tcG9uZW50LmZyb21TdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IENvbXBvbmVudChJQ0FMLnBhcnNlLmNvbXBvbmVudChzdHIpKTtcbiAgfTtcblxuICByZXR1cm4gQ29tcG9uZW50O1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLlByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIE5BTUVfSU5ERVggPSAwO1xuICB2YXIgUFJPUF9JTkRFWCA9IDE7XG4gIHZhciBUWVBFX0lOREVYID0gMjtcbiAgdmFyIFZBTFVFX0lOREVYID0gMztcblxuICB2YXIgZGVzaWduID0gSUNBTC5kZXNpZ247XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogUHJvdmlkZXMgYSBsYXllciBvbiB0b3Agb2YgdGhlIHJhdyBqQ2FsIG9iamVjdCBmb3IgbWFuaXB1bGF0aW5nIGEgc2luZ2xlXG4gICAqIHByb3BlcnR5LCB3aXRoIGl0cyBwYXJhbWV0ZXJzIGFuZCB2YWx1ZS5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEl0IGlzIGltcG9ydGFudCB0byBub3RlIHRoYXQgbXV0YXRpb25zIGRvbmUgaW4gdGhlIHdyYXBwZXJcbiAgICogZGlyZWN0bHkgbXV0YXRlIHRoZSBqQ2FsIG9iamVjdCB1c2VkIHRvIGluaXRpYWxpemUuXG4gICAqXG4gICAqIENhbiBhbHNvIGJlIHVzZWQgdG8gY3JlYXRlIG5ldyBwcm9wZXJ0aWVzIGJ5IHBhc3NpbmdcbiAgICogdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IChhcyBhIFN0cmluZykuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAYWxpYXMgSUNBTC5Qcm9wZXJ0eVxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gakNhbCAgICAgICAgIFJhdyBqQ2FsIHJlcHJlc2VudGF0aW9uIE9SXG4gICAqICB0aGUgbmV3IG5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAqXG4gICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnQ9fSBwYXJlbnQgICAgUGFyZW50IGNvbXBvbmVudFxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcGVydHkoakNhbCwgcGFyZW50KSB7XG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG5cbiAgICBpZiAodHlwZW9mKGpDYWwpID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gV2UgYXJlIGNyZWF0aW5nIHRoZSBwcm9wZXJ0eSBieSBuYW1lIGFuZCBuZWVkIHRvIGRldGVjdCB0aGUgdHlwZVxuICAgICAgdGhpcy5qQ2FsID0gW2pDYWwsIHt9LCBkZXNpZ24uZGVmYXVsdFR5cGVdO1xuICAgICAgdGhpcy5qQ2FsW1RZUEVfSU5ERVhdID0gdGhpcy5nZXREZWZhdWx0VHlwZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmpDYWwgPSBqQ2FsO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVUeXBlKCk7XG4gIH1cblxuICBQcm9wZXJ0eS5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgdHlwZSBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5qQ2FsW1RZUEVfSU5ERVhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIHByb3BlcnR5LCBpbiBsb3dlcmNhc2UuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmpDYWxbTkFNRV9JTkRFWF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBwYXJlbnQgY29tcG9uZW50IGZvciB0aGlzIHByb3BlcnR5LlxuICAgICAqIEB0eXBlIHtJQ0FMLkNvbXBvbmVudH1cbiAgICAgKi9cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgICB9LFxuXG4gICAgc2V0IHBhcmVudChwKSB7XG4gICAgICAvLyBCZWZvcmUgc2V0dGluZyB0aGUgcGFyZW50LCBjaGVjayBpZiB0aGUgZGVzaWduIHNldCBoYXMgY2hhbmdlZC4gSWYgaXRcbiAgICAgIC8vIGhhcywgd2UgbGF0ZXIgbmVlZCB0byB1cGRhdGUgdGhlIHR5cGUgaWYgaXQgd2FzIHVua25vd24gYmVmb3JlLlxuICAgICAgdmFyIGRlc2lnblNldENoYW5nZWQgPSAhdGhpcy5fcGFyZW50IHx8IChwICYmIHAuX2Rlc2lnblNldCAhPSB0aGlzLl9wYXJlbnQuX2Rlc2lnblNldCk7XG5cbiAgICAgIHRoaXMuX3BhcmVudCA9IHA7XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT0gZGVzaWduLmRlZmF1bHRUeXBlICYmIGRlc2lnblNldENoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5qQ2FsW1RZUEVfSU5ERVhdID0gdGhpcy5nZXREZWZhdWx0VHlwZSgpO1xuICAgICAgICB0aGlzLl91cGRhdGVUeXBlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVzaWduIHNldCBmb3IgdGhpcyBwcm9wZXJ0eSwgZS5nLiBpY2FsZW5kYXIgdnMgdmNhcmRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXQgX2Rlc2lnblNldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50Ll9kZXNpZ25TZXQgOiBkZXNpZ24uZGVmYXVsdFNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdHlwZSBtZXRhZGF0YSBmcm9tIHRoZSBjdXJyZW50IGpDYWwgdHlwZSBhbmQgZGVzaWduIHNldC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZVR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRlc2lnblNldCA9IHRoaXMuX2Rlc2lnblNldDtcblxuICAgICAgaWYgKHRoaXMudHlwZSBpbiBkZXNpZ25TZXQudmFsdWUpIHtcbiAgICAgICAgdmFyIGRlc2lnblR5cGUgPSBkZXNpZ25TZXQudmFsdWVbdGhpcy50eXBlXTtcblxuICAgICAgICBpZiAoJ2RlY29yYXRlJyBpbiBkZXNpZ25TZXQudmFsdWVbdGhpcy50eXBlXSkge1xuICAgICAgICAgIHRoaXMuaXNEZWNvcmF0ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaXNEZWNvcmF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm5hbWUgaW4gZGVzaWduU2V0LnByb3BlcnR5KSB7XG4gICAgICAgICAgdGhpcy5pc011bHRpVmFsdWUgPSAoJ211bHRpVmFsdWUnIGluIGRlc2lnblNldC5wcm9wZXJ0eVt0aGlzLm5hbWVdKTtcbiAgICAgICAgICB0aGlzLmlzU3RydWN0dXJlZFZhbHVlID0gKCdzdHJ1Y3R1cmVkVmFsdWUnIGluIGRlc2lnblNldC5wcm9wZXJ0eVt0aGlzLm5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIeWRyYXRlIGEgc2luZ2xlIHZhbHVlLiBUaGUgYWN0IG9mIGh5ZHJhdGluZyBtZWFucyB0dXJuaW5nIHRoZSByYXcgakNhbFxuICAgICAqIHZhbHVlIGludG8gYSBwb3RlbnRpYWxseSB3cmFwcGVkIG9iamVjdCwgZm9yIGV4YW1wbGUge0BsaW5rIElDQUwuVGltZX0uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAgICAgICAgVGhlIGluZGV4IG9mIHRoZSB2YWx1ZSB0byBoeWRyYXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICBUaGUgZGVjb3JhdGVkIHZhbHVlLlxuICAgICAqL1xuICAgIF9oeWRyYXRlVmFsdWU6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpZiAodGhpcy5fdmFsdWVzICYmIHRoaXMuX3ZhbHVlc1tpbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlc1tpbmRleF07XG4gICAgICB9XG5cbiAgICAgIC8vIGZvciB0aGUgY2FzZSB3aGVyZSB0aGVyZSBpcyBubyB2YWx1ZS5cbiAgICAgIGlmICh0aGlzLmpDYWwubGVuZ3RoIDw9IChWQUxVRV9JTkRFWCArIGluZGV4KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNEZWNvcmF0ZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB0aGlzLl9kZWNvcmF0ZShcbiAgICAgICAgICB0aGlzLmpDYWxbVkFMVUVfSU5ERVggKyBpbmRleF1cbiAgICAgICAgKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5qQ2FsW1ZBTFVFX0lOREVYICsgaW5kZXhdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNvcmF0ZSBhIHNpbmdsZSB2YWx1ZSwgcmV0dXJuaW5nIGl0cyB3cmFwcGVkIG9iamVjdC4gVGhpcyBpcyB1c2VkIGJ5XG4gICAgICogdGhlIGh5ZHJhdGUgZnVuY3Rpb24gdG8gYWN0dWFsbHkgd3JhcCB0aGUgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWUgICAgICAgICBUaGUgdmFsdWUgdG8gZGVjb3JhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgVGhlIGRlY29yYXRlZCB2YWx1ZVxuICAgICAqL1xuICAgIF9kZWNvcmF0ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZXNpZ25TZXQudmFsdWVbdGhpcy50eXBlXS5kZWNvcmF0ZSh2YWx1ZSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVuZGVjb3JhdGUgYSBzaW5nbGUgdmFsdWUsIHJldHVybmluZyBpdHMgcmF3IGpDYWwgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlICAgICAgICAgVGhlIHZhbHVlIHRvIHVuZGVjb3JhdGVcbiAgICAgKiBAcmV0dXJuIHs/fSAgICAgICAgICAgICAgICAgICBUaGUgdW5kZWNvcmF0ZWQgdmFsdWVcbiAgICAgKi9cbiAgICBfdW5kZWNvcmF0ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZXNpZ25TZXQudmFsdWVbdGhpcy50eXBlXS51bmRlY29yYXRlKHZhbHVlLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIGluZGV4IHdoaWxlIGFsc28gaHlkcmF0aW5nIGl0LiBUaGUgcGFzc2VkXG4gICAgICogdmFsdWUgY2FuIGVpdGhlciBiZSBhIGRlY29yYXRlZCBvciB1bmRlY29yYXRlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZSAgICAgICAgICAgICBUaGUgdmFsdWUgdG8gc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4ICAgICAgICBUaGUgaW5kZXggdG8gc2V0IGl0IGF0XG4gICAgICovXG4gICAgX3NldERlY29yYXRlZFZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgIGlmICghdGhpcy5fdmFsdWVzKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgJ2ljYWx0eXBlJyBpbiB2YWx1ZSkge1xuICAgICAgICAvLyBkZWNvcmF0ZWQgdmFsdWVcbiAgICAgICAgdGhpcy5qQ2FsW1ZBTFVFX0lOREVYICsgaW5kZXhdID0gdGhpcy5fdW5kZWNvcmF0ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVuZGVjb3JhdGVkIHZhbHVlXG4gICAgICAgIHRoaXMuakNhbFtWQUxVRV9JTkRFWCArIGluZGV4XSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gdGhpcy5fZGVjb3JhdGUodmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcGFyYW1ldGVyIG9uIHRoZSBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgbmFtZSAgIFBhcmFtZXRlciBuYW1lIChsb3dlcmNhc2UpXG4gICAgICogQHJldHVybiB7QXJyYXl8U3RyaW5nfSAgICAgICAgUGFyYW1ldGVyIHZhbHVlXG4gICAgICovXG4gICAgZ2V0UGFyYW1ldGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBpZiAobmFtZSBpbiB0aGlzLmpDYWxbUFJPUF9JTkRFWF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuakNhbFtQUk9QX0lOREVYXVtuYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgZmlyc3QgcGFyYW1ldGVyIG9uIHRoZSBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgbmFtZSAgIFBhcmFtZXRlciBuYW1lIChsb3dlcmNhc2UpXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgUGFyYW1ldGVyIHZhbHVlXG4gICAgICovXG4gICAgZ2V0Rmlyc3RQYXJhbWV0ZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy5nZXRQYXJhbWV0ZXIobmFtZSk7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnMpKSB7XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzWzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyYW1ldGVycztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHBhcmFtZXRlciBvbiB0aGUgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgbmFtZSAgICAgVGhlIHBhcmFtZXRlciBuYW1lXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IHZhbHVlICAgIFRoZSBwYXJhbWV0ZXIgdmFsdWVcbiAgICAgKi9cbiAgICBzZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgbGNuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgIGxjbmFtZSBpbiB0aGlzLl9kZXNpZ25TZXQucGFyYW0gJiZcbiAgICAgICAgICAnbXVsdGlWYWx1ZScgaW4gdGhpcy5fZGVzaWduU2V0LnBhcmFtW2xjbmFtZV0pIHtcbiAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICB9XG4gICAgICB0aGlzLmpDYWxbUFJPUF9JTkRFWF1bbmFtZV0gPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHBhcmFtZXRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgICAgIFRoZSBwYXJhbWV0ZXIgbmFtZVxuICAgICAqL1xuICAgIHJlbW92ZVBhcmFtZXRlcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgZGVsZXRlIHRoaXMuakNhbFtQUk9QX0lOREVYXVtuYW1lXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkZWZhdWx0IHR5cGUgYmFzZWQgb24gdGhpcyBwcm9wZXJ0eSdzIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICBUaGUgZGVmYXVsdCB0eXBlIGZvciB0aGlzIHByb3BlcnR5XG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5hbWUgPSB0aGlzLmpDYWxbTkFNRV9JTkRFWF07XG4gICAgICB2YXIgZGVzaWduU2V0ID0gdGhpcy5fZGVzaWduU2V0O1xuXG4gICAgICBpZiAobmFtZSBpbiBkZXNpZ25TZXQucHJvcGVydHkpIHtcbiAgICAgICAgdmFyIGRldGFpbHMgPSBkZXNpZ25TZXQucHJvcGVydHlbbmFtZV07XG4gICAgICAgIGlmICgnZGVmYXVsdFR5cGUnIGluIGRldGFpbHMpIHtcbiAgICAgICAgICByZXR1cm4gZGV0YWlscy5kZWZhdWx0VHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2lnbi5kZWZhdWx0VHlwZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0eXBlIG9mIHByb3BlcnR5IGFuZCBjbGVhcnMgb3V0IGFueSBleGlzdGluZyB2YWx1ZXMgb2YgdGhlIGN1cnJlbnRcbiAgICAgKiB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgICAgIE5ldyBpQ0FMIHR5cGUgKHNlZSBkZXNpZ24uKi52YWx1ZXMpXG4gICAgICovXG4gICAgcmVzZXRUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB0aGlzLnJlbW92ZUFsbFZhbHVlcygpO1xuICAgICAgdGhpcy5qQ2FsW1RZUEVfSU5ERVhdID0gdHlwZTtcbiAgICAgIHRoaXMuX3VwZGF0ZVR5cGUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGZpcnN0IHByb3BlcnR5IHZhbHVlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgIEZpcnN0IHByb3BlcnR5IHZhbHVlXG4gICAgICovXG4gICAgZ2V0Rmlyc3RWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5faHlkcmF0ZVZhbHVlKDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCB2YWx1ZXMgb24gdGhlIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogTk9URTogdGhpcyBjcmVhdGVzIGFuIGFycmF5IGR1cmluZyBlYWNoIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgTGlzdCBvZiB2YWx1ZXNcbiAgICAgKi9cbiAgICBnZXRWYWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlbiA9IHRoaXMuakNhbC5sZW5ndGggLSBWQUxVRV9JTkRFWDtcblxuICAgICAgaWYgKGxlbiA8IDEpIHtcbiAgICAgICAgLy8gaXQgaXMgcG9zc2libGUgZm9yIGEgcHJvcGVydHkgdG8gaGF2ZSBubyB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcmVzdWx0W2ldID0gdGhpcy5faHlkcmF0ZVZhbHVlKGkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCB2YWx1ZXMgZnJvbSB0aGlzIHByb3BlcnR5XG4gICAgICovXG4gICAgcmVtb3ZlQWxsVmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLmpDYWwubGVuZ3RoID0gMztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0eS4gIFdpbGwgb3ZlcndyaXRlIHRoZSBleGlzdGluZyB2YWx1ZXMuXG4gICAgICogVGhpcyBjYW4gb25seSBiZSB1c2VkIGZvciBtdWx0aS12YWx1ZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzICAgIEFuIGFycmF5IG9mIHZhbHVlc1xuICAgICAqL1xuICAgIHNldFZhbHVlczogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICBpZiAoIXRoaXMuaXNNdWx0aVZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICB0aGlzLm5hbWUgKyAnOiBkb2VzIG5vdCBub3Qgc3VwcG9ydCBtdWxpdFZhbHVlLlxcbicgK1xuICAgICAgICAgICdvdmVycmlkZSBpc011bHRpVmFsdWUnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdGhpcy5yZW1vdmVBbGxWYWx1ZXMoKTtcblxuICAgICAgaWYgKGxlbiA+IDAgJiZcbiAgICAgICAgICB0eXBlb2YodmFsdWVzWzBdKSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAnaWNhbHR5cGUnIGluIHZhbHVlc1swXSkge1xuICAgICAgICB0aGlzLnJlc2V0VHlwZSh2YWx1ZXNbMF0uaWNhbHR5cGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc0RlY29yYXRlZCkge1xuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5fc2V0RGVjb3JhdGVkVmFsdWUodmFsdWVzW2ldLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHRoaXMuakNhbFtWQUxVRV9JTkRFWCArIGldID0gdmFsdWVzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHByb3BlcnR5LiBJZiB0aGlzIGlzIGEgbXVsdGktdmFsdWVcbiAgICAgKiBwcm9wZXJ0eSwgYWxsIG90aGVyIHZhbHVlcyB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHZhbHVlICAgICBOZXcgcHJvcGVydHkgdmFsdWUuXG4gICAgICovXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLnJlbW92ZUFsbFZhbHVlcygpO1xuICAgICAgaWYgKHR5cGVvZih2YWx1ZSkgPT09ICdvYmplY3QnICYmICdpY2FsdHlwZScgaW4gdmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZXNldFR5cGUodmFsdWUuaWNhbHR5cGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc0RlY29yYXRlZCkge1xuICAgICAgICB0aGlzLl9zZXREZWNvcmF0ZWRWYWx1ZSh2YWx1ZSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmpDYWxbVkFMVUVfSU5ERVhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudC4gVGhlIHJldHVybmVkIG9iamVjdFxuICAgICAqIGlzIGEgbGl2ZSBqQ2FsIG9iamVjdCBhbmQgc2hvdWxkIGJlIGNsb25lZCBpZiBtb2RpZmllZC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmpDYWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb21wb25lbnQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvSUNBTFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gSUNBTC5zdHJpbmdpZnkucHJvcGVydHkoXG4gICAgICAgIHRoaXMuakNhbCwgdGhpcy5fZGVzaWduU2V0LCB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIHtAbGluayBJQ0FMLlByb3BlcnR5fSBieSBwYXJzaW5nIHRoZSBwYXNzZWQgaUNhbGVuZGFyIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBpQ2FsZW5kYXIgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0PX0gZGVzaWduU2V0ICBUaGUgZGVzaWduIGRhdGEgdG8gdXNlIGZvciB0aGlzIHByb3BlcnR5XG4gICAqIEByZXR1cm4ge0lDQUwuUHJvcGVydHl9ICAgICAgICAgICAgICAgICAgICBUaGUgY3JlYXRlZCBpQ2FsZW5kYXIgcHJvcGVydHlcbiAgICovXG4gIFByb3BlcnR5LmZyb21TdHJpbmcgPSBmdW5jdGlvbihzdHIsIGRlc2lnblNldCkge1xuICAgIHJldHVybiBuZXcgUHJvcGVydHkoSUNBTC5wYXJzZS5wcm9wZXJ0eShzdHIsIGRlc2lnblNldCkpO1xuICB9O1xuXG4gIHJldHVybiBQcm9wZXJ0eTtcbn0oKSk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG5cbi8qKlxuICogVGhpcyBzeW1ib2wgaXMgZnVydGhlciBkZXNjcmliZWQgbGF0ZXIgb25cbiAqIEBpZ25vcmVcbiAqL1xuSUNBTC5VdGNPZmZzZXQgPSAoZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBcImR1cmF0aW9uXCIgdmFsdWUgdHlwZSwgd2l0aCB2YXJpb3VzIGNhbGN1bGF0aW9uXG4gICAqIGFuZCBtYW5pcHVsYXRpb24gbWV0aG9kcy5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBhbGlhcyBJQ0FMLlV0Y09mZnNldFxuICAgKiBAcGFyYW0ge09iamVjdH0gYURhdGEgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgdXRjIG9mZnNldFxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmhvdXJzICAgVGhlIGhvdXJzIGZvciB0aGUgdXRjIG9mZnNldFxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLm1pbnV0ZXMgVGhlIG1pbnV0ZXMgaW4gdGhlIHV0YyBvZmZzZXRcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5mYWN0b3IgIFRoZSBmYWN0b3IgZm9yIHRoZSB1dGMtb2Zmc2V0LCBlaXRoZXIgLTEgb3IgMVxuICAgKi9cbiAgZnVuY3Rpb24gVXRjT2Zmc2V0KGFEYXRhKSB7XG4gICAgdGhpcy5mcm9tRGF0YShhRGF0YSk7XG4gIH1cblxuICBVdGNPZmZzZXQucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogVGhlIGhvdXJzIGluIHRoZSB1dGMtb2Zmc2V0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBob3VyczogMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBtaW51dGVzIGluIHRoZSB1dGMtb2Zmc2V0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBtaW51dGVzOiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNpZ24gb2YgdGhlIHV0YyBvZmZzZXQsIDEgZm9yIHBvc2l0aXZlIG9mZnNldCwgLTEgZm9yIG5lZ2F0aXZlXG4gICAgICogb2Zmc2V0cy5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGZhY3RvcjogMSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG5hbWUsIHRvIGJlIHVzZWQgaW4gdGhlIGpDYWwgb2JqZWN0LlxuICAgICAqIEBjb25zdGFudFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJ1dGMtb2Zmc2V0XCJcbiAgICAgKi9cbiAgICBpY2FsdHlwZTogXCJ1dGMtb2Zmc2V0XCIsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIHV0YyBvZmZzZXQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7SUNBTC5VdGNPZmZzZXR9ICAgICBUaGUgY2xvbmVkIG9iamVjdFxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJQ0FMLlV0Y09mZnNldC5mcm9tU2Vjb25kcyh0aGlzLnRvU2Vjb25kcygpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSB1c2luZyBtZW1iZXJzIGZyb20gdGhlIHBhc3NlZCBkYXRhIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBtZW1iZXJzIG9mIHRoZSB1dGMgb2Zmc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5ob3VycyAgIFRoZSBob3VycyBmb3IgdGhlIHV0YyBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLm1pbnV0ZXMgVGhlIG1pbnV0ZXMgaW4gdGhlIHV0YyBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmZhY3RvciAgVGhlIGZhY3RvciBmb3IgdGhlIHV0Yy1vZmZzZXQsIGVpdGhlciAtMSBvciAxXG4gICAgICovXG4gICAgZnJvbURhdGE6IGZ1bmN0aW9uKGFEYXRhKSB7XG4gICAgICBpZiAoYURhdGEpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGFEYXRhKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICBpZiAoYURhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgdGhpc1trZXldID0gYURhdGFba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX25vcm1hbGl6ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIHNlY29uZHMgdmFsdWUuIFRoZSBzZWNvbmRzXG4gICAgICogdmFsdWUgaXMgdHJ1bmNhdGVkIHRvIHRoZSBtaW51dGUuIE9mZnNldHMgYXJlIHdyYXBwZWQgd2hlbiB0aGUgd29ybGRcbiAgICAgKiBlbmRzLCB0aGUgaG91ciBhZnRlciBVVEMrMTQ6MDAgaXMgVVRDLTEyOjAwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFTZWNvbmRzICAgICAgICAgVGhlIHNlY29uZHMgdG8gY29udmVydCBpbnRvIGFuIG9mZnNldFxuICAgICAqL1xuICAgIGZyb21TZWNvbmRzOiBmdW5jdGlvbihhU2Vjb25kcykge1xuICAgICAgdmFyIHNlY3MgPSBNYXRoLmFicyhhU2Vjb25kcyk7XG5cbiAgICAgIHRoaXMuZmFjdG9yID0gYVNlY29uZHMgPCAwID8gLTEgOiAxO1xuICAgICAgdGhpcy5ob3VycyA9IElDQUwuaGVscGVycy50cnVuYyhzZWNzIC8gMzYwMCk7XG5cbiAgICAgIHNlY3MgLT0gKHRoaXMuaG91cnMgKiAzNjAwKTtcbiAgICAgIHRoaXMubWludXRlcyA9IElDQUwuaGVscGVycy50cnVuYyhzZWNzIC8gNjApO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGN1cnJlbnQgb2Zmc2V0IHRvIGEgdmFsdWUgaW4gc2Vjb25kc1xuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgICAgVGhlIG9mZnNldCBpbiBzZWNvbmRzXG4gICAgICovXG4gICAgdG9TZWNvbmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZhY3RvciAqICg2MCAqIHRoaXMubWludXRlcyArIDM2MDAgKiB0aGlzLmhvdXJzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZSB0aGlzIHV0YyBvZmZzZXQgd2l0aCBhbm90aGVyIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5VdGNPZmZzZXR9IG90aGVyICAgICAgICBUaGUgb3RoZXIgb2Zmc2V0IHRvIGNvbXBhcmUgd2l0aFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAtMSwgMCBvciAxIGZvciBsZXNzL2VxdWFsL2dyZWF0ZXJcbiAgICAgKi9cbiAgICBjb21wYXJlOiBmdW5jdGlvbiBpY2FsdGltZV9jb21wYXJlKG90aGVyKSB7XG4gICAgICB2YXIgYSA9IHRoaXMudG9TZWNvbmRzKCk7XG4gICAgICB2YXIgYiA9IG90aGVyLnRvU2Vjb25kcygpO1xuICAgICAgcmV0dXJuIChhID4gYikgLSAoYiA+IGEpO1xuICAgIH0sXG5cbiAgICBfbm9ybWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFJhbmdlOiA5NzIwMCBzZWNvbmRzICh3aXRoIDEgaG91ciBpbmJldHdlZW4pXG4gICAgICB2YXIgc2VjcyA9IHRoaXMudG9TZWNvbmRzKCk7XG4gICAgICB2YXIgZmFjdG9yID0gdGhpcy5mYWN0b3I7XG4gICAgICB3aGlsZSAoc2VjcyA8IC00MzIwMCkgeyAvLyA9IFVUQy0xMjowMFxuICAgICAgICBzZWNzICs9IDk3MjAwO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHNlY3MgPiA1MDQwMCkgeyAvLyA9IFVUQysxNDowMFxuICAgICAgICBzZWNzIC09IDk3MjAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZyb21TZWNvbmRzKHNlY3MpO1xuXG4gICAgICAvLyBBdm9pZCBjaGFuZ2luZyB0aGUgZmFjdG9yIHdoZW4gb24gemVybyBzZWNvbmRzXG4gICAgICBpZiAoc2VjcyA9PSAwKSB7XG4gICAgICAgIHRoaXMuZmFjdG9yID0gZmFjdG9yO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaUNhbGVuZGFyIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHV0Yy1vZmZzZXQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvSUNBTFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gSUNBTC5kZXNpZ24uaWNhbGVuZGFyLnZhbHVlWyd1dGMtb2Zmc2V0J10udG9JQ0FMKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB1dGMtb2Zmc2V0LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuZmFjdG9yID09IDEgPyBcIitcIiA6IFwiLVwiKSArXG4gICAgICAgICAgICAgIElDQUwuaGVscGVycy5wYWQyKHRoaXMuaG91cnMpICsgJzonICtcbiAgICAgICAgICAgICAgSUNBTC5oZWxwZXJzLnBhZDIodGhpcy5taW51dGVzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIElDQUwuVXRjT2Zmc2V0fSBpbnN0YW5jZSBmcm9tIHRoZSBwYXNzZWQgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVN0cmluZyAgICBUaGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEByZXR1cm4ge0lDQUwuRHVyYXRpb259ICAgIFRoZSBjcmVhdGVkIHV0Yy1vZmZzZXQgaW5zdGFuY2VcbiAgICovXG4gIFV0Y09mZnNldC5mcm9tU3RyaW5nID0gZnVuY3Rpb24oYVN0cmluZykge1xuICAgIC8vIC0wNTowMFxuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgLy9UT0RPOiBzdXBwb3J0IHNlY29uZHMgcGVyIHJmYzU1NDUgP1xuICAgIG9wdGlvbnMuZmFjdG9yID0gKGFTdHJpbmdbMF0gPT09ICcrJykgPyAxIDogLTE7XG4gICAgb3B0aW9ucy5ob3VycyA9IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChhU3RyaW5nLnN1YnN0cigxLCAyKSk7XG4gICAgb3B0aW9ucy5taW51dGVzID0gSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KGFTdHJpbmcuc3Vic3RyKDQsIDIpKTtcblxuICAgIHJldHVybiBuZXcgSUNBTC5VdGNPZmZzZXQob3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIElDQUwuVXRjT2Zmc2V0fSBpbnN0YW5jZSBmcm9tIHRoZSBwYXNzZWQgc2Vjb25kc1xuICAgKiB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFTZWNvbmRzICAgICAgIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB0byBjb252ZXJ0XG4gICAqL1xuICBVdGNPZmZzZXQuZnJvbVNlY29uZHMgPSBmdW5jdGlvbihhU2Vjb25kcykge1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBVdGNPZmZzZXQoKTtcbiAgICBpbnN0YW5jZS5mcm9tU2Vjb25kcyhhU2Vjb25kcyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIHJldHVybiBVdGNPZmZzZXQ7XG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG4vKipcbiAqIFRoaXMgc3ltYm9sIGlzIGZ1cnRoZXIgZGVzY3JpYmVkIGxhdGVyIG9uXG4gKiBAaWdub3JlXG4gKi9cbklDQUwuQmluYXJ5ID0gKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFJlcHJlc2VudHMgdGhlIEJJTkFSWSB2YWx1ZSB0eXBlLCB3aGljaCBjb250YWlucyBleHRyYSBtZXRob2RzIGZvclxuICAgKiBlbmNvZGluZyBhbmQgZGVjb2RpbmcuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAYWxpYXMgSUNBTC5CaW5hcnlcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFWYWx1ZSAgICAgVGhlIGJpbmFyeSBkYXRhIGZvciB0aGlzIHZhbHVlXG4gICAqL1xuICBmdW5jdGlvbiBCaW5hcnkoYVZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IGFWYWx1ZTtcbiAgfVxuXG4gIEJpbmFyeS5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgbmFtZSwgdG8gYmUgdXNlZCBpbiB0aGUgakNhbCBvYmplY3QuXG4gICAgICogQGRlZmF1bHQgXCJiaW5hcnlcIlxuICAgICAqIEBjb25zdGFudFxuICAgICAqL1xuICAgIGljYWx0eXBlOiBcImJpbmFyeVwiLFxuXG4gICAgLyoqXG4gICAgICogQmFzZTY0IGRlY29kZSB0aGUgY3VycmVudCB2YWx1ZVxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgIFRoZSBiYXNlNjQtZGVjb2RlZCB2YWx1ZVxuICAgICAqL1xuICAgIGRlY29kZVZhbHVlOiBmdW5jdGlvbiBkZWNvZGVWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9iNjRfZGVjb2RlKHRoaXMudmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSBwYXNzZWQgcGFyYW1ldGVyIHdpdGggYmFzZTY0IGFuZCBzZXRzIHRoZSBpbnRlcm5hbFxuICAgICAqIHZhbHVlIHRvIHRoZSByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYVZhbHVlICAgICAgVGhlIHJhdyBiaW5hcnkgdmFsdWUgdG8gZW5jb2RlXG4gICAgICovXG4gICAgc2V0RW5jb2RlZFZhbHVlOiBmdW5jdGlvbiBzZXRFbmNvZGVkVmFsdWUoYVZhbHVlKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5fYjY0X2VuY29kZShhVmFsdWUpO1xuICAgIH0sXG5cbiAgICBfYjY0X2VuY29kZTogZnVuY3Rpb24gYmFzZTY0X2VuY29kZShkYXRhKSB7XG4gICAgICAvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldFxuICAgICAgLy8gKyAgIG9yaWdpbmFsIGJ5OiBUeWxlciBBa2lucyAoaHR0cDovL3J1bWtpbi5jb20pXG4gICAgICAvLyArICAgaW1wcm92ZWQgYnk6IEJheXJvbiBHdWV2YXJhXG4gICAgICAvLyArICAgaW1wcm92ZWQgYnk6IFRodW5kZXIubVxuICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgICAgIC8vICsgICBidWdmaXhlZCBieTogUGVsbGVudGVzcXVlIE1hbGVzdWFkYVxuICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgICAgIC8vICsgICBpbXByb3ZlZCBieTogUmFmYcWCIEt1a2F3c2tpIChodHRwOi8va3VrYXdza2kucGwpXG4gICAgICAvLyAqICAgICBleGFtcGxlIDE6IGJhc2U2NF9lbmNvZGUoJ0tldmluIHZhbiBab25uZXZlbGQnKTtcbiAgICAgIC8vICogICAgIHJldHVybnMgMTogJ1MyVjJhVzRnZG1GdUlGcHZibTVsZG1Wc1pBPT0nXG4gICAgICAvLyBtb3ppbGxhIGhhcyB0aGlzIG5hdGl2ZVxuICAgICAgLy8gLSBidXQgYnJlYWtzIGluIDIuMC4wLjEyIVxuICAgICAgLy9pZiAodHlwZW9mIHRoaXMud2luZG93WydhdG9iJ10gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gICAgcmV0dXJuIGF0b2IoZGF0YSk7XG4gICAgICAvL31cbiAgICAgIHZhciBiNjQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCIgK1xuICAgICAgICAgICAgICAgIFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG4gICAgICB2YXIgbzEsIG8yLCBvMywgaDEsIGgyLCBoMywgaDQsIGJpdHMsIGkgPSAwLFxuICAgICAgICBhYyA9IDAsXG4gICAgICAgIGVuYyA9IFwiXCIsXG4gICAgICAgIHRtcF9hcnIgPSBbXTtcblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuXG4gICAgICBkbyB7IC8vIHBhY2sgdGhyZWUgb2N0ZXRzIGludG8gZm91ciBoZXhldHNcbiAgICAgICAgbzEgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgbzIgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgbzMgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcblxuICAgICAgICBiaXRzID0gbzEgPDwgMTYgfCBvMiA8PCA4IHwgbzM7XG5cbiAgICAgICAgaDEgPSBiaXRzID4+IDE4ICYgMHgzZjtcbiAgICAgICAgaDIgPSBiaXRzID4+IDEyICYgMHgzZjtcbiAgICAgICAgaDMgPSBiaXRzID4+IDYgJiAweDNmO1xuICAgICAgICBoNCA9IGJpdHMgJiAweDNmO1xuXG4gICAgICAgIC8vIHVzZSBoZXhldHMgdG8gaW5kZXggaW50byBiNjQsIGFuZCBhcHBlbmQgcmVzdWx0IHRvIGVuY29kZWQgc3RyaW5nXG4gICAgICAgIHRtcF9hcnJbYWMrK10gPSBiNjQuY2hhckF0KGgxKSArIGI2NC5jaGFyQXQoaDIpICsgYjY0LmNoYXJBdChoMykgKyBiNjQuY2hhckF0KGg0KTtcbiAgICAgIH0gd2hpbGUgKGkgPCBkYXRhLmxlbmd0aCk7XG5cbiAgICAgIGVuYyA9IHRtcF9hcnIuam9pbignJyk7XG5cbiAgICAgIHZhciByID0gZGF0YS5sZW5ndGggJSAzO1xuXG4gICAgICByZXR1cm4gKHIgPyBlbmMuc2xpY2UoMCwgciAtIDMpIDogZW5jKSArICc9PT0nLnNsaWNlKHIgfHwgMyk7XG5cbiAgICB9LFxuXG4gICAgX2I2NF9kZWNvZGU6IGZ1bmN0aW9uIGJhc2U2NF9kZWNvZGUoZGF0YSkge1xuICAgICAgLy8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXRcbiAgICAgIC8vICsgICBvcmlnaW5hbCBieTogVHlsZXIgQWtpbnMgKGh0dHA6Ly9ydW1raW4uY29tKVxuICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBUaHVuZGVyLm1cbiAgICAgIC8vICsgICAgICBpbnB1dCBieTogQW1hbiBHdXB0YVxuICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgICAgIC8vICsgICBidWdmaXhlZCBieTogT25ubyBNYXJzbWFuXG4gICAgICAvLyArICAgYnVnZml4ZWQgYnk6IFBlbGxlbnRlc3F1ZSBNYWxlc3VhZGFcbiAgICAgIC8vICsgICBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG4gICAgICAvLyArICAgICAgaW5wdXQgYnk6IEJyZXR0IFphbWlyIChodHRwOi8vYnJldHQtemFtaXIubWUpXG4gICAgICAvLyArICAgYnVnZml4ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAgICAgLy8gKiAgICAgZXhhbXBsZSAxOiBiYXNlNjRfZGVjb2RlKCdTMlYyYVc0Z2RtRnVJRnB2Ym01bGRtVnNaQT09Jyk7XG4gICAgICAvLyAqICAgICByZXR1cm5zIDE6ICdLZXZpbiB2YW4gWm9ubmV2ZWxkJ1xuICAgICAgLy8gbW96aWxsYSBoYXMgdGhpcyBuYXRpdmVcbiAgICAgIC8vIC0gYnV0IGJyZWFrcyBpbiAyLjAuMC4xMiFcbiAgICAgIC8vaWYgKHR5cGVvZiB0aGlzLndpbmRvd1snYnRvYSddID09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vICAgIHJldHVybiBidG9hKGRhdGEpO1xuICAgICAgLy99XG4gICAgICB2YXIgYjY0ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiICtcbiAgICAgICAgICAgICAgICBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO1xuICAgICAgdmFyIG8xLCBvMiwgbzMsIGgxLCBoMiwgaDMsIGg0LCBiaXRzLCBpID0gMCxcbiAgICAgICAgYWMgPSAwLFxuICAgICAgICBkZWMgPSBcIlwiLFxuICAgICAgICB0bXBfYXJyID0gW107XG5cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cblxuICAgICAgZGF0YSArPSAnJztcblxuICAgICAgZG8geyAvLyB1bnBhY2sgZm91ciBoZXhldHMgaW50byB0aHJlZSBvY3RldHMgdXNpbmcgaW5kZXggcG9pbnRzIGluIGI2NFxuICAgICAgICBoMSA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuICAgICAgICBoMiA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuICAgICAgICBoMyA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuICAgICAgICBoNCA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuXG4gICAgICAgIGJpdHMgPSBoMSA8PCAxOCB8IGgyIDw8IDEyIHwgaDMgPDwgNiB8IGg0O1xuXG4gICAgICAgIG8xID0gYml0cyA+PiAxNiAmIDB4ZmY7XG4gICAgICAgIG8yID0gYml0cyA+PiA4ICYgMHhmZjtcbiAgICAgICAgbzMgPSBiaXRzICYgMHhmZjtcblxuICAgICAgICBpZiAoaDMgPT0gNjQpIHtcbiAgICAgICAgICB0bXBfYXJyW2FjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShvMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaDQgPT0gNjQpIHtcbiAgICAgICAgICB0bXBfYXJyW2FjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShvMSwgbzIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRtcF9hcnJbYWMrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG8xLCBvMiwgbzMpO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChpIDwgZGF0YS5sZW5ndGgpO1xuXG4gICAgICBkZWMgPSB0bXBfYXJyLmpvaW4oJycpO1xuXG4gICAgICByZXR1cm4gZGVjO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgYmluYXJ5IHZhbHVlIGZyb20gdGhlIGdpdmVuIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFTdHJpbmcgICAgICAgIFRoZSBiaW5hcnkgdmFsdWUgc3RyaW5nXG4gICAqIEByZXR1cm4ge0lDQUwuQmluYXJ5fSAgICAgICAgICBUaGUgYmluYXJ5IHZhbHVlIGluc3RhbmNlXG4gICAqL1xuICBCaW5hcnkuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKGFTdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IEJpbmFyeShhU3RyaW5nKTtcbiAgfTtcblxuICByZXR1cm4gQmluYXJ5O1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuXG4oZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgXCJwZXJpb2RcIiB2YWx1ZSB0eXBlLCB3aXRoIHZhcmlvdXMgY2FsY3VsYXRpb25cbiAgICogYW5kIG1hbmlwdWxhdGlvbiBtZXRob2RzLlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIHBhc3NlZCBkYXRhIG9iamVjdCBjYW5ub3QgY29udGFpbiBib3RoIGFuZCBlbmQgZGF0ZSBhbmQgYSBkdXJhdGlvbi5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHBlcmlvZFxuICAgKiBAcGFyYW0ge0lDQUwuVGltZT19IGFEYXRhLnN0YXJ0ICAgICAgICBUaGUgc3RhcnQgb2YgdGhlIHBlcmlvZFxuICAgKiBAcGFyYW0ge0lDQUwuVGltZT19IGFEYXRhLmVuZCAgICAgICAgICBUaGUgZW5kIG9mIHRoZSBwZXJpb2RcbiAgICogQHBhcmFtIHtJQ0FMLkR1cmF0aW9uPX0gYURhdGEuZHVyYXRpb24gVGhlIGR1cmF0aW9uIG9mIHRoZSBwZXJpb2RcbiAgICovXG4gIElDQUwuUGVyaW9kID0gZnVuY3Rpb24gaWNhbHBlcmlvZChhRGF0YSkge1xuICAgIHRoaXMud3JhcHBlZEpTT2JqZWN0ID0gdGhpcztcblxuICAgIGlmIChhRGF0YSAmJiAnc3RhcnQnIGluIGFEYXRhKSB7XG4gICAgICBpZiAoYURhdGEuc3RhcnQgJiYgIShhRGF0YS5zdGFydCBpbnN0YW5jZW9mIElDQUwuVGltZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignLnN0YXJ0IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgSUNBTC5UaW1lJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXJ0ID0gYURhdGEuc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKGFEYXRhICYmIGFEYXRhLmVuZCAmJiBhRGF0YS5kdXJhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgYWNjZXB0IGJvdGggZW5kIGFuZCBkdXJhdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChhRGF0YSAmJiAnZW5kJyBpbiBhRGF0YSkge1xuICAgICAgaWYgKGFEYXRhLmVuZCAmJiAhKGFEYXRhLmVuZCBpbnN0YW5jZW9mIElDQUwuVGltZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignLmVuZCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIElDQUwuVGltZScpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbmQgPSBhRGF0YS5lbmQ7XG4gICAgfVxuXG4gICAgaWYgKGFEYXRhICYmICdkdXJhdGlvbicgaW4gYURhdGEpIHtcbiAgICAgIGlmIChhRGF0YS5kdXJhdGlvbiAmJiAhKGFEYXRhLmR1cmF0aW9uIGluc3RhbmNlb2YgSUNBTC5EdXJhdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignLmR1cmF0aW9uIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgSUNBTC5EdXJhdGlvbicpO1xuICAgICAgfVxuICAgICAgdGhpcy5kdXJhdGlvbiA9IGFEYXRhLmR1cmF0aW9uO1xuICAgIH1cbiAgfTtcblxuICBJQ0FMLlBlcmlvZC5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RhcnQgb2YgdGhlIHBlcmlvZFxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgc3RhcnQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZW5kIG9mIHRoZSBwZXJpb2RcbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lfVxuICAgICAqL1xuICAgIGVuZDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkdXJhdGlvbiBvZiB0aGUgcGVyaW9kXG4gICAgICogQHR5cGUge0lDQUwuRHVyYXRpb259XG4gICAgICovXG4gICAgZHVyYXRpb246IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgaWRlbnRpZmllci5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwiaWNhbHBlcmlvZFwiXG4gICAgICovXG4gICAgaWNhbGNsYXNzOiBcImljYWxwZXJpb2RcIixcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG5hbWUsIHRvIGJlIHVzZWQgaW4gdGhlIGpDYWwgb2JqZWN0LlxuICAgICAqIEBjb25zdGFudFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJwZXJpb2RcIlxuICAgICAqL1xuICAgIGljYWx0eXBlOiBcInBlcmlvZFwiLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBkdXJhdGlvbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlBlcmlvZH0gICAgICBUaGUgY2xvbmVkIG9iamVjdFxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJQ0FMLlBlcmlvZC5mcm9tRGF0YSh7XG4gICAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0ID8gdGhpcy5zdGFydC5jbG9uZSgpIDogbnVsbCxcbiAgICAgICAgZW5kOiB0aGlzLmVuZCA/IHRoaXMuZW5kLmNsb25lKCkgOiBudWxsLFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbiA/IHRoaXMuZHVyYXRpb24uY2xvbmUoKSA6IG51bGxcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBkdXJhdGlvbiBvZiB0aGUgcGVyaW9kLCBlaXRoZXIgZGlyZWN0bHkgb3IgYnkgc3VidHJhY3RpbmdcbiAgICAgKiBzdGFydCBmcm9tIGVuZCBkYXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7SUNBTC5EdXJhdGlvbn0gICAgICBUaGUgY2FsY3VsYXRlZCBkdXJhdGlvblxuICAgICAqL1xuICAgIGdldER1cmF0aW9uOiBmdW5jdGlvbiBkdXJhdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmR1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmR1cmF0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kLnN1YnRyYWN0RGF0ZSh0aGlzLnN0YXJ0KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgZW5kIGRhdGUgb2YgdGhlIHBlcmlvZCwgZWl0aGVyIGRpcmVjdGx5IG9yIGJ5IGFkZGluZ1xuICAgICAqIGR1cmF0aW9uIHRvIHN0YXJ0IGRhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgIFRoZSBjYWxjdWxhdGVkIGVuZCBkYXRlXG4gICAgICovXG4gICAgZ2V0RW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmVuZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5zdGFydC5jbG9uZSgpO1xuICAgICAgICBlbmQuYWRkRHVyYXRpb24odGhpcy5kdXJhdGlvbik7XG4gICAgICAgIHJldHVybiBlbmQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBwZXJpb2QuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0ICsgXCIvXCIgKyAodGhpcy5lbmQgfHwgdGhpcy5kdXJhdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBqQ2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcGVyaW9kIHR5cGUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW3RoaXMuc3RhcnQudG9TdHJpbmcoKSwgKHRoaXMuZW5kIHx8IHRoaXMuZHVyYXRpb24pLnRvU3RyaW5nKCldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaUNhbGVuZGFyIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHBlcmlvZC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9JQ0FMU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0LnRvSUNBTFN0cmluZygpICsgXCIvXCIgK1xuICAgICAgICAgICAgICh0aGlzLmVuZCB8fCB0aGlzLmR1cmF0aW9uKS50b0lDQUxTdHJpbmcoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIElDQUwuUGVyaW9kfSBpbnN0YW5jZSBmcm9tIHRoZSBwYXNzZWQgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyICAgICAgICAgICAgVGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0lDQUwuUHJvcGVydHl9IHByb3AgICAgVGhlIHByb3BlcnR5IHRoaXMgcGVyaW9kIHdpbGwgYmUgb25cbiAgICogQHJldHVybiB7SUNBTC5QZXJpb2R9ICAgICAgICAgIFRoZSBjcmVhdGVkIHBlcmlvZCBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5QZXJpb2QuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyLCBwcm9wKSB7XG4gICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCcvJyk7XG5cbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIHN0cmluZyB2YWx1ZTogXCInICsgc3RyICsgJ1wiIG11c3QgY29udGFpbiBhIFwiL1wiIGNoYXIuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHN0YXJ0OiBJQ0FMLlRpbWUuZnJvbURhdGVUaW1lU3RyaW5nKHBhcnRzWzBdLCBwcm9wKVxuICAgIH07XG5cbiAgICB2YXIgZW5kID0gcGFydHNbMV07XG5cbiAgICBpZiAoSUNBTC5EdXJhdGlvbi5pc1ZhbHVlU3RyaW5nKGVuZCkpIHtcbiAgICAgIG9wdGlvbnMuZHVyYXRpb24gPSBJQ0FMLkR1cmF0aW9uLmZyb21TdHJpbmcoZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5lbmQgPSBJQ0FMLlRpbWUuZnJvbURhdGVUaW1lU3RyaW5nKGVuZCwgcHJvcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBJQ0FMLlBlcmlvZChvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5QZXJpb2R9IGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIGRhdGEgb2JqZWN0LlxuICAgKiBUaGUgcGFzc2VkIGRhdGEgb2JqZWN0IGNhbm5vdCBjb250YWluIGJvdGggYW5kIGVuZCBkYXRlIGFuZCBhIGR1cmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYURhdGEgICAgICAgICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBtZW1iZXJzIG9mIHRoZSBwZXJpb2RcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWU9fSBhRGF0YS5zdGFydCAgICAgICAgVGhlIHN0YXJ0IG9mIHRoZSBwZXJpb2RcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWU9fSBhRGF0YS5lbmQgICAgICAgICAgVGhlIGVuZCBvZiB0aGUgcGVyaW9kXG4gICAqIEBwYXJhbSB7SUNBTC5EdXJhdGlvbj19IGFEYXRhLmR1cmF0aW9uIFRoZSBkdXJhdGlvbiBvZiB0aGUgcGVyaW9kXG4gICAqIEByZXR1cm4ge0lDQUwuUGVyaW9kfSAgICAgICAgICAgICAgICAgIFRoZSBwZXJpb2QgaW5zdGFuY2VcbiAgICovXG4gIElDQUwuUGVyaW9kLmZyb21EYXRhID0gZnVuY3Rpb24gZnJvbURhdGEoYURhdGEpIHtcbiAgICByZXR1cm4gbmV3IElDQUwuUGVyaW9kKGFEYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBwZXJpb2QgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gakNhbCBkYXRhIGFycmF5LiBUaGUgZmlyc3RcbiAgICogbWVtYmVyIGlzIGFsd2F5cyB0aGUgc3RhcnQgZGF0ZSBzdHJpbmcsIHRoZSBzZWNvbmQgbWVtYmVyIGlzIGVpdGhlciBhXG4gICAqIGR1cmF0aW9uIG9yIGVuZCBkYXRlIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxTdHJpbmcsU3RyaW5nPn0gYURhdGEgICAgVGhlIGpDYWwgZGF0YSBhcnJheVxuICAgKiBAcGFyYW0ge0lDQUwuUHJvcGVydHl9IGFQcm9wICAgICAgICAgICBUaGUgcHJvcGVydHkgdGhpcyBqQ2FsIGRhdGEgaXMgb25cbiAgICogQHBhcmFtIHtCb29sZWFufSBhTGVuaWVudCAgICAgICAgICAgICAgSWYgdHJ1ZSwgZGF0YSB2YWx1ZSBjYW4gYmUgYm90aCBkYXRlIGFuZCBkYXRlLXRpbWVcbiAgICogQHJldHVybiB7SUNBTC5QZXJpb2R9ICAgICAgICAgICAgICAgICAgVGhlIHBlcmlvZCBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5QZXJpb2QuZnJvbUpTT04gPSBmdW5jdGlvbihhRGF0YSwgYVByb3AsIGFMZW5pZW50KSB7XG4gICAgZnVuY3Rpb24gZnJvbURhdGVPckRhdGVUaW1lU3RyaW5nKGFWYWx1ZSwgYVByb3ApIHtcbiAgICAgIGlmIChhTGVuaWVudCkge1xuICAgICAgICByZXR1cm4gSUNBTC5UaW1lLmZyb21TdHJpbmcoYVZhbHVlLCBhUHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gSUNBTC5UaW1lLmZyb21EYXRlVGltZVN0cmluZyhhVmFsdWUsIGFQcm9wKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoSUNBTC5EdXJhdGlvbi5pc1ZhbHVlU3RyaW5nKGFEYXRhWzFdKSkge1xuICAgICAgcmV0dXJuIElDQUwuUGVyaW9kLmZyb21EYXRhKHtcbiAgICAgICAgc3RhcnQ6IGZyb21EYXRlT3JEYXRlVGltZVN0cmluZyhhRGF0YVswXSwgYVByb3ApLFxuICAgICAgICBkdXJhdGlvbjogSUNBTC5EdXJhdGlvbi5mcm9tU3RyaW5nKGFEYXRhWzFdKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBJQ0FMLlBlcmlvZC5mcm9tRGF0YSh7XG4gICAgICAgIHN0YXJ0OiBmcm9tRGF0ZU9yRGF0ZVRpbWVTdHJpbmcoYURhdGFbMF0sIGFQcm9wKSxcbiAgICAgICAgZW5kOiBmcm9tRGF0ZU9yRGF0ZVRpbWVTdHJpbmcoYURhdGFbMV0sIGFQcm9wKVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufSkoKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBEVVJBVElPTl9MRVRURVJTID0gLyhbUERXSE1UU117MSwxfSkvO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgXCJkdXJhdGlvblwiIHZhbHVlIHR5cGUsIHdpdGggdmFyaW91cyBjYWxjdWxhdGlvblxuICAgKiBhbmQgbWFuaXB1bGF0aW9uIG1ldGhvZHMuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAYWxpYXMgSUNBTC5EdXJhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIGR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLndlZWtzICAgICAgICAgRHVyYXRpb24gaW4gd2Vla3NcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuZGF5cyAgICAgICAgICBEdXJhdGlvbiBpbiBkYXlzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLmhvdXJzICAgICAgICAgRHVyYXRpb24gaW4gaG91cnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEubWludXRlcyAgICAgICBEdXJhdGlvbiBpbiBtaW51dGVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnNlY29uZHMgICAgICAgRHVyYXRpb24gaW4gc2Vjb25kc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRhdGEuaXNOZWdhdGl2ZSAgIElmIHRydWUsIHRoZSBkdXJhdGlvbiBpcyBuZWdhdGl2ZVxuICAgKi9cbiAgSUNBTC5EdXJhdGlvbiA9IGZ1bmN0aW9uIGljYWxkdXJhdGlvbihkYXRhKSB7XG4gICAgdGhpcy53cmFwcGVkSlNPYmplY3QgPSB0aGlzO1xuICAgIHRoaXMuZnJvbURhdGEoZGF0YSk7XG4gIH07XG5cbiAgSUNBTC5EdXJhdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIHdlZWtzIGluIHRoaXMgZHVyYXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB3ZWVrczogMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkYXlzIGluIHRoaXMgZHVyYXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBkYXlzOiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRheXMgaW4gdGhpcyBkdXJhdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIGhvdXJzOiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG1pbnV0ZXMgaW4gdGhpcyBkdXJhdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIG1pbnV0ZXM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2Vjb25kcyBpbiB0aGlzIGR1cmF0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgc2Vjb25kczogMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWNvbmRzIGluIHRoaXMgZHVyYXRpb25cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGlzTmVnYXRpdmU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNsYXNzIGlkZW50aWZpZXIuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcImljYWxkdXJhdGlvblwiXG4gICAgICovXG4gICAgaWNhbGNsYXNzOiBcImljYWxkdXJhdGlvblwiLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgbmFtZSwgdG8gYmUgdXNlZCBpbiB0aGUgakNhbCBvYmplY3QuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcImR1cmF0aW9uXCJcbiAgICAgKi9cbiAgICBpY2FsdHlwZTogXCJkdXJhdGlvblwiLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBkdXJhdGlvbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgICAgIFRoZSBjbG9uZWQgb2JqZWN0XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIElDQUwuRHVyYXRpb24uZnJvbURhdGEodGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkdXJhdGlvbiB2YWx1ZSBleHByZXNzZWQgYXMgYSBudW1iZXIgb2Ygc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgVGhlIGR1cmF0aW9uIHZhbHVlIGluIHNlY29uZHNcbiAgICAgKi9cbiAgICB0b1NlY29uZHM6IGZ1bmN0aW9uIHRvU2Vjb25kcygpIHtcbiAgICAgIHZhciBzZWNvbmRzID0gdGhpcy5zZWNvbmRzICsgNjAgKiB0aGlzLm1pbnV0ZXMgKyAzNjAwICogdGhpcy5ob3VycyArXG4gICAgICAgICAgICAgICAgICAgIDg2NDAwICogdGhpcy5kYXlzICsgNyAqIDg2NDAwICogdGhpcy53ZWVrcztcbiAgICAgIHJldHVybiAodGhpcy5pc05lZ2F0aXZlID8gLXNlY29uZHMgOiBzZWNvbmRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIHBhc3NlZCBzZWNvbmRzIHZhbHVlIGludG8gdGhpcyBkdXJhdGlvbiBvYmplY3QuIEFmdGVyd2FyZHMsXG4gICAgICogbWVtYmVycyBsaWtlIHtAbGluayBJQ0FMLkR1cmF0aW9uI2RheXMgZGF5c30gYW5kIHtAbGluayBJQ0FMLkR1cmF0aW9uI3dlZWtzIHdlZWtzfSB3aWxsIGJlIHNldCB1cFxuICAgICAqIGFjY29yZGluZ2x5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFTZWNvbmRzICAgICBUaGUgZHVyYXRpb24gdmFsdWUgaW4gc2Vjb25kc1xuICAgICAqIEByZXR1cm4ge0lDQUwuRHVyYXRpb259ICAgICAgUmV0dXJucyB0aGlzIGluc3RhbmNlXG4gICAgICovXG4gICAgZnJvbVNlY29uZHM6IGZ1bmN0aW9uIGZyb21TZWNvbmRzKGFTZWNvbmRzKSB7XG4gICAgICB2YXIgc2VjcyA9IE1hdGguYWJzKGFTZWNvbmRzKTtcblxuICAgICAgdGhpcy5pc05lZ2F0aXZlID0gKGFTZWNvbmRzIDwgMCk7XG4gICAgICB0aGlzLmRheXMgPSBJQ0FMLmhlbHBlcnMudHJ1bmMoc2VjcyAvIDg2NDAwKTtcblxuICAgICAgLy8gSWYgd2UgaGF2ZSBhIGZsYXQgbnVtYmVyIG9mIHdlZWtzLCB1c2UgdGhlbS5cbiAgICAgIGlmICh0aGlzLmRheXMgJSA3ID09IDApIHtcbiAgICAgICAgdGhpcy53ZWVrcyA9IHRoaXMuZGF5cyAvIDc7XG4gICAgICAgIHRoaXMuZGF5cyA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndlZWtzID0gMDtcbiAgICAgIH1cblxuICAgICAgc2VjcyAtPSAodGhpcy5kYXlzICsgNyAqIHRoaXMud2Vla3MpICogODY0MDA7XG5cbiAgICAgIHRoaXMuaG91cnMgPSBJQ0FMLmhlbHBlcnMudHJ1bmMoc2VjcyAvIDM2MDApO1xuICAgICAgc2VjcyAtPSB0aGlzLmhvdXJzICogMzYwMDtcblxuICAgICAgdGhpcy5taW51dGVzID0gSUNBTC5oZWxwZXJzLnRydW5jKHNlY3MgLyA2MCk7XG4gICAgICBzZWNzIC09IHRoaXMubWludXRlcyAqIDYwO1xuXG4gICAgICB0aGlzLnNlY29uZHMgPSBzZWNzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIGN1cnJlbnQgaW5zdGFuY2UgdXNpbmcgbWVtYmVycyBmcm9tIHRoZSBwYXNzZWQgZGF0YSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYURhdGEgICAgICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBtZW1iZXJzIG9mIHRoZSBkdXJhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS53ZWVrcyAgICAgICAgIER1cmF0aW9uIGluIHdlZWtzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmRheXMgICAgICAgICAgRHVyYXRpb24gaW4gZGF5c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5ob3VycyAgICAgICAgIER1cmF0aW9uIGluIGhvdXJzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLm1pbnV0ZXMgICAgICAgRHVyYXRpb24gaW4gbWludXRlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5zZWNvbmRzICAgICAgIER1cmF0aW9uIGluIHNlY29uZHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFEYXRhLmlzTmVnYXRpdmUgICBJZiB0cnVlLCB0aGUgZHVyYXRpb24gaXMgbmVnYXRpdmVcbiAgICAgKi9cbiAgICBmcm9tRGF0YTogZnVuY3Rpb24gZnJvbURhdGEoYURhdGEpIHtcbiAgICAgIHZhciBwcm9wc1RvQ29weSA9IFtcIndlZWtzXCIsIFwiZGF5c1wiLCBcImhvdXJzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiLCBcImlzTmVnYXRpdmVcIl07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHNUb0NvcHkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghcHJvcHNUb0NvcHkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNUb0NvcHlba2V5XTtcbiAgICAgICAgaWYgKGFEYXRhICYmIHByb3AgaW4gYURhdGEpIHtcbiAgICAgICAgICB0aGlzW3Byb3BdID0gYURhdGFbcHJvcF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpc1twcm9wXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBkdXJhdGlvbiBpbnN0YW5jZSB0byB0aGUgZGVmYXVsdCB2YWx1ZXMsIGkuZS4gUFQwU1xuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuaXNOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy53ZWVrcyA9IDA7XG4gICAgICB0aGlzLmRheXMgPSAwO1xuICAgICAgdGhpcy5ob3VycyA9IDA7XG4gICAgICB0aGlzLm1pbnV0ZXMgPSAwO1xuICAgICAgdGhpcy5zZWNvbmRzID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdGhlIGR1cmF0aW9uIGluc3RhbmNlIHdpdGggYW5vdGhlciBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuRHVyYXRpb259IGFPdGhlciAgICAgICAgVGhlIGluc3RhbmNlIHRvIGNvbXBhcmUgd2l0aFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAtMSwgMCBvciAxIGZvciBsZXNzL2VxdWFsL2dyZWF0ZXJcbiAgICAgKi9cbiAgICBjb21wYXJlOiBmdW5jdGlvbiBjb21wYXJlKGFPdGhlcikge1xuICAgICAgdmFyIHRoaXNTZWNvbmRzID0gdGhpcy50b1NlY29uZHMoKTtcbiAgICAgIHZhciBvdGhlclNlY29uZHMgPSBhT3RoZXIudG9TZWNvbmRzKCk7XG4gICAgICByZXR1cm4gKHRoaXNTZWNvbmRzID4gb3RoZXJTZWNvbmRzKSAtICh0aGlzU2Vjb25kcyA8IG90aGVyU2Vjb25kcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgdGhlIGR1cmF0aW9uIGluc3RhbmNlLiBGb3IgZXhhbXBsZSwgYSBkdXJhdGlvbiB3aXRoIGEgdmFsdWVcbiAgICAgKiBvZiA2MSBzZWNvbmRzIHdpbGwgYmUgbm9ybWFsaXplZCB0byAxIG1pbnV0ZSBhbmQgMSBzZWNvbmQuXG4gICAgICovXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbiBub3JtYWxpemUoKSB7XG4gICAgICB0aGlzLmZyb21TZWNvbmRzKHRoaXMudG9TZWNvbmRzKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZHVyYXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIGlmICh0aGlzLnRvU2Vjb25kcygpID09IDApIHtcbiAgICAgICAgcmV0dXJuIFwiUFQwU1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUpIHN0ciArPSBcIi1cIjtcbiAgICAgICAgc3RyICs9IFwiUFwiO1xuICAgICAgICBpZiAodGhpcy53ZWVrcykgc3RyICs9IHRoaXMud2Vla3MgKyBcIldcIjtcbiAgICAgICAgaWYgKHRoaXMuZGF5cykgc3RyICs9IHRoaXMuZGF5cyArIFwiRFwiO1xuXG4gICAgICAgIGlmICh0aGlzLmhvdXJzIHx8IHRoaXMubWludXRlcyB8fCB0aGlzLnNlY29uZHMpIHtcbiAgICAgICAgICBzdHIgKz0gXCJUXCI7XG4gICAgICAgICAgaWYgKHRoaXMuaG91cnMpIHN0ciArPSB0aGlzLmhvdXJzICsgXCJIXCI7XG4gICAgICAgICAgaWYgKHRoaXMubWludXRlcykgc3RyICs9IHRoaXMubWludXRlcyArIFwiTVwiO1xuICAgICAgICAgIGlmICh0aGlzLnNlY29uZHMpIHN0ciArPSB0aGlzLnNlY29uZHMgKyBcIlNcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaUNhbGVuZGFyIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGR1cmF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b0lDQUxTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5EdXJhdGlvbiBpbnN0YW5jZSBmcm9tIHRoZSBwYXNzZWQgc2Vjb25kcyB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFTZWNvbmRzICAgICAgIFRoZSBzZWNvbmRzIHRvIGNyZWF0ZSB0aGUgaW5zdGFuY2UgZnJvbVxuICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgICAgICAgVGhlIG5ld2x5IGNyZWF0ZWQgZHVyYXRpb24gaW5zdGFuY2VcbiAgICovXG4gIElDQUwuRHVyYXRpb24uZnJvbVNlY29uZHMgPSBmdW5jdGlvbiBpY2FsZHVyYXRpb25fZnJvbV9zZWNvbmRzKGFTZWNvbmRzKSB7XG4gICAgcmV0dXJuIChuZXcgSUNBTC5EdXJhdGlvbigpKS5mcm9tU2Vjb25kcyhhU2Vjb25kcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiB0byBoYW5kbGUgYSBjaHVuayBvZiBhIGR1cmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGV0dGVyIHR5cGUgb2YgZHVyYXRpb24gY2h1bmtcbiAgICogQHBhcmFtIHtTdHJpbmd9IG51bWJlciBudW1lcmljIHZhbHVlIG9yIC0vK1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGljdCB0YXJnZXQgdG8gYXNzaWduIHZhbHVlcyB0b1xuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VEdXJhdGlvbkNodW5rKGxldHRlciwgbnVtYmVyLCBvYmplY3QpIHtcbiAgICB2YXIgdHlwZTtcbiAgICBzd2l0Y2ggKGxldHRlcikge1xuICAgICAgY2FzZSAnUCc6XG4gICAgICAgIGlmIChudW1iZXIgJiYgbnVtYmVyID09PSAnLScpIHtcbiAgICAgICAgICBvYmplY3QuaXNOZWdhdGl2ZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqZWN0LmlzTmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwZXJpb2RcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdEJzpcbiAgICAgICAgdHlwZSA9ICdkYXlzJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdXJzpcbiAgICAgICAgdHlwZSA9ICd3ZWVrcyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnSCc6XG4gICAgICAgIHR5cGUgPSAnaG91cnMnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ00nOlxuICAgICAgICB0eXBlID0gJ21pbnV0ZXMnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1MnOlxuICAgICAgICB0eXBlID0gJ3NlY29uZHMnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIE5vdCBhIHZhbGlkIGNodW5rXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmICh0eXBlKSB7XG4gICAgICBpZiAoIW51bWJlciAmJiBudW1iZXIgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdpbnZhbGlkIGR1cmF0aW9uIHZhbHVlOiBNaXNzaW5nIG51bWJlciBiZWZvcmUgXCInICsgbGV0dGVyICsgJ1wiJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdmFyIG51bSA9IHBhcnNlSW50KG51bWJlciwgMTApO1xuICAgICAgaWYgKElDQUwuaGVscGVycy5pc1N0cmljdGx5TmFOKG51bSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdpbnZhbGlkIGR1cmF0aW9uIHZhbHVlOiBJbnZhbGlkIG51bWJlciBcIicgKyBudW1iZXIgKyAnXCIgYmVmb3JlIFwiJyArIGxldHRlciArICdcIidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG9iamVjdFt0eXBlXSA9IG51bTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBhbiBpQ2FsZW5kYXIgZHVyYXRpb24gdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAgICAgIFRoZSByYXcgaWNhbCB2YWx1ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICBUcnVlLCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gaWNhbCB0eXBlXG4gICAqL1xuICBJQ0FMLkR1cmF0aW9uLmlzVmFsdWVTdHJpbmcgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gKHN0cmluZ1swXSA9PT0gJ1AnIHx8IHN0cmluZ1sxXSA9PT0gJ1AnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5EdXJhdGlvbn0gaW5zdGFuY2UgZnJvbSB0aGUgcGFzc2VkIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFTdHIgICAgICAgVGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgICBUaGUgY3JlYXRlZCBkdXJhdGlvbiBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5EdXJhdGlvbi5mcm9tU3RyaW5nID0gZnVuY3Rpb24gaWNhbGR1cmF0aW9uX2Zyb21fc3RyaW5nKGFTdHIpIHtcbiAgICB2YXIgcG9zID0gMDtcbiAgICB2YXIgZGljdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGNodW5rcyA9IDA7XG5cbiAgICB3aGlsZSAoKHBvcyA9IGFTdHIuc2VhcmNoKERVUkFUSU9OX0xFVFRFUlMpKSAhPT0gLTEpIHtcbiAgICAgIHZhciB0eXBlID0gYVN0cltwb3NdO1xuICAgICAgdmFyIG51bWVyaWMgPSBhU3RyLnN1YnN0cigwLCBwb3MpO1xuICAgICAgYVN0ciA9IGFTdHIuc3Vic3RyKHBvcyArIDEpO1xuXG4gICAgICBjaHVua3MgKz0gcGFyc2VEdXJhdGlvbkNodW5rKHR5cGUsIG51bWVyaWMsIGRpY3QpO1xuICAgIH1cblxuICAgIGlmIChjaHVua3MgPCAyKSB7XG4gICAgICAvLyBUaGVyZSBtdXN0IGJlIGF0IGxlYXN0IGEgY2h1bmsgd2l0aCBcIlBcIiBhbmQgc29tZSB1bml0IGNodW5rXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdpbnZhbGlkIGR1cmF0aW9uIHZhbHVlOiBOb3QgZW5vdWdoIGR1cmF0aW9uIGNvbXBvbmVudHMgaW4gXCInICsgYVN0ciArICdcIidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBJQ0FMLkR1cmF0aW9uKGRpY3QpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElDQUwuRHVyYXRpb24gaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIGR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS53ZWVrcyAgICAgICAgIER1cmF0aW9uIGluIHdlZWtzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5kYXlzICAgICAgICAgIER1cmF0aW9uIGluIGRheXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmhvdXJzICAgICAgICAgRHVyYXRpb24gaW4gaG91cnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLm1pbnV0ZXMgICAgICAgRHVyYXRpb24gaW4gbWludXRlc1xuICAgKiBAcGFyYW0ge051bWJlcn0gYURhdGEuc2Vjb25kcyAgICAgICBEdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYURhdGEuaXNOZWdhdGl2ZSAgIElmIHRydWUsIHRoZSBkdXJhdGlvbiBpcyBuZWdhdGl2ZVxuICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgICAgICAgICAgICBUaGUgY3JlYXRlYWQgZHVyYXRpb24gaW5zdGFuY2VcbiAgICovXG4gIElDQUwuRHVyYXRpb24uZnJvbURhdGEgPSBmdW5jdGlvbiBpY2FsZHVyYXRpb25fZnJvbV9kYXRhKGFEYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBJQ0FMLkR1cmF0aW9uKGFEYXRhKTtcbiAgfTtcbn0pKCk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxMiAqL1xuXG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgT1BUSU9OUyA9IFtcInR6aWRcIiwgXCJsb2NhdGlvblwiLCBcInR6bmFtZXNcIixcbiAgICAgICAgICAgICAgICAgXCJsYXRpdHVkZVwiLCBcImxvbmdpdHVkZVwiXTtcblxuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBUaW1lem9uZSByZXByZXNlbnRhdGlvbiwgY3JlYXRlZCBieSBwYXNzaW5nIGluIGEgdHppZCBhbmQgY29tcG9uZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgdmNhbGVuZGFyO1xuICAgKiB2YXIgdGltZXpvbmVDb21wID0gdmNhbGVuZGFyLmdldEZpcnN0U3ViY29tcG9uZW50KCd2dGltZXpvbmUnKTtcbiAgICogdmFyIHR6aWQgPSB0aW1lem9uZUNvbXAuZ2V0Rmlyc3RQcm9wZXJ0eVZhbHVlKCd0emlkJyk7XG4gICAqXG4gICAqIHZhciB0aW1lem9uZSA9IG5ldyBJQ0FMLlRpbWV6b25lKHtcbiAgICogICBjb21wb25lbnQ6IHRpbWV6b25lQ29tcCxcbiAgICogICB0emlkXG4gICAqIH0pO1xuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudHxPYmplY3R9IGRhdGEgb3B0aW9ucyBmb3IgY2xhc3NcbiAgICogQHBhcmFtIHtTdHJpbmd8SUNBTC5Db21wb25lbnR9IGRhdGEuY29tcG9uZW50XG4gICAqICAgICAgICBJZiBkYXRhIGlzIGEgc2ltcGxlIG9iamVjdCwgdGhlbiB0aGlzIG1lbWJlciBjYW4gYmUgc2V0IHRvIGVpdGhlciBhXG4gICAqICAgICAgICBzdHJpbmcgY29udGFpbmluZyB0aGUgY29tcG9uZW50IGRhdGEsIG9yIGFuIGFscmVhZHkgcGFyc2VkXG4gICAqICAgICAgICBJQ0FMLkNvbXBvbmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS50emlkICAgICAgVGhlIHRpbWV6b25lIGlkZW50aWZpZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEubG9jYXRpb24gIFRoZSB0aW1lem9uZSBsb2NhdGlvbndcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEudHpuYW1lcyAgIEFuIGFsdGVybmF0aXZlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXpvbmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEubGF0aXR1ZGUgIFRoZSBsYXRpdHVkZSBvZiB0aGUgdGltZXpvbmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEubG9uZ2l0dWRlIFRoZSBsb25naXR1ZGUgb2YgdGhlIHRpbWV6b25lXG4gICAqL1xuICBJQ0FMLlRpbWV6b25lID0gZnVuY3Rpb24gaWNhbHRpbWV6b25lKGRhdGEpIHtcbiAgICB0aGlzLndyYXBwZWRKU09iamVjdCA9IHRoaXM7XG4gICAgdGhpcy5mcm9tRGF0YShkYXRhKTtcbiAgfTtcblxuICBJQ0FMLlRpbWV6b25lLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFRpbWV6b25lIGlkZW50aWZpZXJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHR6aWQ6IFwiXCIsXG5cbiAgICAvKipcbiAgICAgKiBUaW1lem9uZSBsb2NhdGlvblxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgbG9jYXRpb246IFwiXCIsXG5cbiAgICAvKipcbiAgICAgKiBBbHRlcm5hdGl2ZSB0aW1lem9uZSBuYW1lLCBmb3IgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdHpuYW1lczogXCJcIixcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmltYXJ5IGxhdGl0dWRlIGZvciB0aGUgdGltZXpvbmUuXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBsYXRpdHVkZTogMC4wLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHByaW1hcnkgbG9uZ2l0dWRlIGZvciB0aGUgdGltZXpvbmUuXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBsb25naXR1ZGU6IDAuMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSB2dGltZXpvbmUgY29tcG9uZW50IGZvciB0aGlzIHRpbWV6b25lLlxuICAgICAqIEB0eXBlIHtJQ0FMLkNvbXBvbmVudH1cbiAgICAgKi9cbiAgICBjb21wb25lbnQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgeWVhciB0aGlzIHRpbWV6b25lIGhhcyBiZWVuIGV4cGFuZGVkIHRvLiBBbGwgdGltZXpvbmUgdHJhbnNpdGlvblxuICAgICAqIGRhdGVzIHVudGlsIHRoaXMgeWVhciBhcmUga25vd24gYW5kIGNhbiBiZSB1c2VkIGZvciBjYWxjdWxhdGlvblxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGV4cGFuZGVkVW50aWxZZWFyOiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNsYXNzIGlkZW50aWZpZXIuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcImljYWx0aW1lem9uZVwiXG4gICAgICovXG4gICAgaWNhbGNsYXNzOiBcImljYWx0aW1lem9uZVwiLFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSB1c2luZyBtZW1iZXJzIGZyb20gdGhlIHBhc3NlZCBkYXRhIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnR8T2JqZWN0fSBhRGF0YSBvcHRpb25zIGZvciBjbGFzc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfElDQUwuQ29tcG9uZW50fSBhRGF0YS5jb21wb25lbnRcbiAgICAgKiAgICAgICAgSWYgYURhdGEgaXMgYSBzaW1wbGUgb2JqZWN0LCB0aGVuIHRoaXMgbWVtYmVyIGNhbiBiZSBzZXQgdG8gZWl0aGVyIGFcbiAgICAgKiAgICAgICAgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGNvbXBvbmVudCBkYXRhLCBvciBhbiBhbHJlYWR5IHBhcnNlZFxuICAgICAqICAgICAgICBJQ0FMLkNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS50emlkICAgICAgVGhlIHRpbWV6b25lIGlkZW50aWZpZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYURhdGEubG9jYXRpb24gIFRoZSB0aW1lem9uZSBsb2NhdGlvbndcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYURhdGEudHpuYW1lcyAgIEFuIGFsdGVybmF0aXZlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lem9uZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5sYXRpdHVkZSAgVGhlIGxhdGl0dWRlIG9mIHRoZSB0aW1lem9uZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5sb25naXR1ZGUgVGhlIGxvbmdpdHVkZSBvZiB0aGUgdGltZXpvbmVcbiAgICAgKi9cbiAgICBmcm9tRGF0YTogZnVuY3Rpb24gZnJvbURhdGEoYURhdGEpIHtcbiAgICAgIHRoaXMuZXhwYW5kZWRVbnRpbFllYXIgPSAwO1xuICAgICAgdGhpcy5jaGFuZ2VzID0gW107XG5cbiAgICAgIGlmIChhRGF0YSBpbnN0YW5jZW9mIElDQUwuQ29tcG9uZW50KSB7XG4gICAgICAgIC8vIEVpdGhlciBhIGNvbXBvbmVudCBpcyBwYXNzZWQgZGlyZWN0bHlcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBhRGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSB0aGUgY29tcG9uZW50IG1heSBiZSBpbiB0aGUgZGF0YSBvYmplY3RcbiAgICAgICAgaWYgKGFEYXRhICYmIFwiY29tcG9uZW50XCIgaW4gYURhdGEpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFEYXRhLmNvbXBvbmVudCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHN0cmluZyB3YXMgcGFzc2VkLCBwYXJzZSBpdCBhcyBhIGNvbXBvbmVudFxuICAgICAgICAgICAgdmFyIGpDYWwgPSBJQ0FMLnBhcnNlKGFEYXRhLmNvbXBvbmVudCk7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudCA9IG5ldyBJQ0FMLkNvbXBvbmVudChqQ2FsKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGFEYXRhLmNvbXBvbmVudCBpbnN0YW5jZW9mIElDQUwuQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBJZiBpdCB3YXMgYSBjb21wb25lbnQgYWxyZWFkeSwgdGhlbiBqdXN0IHNldCBpdFxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBhRGF0YS5jb21wb25lbnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IG51bGwgb3V0IHRoZSBjb21wb25lbnRcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb3B5IHJlbWFpbmluZyBwYXNzZWQgcHJvcGVydGllc1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gT1BUSU9OUykge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKE9QVElPTlMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgdmFyIHByb3AgPSBPUFRJT05TW2tleV07XG4gICAgICAgICAgICBpZiAoYURhdGEgJiYgcHJvcCBpbiBhRGF0YSkge1xuICAgICAgICAgICAgICB0aGlzW3Byb3BdID0gYURhdGFbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGhhdmUgYSBjb21wb25lbnQgYnV0IG5vIFRaSUQsIGF0dGVtcHQgdG8gZ2V0IGl0IGZyb20gdGhlXG4gICAgICAvLyBjb21wb25lbnQncyBwcm9wZXJ0aWVzLlxuICAgICAgaWYgKHRoaXMuY29tcG9uZW50IGluc3RhbmNlb2YgSUNBTC5Db21wb25lbnQgJiYgIXRoaXMudHppZCkge1xuICAgICAgICB0aGlzLnR6aWQgPSB0aGlzLmNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5VmFsdWUoJ3R6aWQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSB1dGNPZmZzZXQgdGhlIGdpdmVuIHRpbWUgd291bGQgb2NjdXIgaW4gdGhpcyB0aW1lem9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lfSB0dCAgICAgICAgVGhlIHRpbWUgdG8gY2hlY2sgZm9yXG4gICAgICogQHJldHVybiB7TnVtYmVyfSB1dGMgb2Zmc2V0IGluIHNlY29uZHNcbiAgICAgKi9cbiAgICB1dGNPZmZzZXQ6IGZ1bmN0aW9uIHV0Y09mZnNldCh0dCkge1xuICAgICAgaWYgKHRoaXMgPT0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZSB8fCB0aGlzID09IElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZW5zdXJlQ292ZXJhZ2UodHQueWVhcik7XG5cbiAgICAgIGlmICghdGhpcy5jaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHR0X2NoYW5nZSA9IHtcbiAgICAgICAgeWVhcjogdHQueWVhcixcbiAgICAgICAgbW9udGg6IHR0Lm1vbnRoLFxuICAgICAgICBkYXk6IHR0LmRheSxcbiAgICAgICAgaG91cjogdHQuaG91cixcbiAgICAgICAgbWludXRlOiB0dC5taW51dGUsXG4gICAgICAgIHNlY29uZDogdHQuc2Vjb25kXG4gICAgICB9O1xuXG4gICAgICB2YXIgY2hhbmdlX251bSA9IHRoaXMuX2ZpbmROZWFyYnlDaGFuZ2UodHRfY2hhbmdlKTtcbiAgICAgIHZhciBjaGFuZ2VfbnVtX3RvX3VzZSA9IC0xO1xuICAgICAgdmFyIHN0ZXAgPSAxO1xuXG4gICAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggYmluIHNlYXJjaD9cbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgdmFyIGNoYW5nZSA9IElDQUwuaGVscGVycy5jbG9uZSh0aGlzLmNoYW5nZXNbY2hhbmdlX251bV0sIHRydWUpO1xuICAgICAgICBpZiAoY2hhbmdlLnV0Y09mZnNldCA8IGNoYW5nZS5wcmV2VXRjT2Zmc2V0KSB7XG4gICAgICAgICAgSUNBTC5UaW1lem9uZS5hZGp1c3RfY2hhbmdlKGNoYW5nZSwgMCwgMCwgMCwgY2hhbmdlLnV0Y09mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgSUNBTC5UaW1lem9uZS5hZGp1c3RfY2hhbmdlKGNoYW5nZSwgMCwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5wcmV2VXRjT2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjbXAgPSBJQ0FMLlRpbWV6b25lLl9jb21wYXJlX2NoYW5nZV9mbih0dF9jaGFuZ2UsIGNoYW5nZSk7XG5cbiAgICAgICAgaWYgKGNtcCA+PSAwKSB7XG4gICAgICAgICAgY2hhbmdlX251bV90b191c2UgPSBjaGFuZ2VfbnVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ZXAgPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGVwID09IC0xICYmIGNoYW5nZV9udW1fdG9fdXNlICE9IC0xKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjaGFuZ2VfbnVtICs9IHN0ZXA7XG5cbiAgICAgICAgaWYgKGNoYW5nZV9udW0gPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlX251bSA+PSB0aGlzLmNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHpvbmVfY2hhbmdlID0gdGhpcy5jaGFuZ2VzW2NoYW5nZV9udW1fdG9fdXNlXTtcbiAgICAgIHZhciB1dGNPZmZzZXRfY2hhbmdlID0gem9uZV9jaGFuZ2UudXRjT2Zmc2V0IC0gem9uZV9jaGFuZ2UucHJldlV0Y09mZnNldDtcblxuICAgICAgaWYgKHV0Y09mZnNldF9jaGFuZ2UgPCAwICYmIGNoYW5nZV9udW1fdG9fdXNlID4gMCkge1xuICAgICAgICB2YXIgdG1wX2NoYW5nZSA9IElDQUwuaGVscGVycy5jbG9uZSh6b25lX2NoYW5nZSwgdHJ1ZSk7XG4gICAgICAgIElDQUwuVGltZXpvbmUuYWRqdXN0X2NoYW5nZSh0bXBfY2hhbmdlLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcF9jaGFuZ2UucHJldlV0Y09mZnNldCk7XG5cbiAgICAgICAgaWYgKElDQUwuVGltZXpvbmUuX2NvbXBhcmVfY2hhbmdlX2ZuKHR0X2NoYW5nZSwgdG1wX2NoYW5nZSkgPCAwKSB7XG4gICAgICAgICAgdmFyIHByZXZfem9uZV9jaGFuZ2UgPSB0aGlzLmNoYW5nZXNbY2hhbmdlX251bV90b191c2UgLSAxXTtcblxuICAgICAgICAgIHZhciB3YW50X2RheWxpZ2h0ID0gZmFsc2U7IC8vIFRPRE9cblxuICAgICAgICAgIGlmICh6b25lX2NoYW5nZS5pc19kYXlsaWdodCAhPSB3YW50X2RheWxpZ2h0ICYmXG4gICAgICAgICAgICAgIHByZXZfem9uZV9jaGFuZ2UuaXNfZGF5bGlnaHQgPT0gd2FudF9kYXlsaWdodCkge1xuICAgICAgICAgICAgem9uZV9jaGFuZ2UgPSBwcmV2X3pvbmVfY2hhbmdlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUT0RPIHJldHVybiBpc19kYXlsaWdodD9cbiAgICAgIHJldHVybiB6b25lX2NoYW5nZS51dGNPZmZzZXQ7XG4gICAgfSxcblxuICAgIF9maW5kTmVhcmJ5Q2hhbmdlOiBmdW5jdGlvbiBpY2FsdGltZXpvbmVfZmluZF9uZWFyYnlfY2hhbmdlKGNoYW5nZSkge1xuICAgICAgLy8gZmluZCB0aGUgY2xvc2VzdCBtYXRjaFxuICAgICAgdmFyIGlkeCA9IElDQUwuaGVscGVycy5iaW5zZWFyY2hJbnNlcnQoXG4gICAgICAgIHRoaXMuY2hhbmdlcyxcbiAgICAgICAgY2hhbmdlLFxuICAgICAgICBJQ0FMLlRpbWV6b25lLl9jb21wYXJlX2NoYW5nZV9mblxuICAgICAgKTtcblxuICAgICAgaWYgKGlkeCA+PSB0aGlzLmNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZXMubGVuZ3RoIC0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlkeDtcbiAgICB9LFxuXG4gICAgX2Vuc3VyZUNvdmVyYWdlOiBmdW5jdGlvbihhWWVhcikge1xuICAgICAgaWYgKElDQUwuVGltZXpvbmUuX21pbmltdW1FeHBhbnNpb25ZZWFyID09IC0xKSB7XG4gICAgICAgIHZhciB0b2RheSA9IElDQUwuVGltZS5ub3coKTtcbiAgICAgICAgSUNBTC5UaW1lem9uZS5fbWluaW11bUV4cGFuc2lvblllYXIgPSB0b2RheS55ZWFyO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hhbmdlc0VuZFllYXIgPSBhWWVhcjtcbiAgICAgIGlmIChjaGFuZ2VzRW5kWWVhciA8IElDQUwuVGltZXpvbmUuX21pbmltdW1FeHBhbnNpb25ZZWFyKSB7XG4gICAgICAgIGNoYW5nZXNFbmRZZWFyID0gSUNBTC5UaW1lem9uZS5fbWluaW11bUV4cGFuc2lvblllYXI7XG4gICAgICB9XG5cbiAgICAgIGNoYW5nZXNFbmRZZWFyICs9IElDQUwuVGltZXpvbmUuRVhUUkFfQ09WRVJBR0U7XG5cbiAgICAgIGlmIChjaGFuZ2VzRW5kWWVhciA+IElDQUwuVGltZXpvbmUuTUFYX1lFQVIpIHtcbiAgICAgICAgY2hhbmdlc0VuZFllYXIgPSBJQ0FMLlRpbWV6b25lLk1BWF9ZRUFSO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuY2hhbmdlcy5sZW5ndGggfHwgdGhpcy5leHBhbmRlZFVudGlsWWVhciA8IGFZZWFyKSB7XG4gICAgICAgIHZhciBzdWJjb21wcyA9IHRoaXMuY29tcG9uZW50LmdldEFsbFN1YmNvbXBvbmVudHMoKTtcbiAgICAgICAgdmFyIGNvbXBMZW4gPSBzdWJjb21wcy5sZW5ndGg7XG4gICAgICAgIHZhciBjb21wSWR4ID0gMDtcblxuICAgICAgICBmb3IgKDsgY29tcElkeCA8IGNvbXBMZW47IGNvbXBJZHgrKykge1xuICAgICAgICAgIHRoaXMuX2V4cGFuZENvbXBvbmVudChcbiAgICAgICAgICAgIHN1YmNvbXBzW2NvbXBJZHhdLCBjaGFuZ2VzRW5kWWVhciwgdGhpcy5jaGFuZ2VzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2hhbmdlcy5zb3J0KElDQUwuVGltZXpvbmUuX2NvbXBhcmVfY2hhbmdlX2ZuKTtcbiAgICAgICAgdGhpcy5leHBhbmRlZFVudGlsWWVhciA9IGNoYW5nZXNFbmRZZWFyO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZXhwYW5kQ29tcG9uZW50OiBmdW5jdGlvbihhQ29tcG9uZW50LCBhWWVhciwgY2hhbmdlcykge1xuICAgICAgaWYgKCFhQ29tcG9uZW50Lmhhc1Byb3BlcnR5KFwiZHRzdGFydFwiKSB8fFxuICAgICAgICAgICFhQ29tcG9uZW50Lmhhc1Byb3BlcnR5KFwidHpvZmZzZXR0b1wiKSB8fFxuICAgICAgICAgICFhQ29tcG9uZW50Lmhhc1Byb3BlcnR5KFwidHpvZmZzZXRmcm9tXCIpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHRzdGFydCA9IGFDb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eShcImR0c3RhcnRcIikuZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgdmFyIGNoYW5nZTtcblxuICAgICAgZnVuY3Rpb24gY29udmVydF90em9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldC5mYWN0b3IgKiAob2Zmc2V0LmhvdXJzICogMzYwMCArIG9mZnNldC5taW51dGVzICogNjApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbml0X2NoYW5nZXMoKSB7XG4gICAgICAgIHZhciBjaGFuZ2ViYXNlID0ge307XG4gICAgICAgIGNoYW5nZWJhc2UuaXNfZGF5bGlnaHQgPSAoYUNvbXBvbmVudC5uYW1lID09IFwiZGF5bGlnaHRcIik7XG4gICAgICAgIGNoYW5nZWJhc2UudXRjT2Zmc2V0ID0gY29udmVydF90em9mZnNldChcbiAgICAgICAgICBhQ29tcG9uZW50LmdldEZpcnN0UHJvcGVydHkoXCJ0em9mZnNldHRvXCIpLmdldEZpcnN0VmFsdWUoKVxuICAgICAgICApO1xuXG4gICAgICAgIGNoYW5nZWJhc2UucHJldlV0Y09mZnNldCA9IGNvbnZlcnRfdHpvZmZzZXQoXG4gICAgICAgICAgYUNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5KFwidHpvZmZzZXRmcm9tXCIpLmdldEZpcnN0VmFsdWUoKVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBjaGFuZ2ViYXNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFDb21wb25lbnQuaGFzUHJvcGVydHkoXCJycnVsZVwiKSAmJiAhYUNvbXBvbmVudC5oYXNQcm9wZXJ0eShcInJkYXRlXCIpKSB7XG4gICAgICAgIGNoYW5nZSA9IGluaXRfY2hhbmdlcygpO1xuICAgICAgICBjaGFuZ2UueWVhciA9IGR0c3RhcnQueWVhcjtcbiAgICAgICAgY2hhbmdlLm1vbnRoID0gZHRzdGFydC5tb250aDtcbiAgICAgICAgY2hhbmdlLmRheSA9IGR0c3RhcnQuZGF5O1xuICAgICAgICBjaGFuZ2UuaG91ciA9IGR0c3RhcnQuaG91cjtcbiAgICAgICAgY2hhbmdlLm1pbnV0ZSA9IGR0c3RhcnQubWludXRlO1xuICAgICAgICBjaGFuZ2Uuc2Vjb25kID0gZHRzdGFydC5zZWNvbmQ7XG5cbiAgICAgICAgSUNBTC5UaW1lem9uZS5hZGp1c3RfY2hhbmdlKGNoYW5nZSwgMCwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtY2hhbmdlLnByZXZVdGNPZmZzZXQpO1xuICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGFDb21wb25lbnQuZ2V0QWxsUHJvcGVydGllcyhcInJkYXRlXCIpO1xuICAgICAgICBmb3IgKHZhciByZGF0ZWtleSBpbiBwcm9wcykge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocmRhdGVrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJkYXRlID0gcHJvcHNbcmRhdGVrZXldO1xuICAgICAgICAgIHZhciB0aW1lID0gcmRhdGUuZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgICAgIGNoYW5nZSA9IGluaXRfY2hhbmdlcygpO1xuXG4gICAgICAgICAgY2hhbmdlLnllYXIgPSB0aW1lLnllYXI7XG4gICAgICAgICAgY2hhbmdlLm1vbnRoID0gdGltZS5tb250aDtcbiAgICAgICAgICBjaGFuZ2UuZGF5ID0gdGltZS5kYXk7XG5cbiAgICAgICAgICBpZiAodGltZS5pc0RhdGUpIHtcbiAgICAgICAgICAgIGNoYW5nZS5ob3VyID0gZHRzdGFydC5ob3VyO1xuICAgICAgICAgICAgY2hhbmdlLm1pbnV0ZSA9IGR0c3RhcnQubWludXRlO1xuICAgICAgICAgICAgY2hhbmdlLnNlY29uZCA9IGR0c3RhcnQuc2Vjb25kO1xuXG4gICAgICAgICAgICBpZiAoZHRzdGFydC56b25lICE9IElDQUwuVGltZXpvbmUudXRjVGltZXpvbmUpIHtcbiAgICAgICAgICAgICAgSUNBTC5UaW1lem9uZS5hZGp1c3RfY2hhbmdlKGNoYW5nZSwgMCwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtY2hhbmdlLnByZXZVdGNPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2UuaG91ciA9IHRpbWUuaG91cjtcbiAgICAgICAgICAgIGNoYW5nZS5taW51dGUgPSB0aW1lLm1pbnV0ZTtcbiAgICAgICAgICAgIGNoYW5nZS5zZWNvbmQgPSB0aW1lLnNlY29uZDtcblxuICAgICAgICAgICAgaWYgKHRpbWUuem9uZSAhPSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lKSB7XG4gICAgICAgICAgICAgIElDQUwuVGltZXpvbmUuYWRqdXN0X2NoYW5nZShjaGFuZ2UsIDAsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLWNoYW5nZS5wcmV2VXRjT2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBycnVsZSA9IGFDb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eShcInJydWxlXCIpO1xuXG4gICAgICAgIGlmIChycnVsZSkge1xuICAgICAgICAgIHJydWxlID0gcnJ1bGUuZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgICAgIGNoYW5nZSA9IGluaXRfY2hhbmdlcygpO1xuXG4gICAgICAgICAgaWYgKHJydWxlLnVudGlsICYmIHJydWxlLnVudGlsLnpvbmUgPT0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZSkge1xuICAgICAgICAgICAgcnJ1bGUudW50aWwuYWRqdXN0KDAsIDAsIDAsIGNoYW5nZS5wcmV2VXRjT2Zmc2V0KTtcbiAgICAgICAgICAgIHJydWxlLnVudGlsLnpvbmUgPSBJQ0FMLlRpbWV6b25lLmxvY2FsVGltZXpvbmU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gcnJ1bGUuaXRlcmF0b3IoZHRzdGFydCk7XG5cbiAgICAgICAgICB2YXIgb2NjO1xuICAgICAgICAgIHdoaWxlICgob2NjID0gaXRlcmF0b3IubmV4dCgpKSkge1xuICAgICAgICAgICAgY2hhbmdlID0gaW5pdF9jaGFuZ2VzKCk7XG4gICAgICAgICAgICBpZiAob2NjLnllYXIgPiBhWWVhciB8fCAhb2NjKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGFuZ2UueWVhciA9IG9jYy55ZWFyO1xuICAgICAgICAgICAgY2hhbmdlLm1vbnRoID0gb2NjLm1vbnRoO1xuICAgICAgICAgICAgY2hhbmdlLmRheSA9IG9jYy5kYXk7XG4gICAgICAgICAgICBjaGFuZ2UuaG91ciA9IG9jYy5ob3VyO1xuICAgICAgICAgICAgY2hhbmdlLm1pbnV0ZSA9IG9jYy5taW51dGU7XG4gICAgICAgICAgICBjaGFuZ2Uuc2Vjb25kID0gb2NjLnNlY29uZDtcbiAgICAgICAgICAgIGNoYW5nZS5pc0RhdGUgPSBvY2MuaXNEYXRlO1xuXG4gICAgICAgICAgICBJQ0FMLlRpbWV6b25lLmFkanVzdF9jaGFuZ2UoY2hhbmdlLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtY2hhbmdlLnByZXZVdGNPZmZzZXQpO1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFuZ2VzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdGltZXpvbmUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAodGhpcy50em5hbWVzID8gdGhpcy50em5hbWVzIDogdGhpcy50emlkKTtcbiAgICB9XG4gIH07XG5cbiAgSUNBTC5UaW1lem9uZS5fY29tcGFyZV9jaGFuZ2VfZm4gPSBmdW5jdGlvbiBpY2FsdGltZXpvbmVfY29tcGFyZV9jaGFuZ2VfZm4oYSwgYikge1xuICAgIGlmIChhLnllYXIgPCBiLnllYXIpIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhLnllYXIgPiBiLnllYXIpIHJldHVybiAxO1xuXG4gICAgaWYgKGEubW9udGggPCBiLm1vbnRoKSByZXR1cm4gLTE7XG4gICAgZWxzZSBpZiAoYS5tb250aCA+IGIubW9udGgpIHJldHVybiAxO1xuXG4gICAgaWYgKGEuZGF5IDwgYi5kYXkpIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhLmRheSA+IGIuZGF5KSByZXR1cm4gMTtcblxuICAgIGlmIChhLmhvdXIgPCBiLmhvdXIpIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhLmhvdXIgPiBiLmhvdXIpIHJldHVybiAxO1xuXG4gICAgaWYgKGEubWludXRlIDwgYi5taW51dGUpIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhLm1pbnV0ZSA+IGIubWludXRlKSByZXR1cm4gMTtcblxuICAgIGlmIChhLnNlY29uZCA8IGIuc2Vjb25kKSByZXR1cm4gLTE7XG4gICAgZWxzZSBpZiAoYS5zZWNvbmQgPiBiLnNlY29uZCkgcmV0dXJuIDE7XG5cbiAgICByZXR1cm4gMDtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCB0aGUgZGF0ZS90aW1lIGZyb20gb25lIHpvbmUgdG8gdGhlIG5leHQuXG4gICAqXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lfSB0dCAgICAgICAgICAgICAgICAgIFRoZSB0aW1lIHRvIGNvbnZlcnRcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWV6b25lfSBmcm9tX3pvbmUgICAgICAgVGhlIHNvdXJjZSB6b25lIHRvIGNvbnZlcnQgZnJvbVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmV9IHRvX3pvbmUgICAgICAgICBUaGUgdGFyZ2V0IHpvbmUgdG8gY29udmVydCB0b1xuICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgICAgICAgICAgICBUaGUgY29udmVydGVkIGRhdGUvdGltZSBvYmplY3RcbiAgICovXG4gIElDQUwuVGltZXpvbmUuY29udmVydF90aW1lID0gZnVuY3Rpb24gaWNhbHRpbWV6b25lX2NvbnZlcnRfdGltZSh0dCwgZnJvbV96b25lLCB0b196b25lKSB7XG4gICAgaWYgKHR0LmlzRGF0ZSB8fFxuICAgICAgICBmcm9tX3pvbmUudHppZCA9PSB0b196b25lLnR6aWQgfHxcbiAgICAgICAgZnJvbV96b25lID09IElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZSB8fFxuICAgICAgICB0b196b25lID09IElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZSkge1xuICAgICAgdHQuem9uZSA9IHRvX3pvbmU7XG4gICAgICByZXR1cm4gdHQ7XG4gICAgfVxuXG4gICAgdmFyIHV0Y09mZnNldCA9IGZyb21fem9uZS51dGNPZmZzZXQodHQpO1xuICAgIHR0LmFkanVzdCgwLCAwLCAwLCAtIHV0Y09mZnNldCk7XG5cbiAgICB1dGNPZmZzZXQgPSB0b196b25lLnV0Y09mZnNldCh0dCk7XG4gICAgdHQuYWRqdXN0KDAsIDAsIDAsIHV0Y09mZnNldCk7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBJQ0FMLlRpbWV6b25lIGluc3RhbmNlIGZyb20gdGhlIHBhc3NlZCBkYXRhIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudHxPYmplY3R9IGFEYXRhIG9wdGlvbnMgZm9yIGNsYXNzXG4gICAqIEBwYXJhbSB7U3RyaW5nfElDQUwuQ29tcG9uZW50fSBhRGF0YS5jb21wb25lbnRcbiAgICogICAgICAgIElmIGFEYXRhIGlzIGEgc2ltcGxlIG9iamVjdCwgdGhlbiB0aGlzIG1lbWJlciBjYW4gYmUgc2V0IHRvIGVpdGhlciBhXG4gICAqICAgICAgICBzdHJpbmcgY29udGFpbmluZyB0aGUgY29tcG9uZW50IGRhdGEsIG9yIGFuIGFscmVhZHkgcGFyc2VkXG4gICAqICAgICAgICBJQ0FMLkNvbXBvbmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYURhdGEudHppZCAgICAgIFRoZSB0aW1lem9uZSBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS5sb2NhdGlvbiAgVGhlIHRpbWV6b25lIGxvY2F0aW9ud1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYURhdGEudHpuYW1lcyAgIEFuIGFsdGVybmF0aXZlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXpvbmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmxhdGl0dWRlICBUaGUgbGF0aXR1ZGUgb2YgdGhlIHRpbWV6b25lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5sb25naXR1ZGUgVGhlIGxvbmdpdHVkZSBvZiB0aGUgdGltZXpvbmVcbiAgICovXG4gIElDQUwuVGltZXpvbmUuZnJvbURhdGEgPSBmdW5jdGlvbiBpY2FsdGltZXpvbmVfZnJvbURhdGEoYURhdGEpIHtcbiAgICB2YXIgdHQgPSBuZXcgSUNBTC5UaW1lem9uZSgpO1xuICAgIHJldHVybiB0dC5mcm9tRGF0YShhRGF0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBpbnN0YW5jZSBkZXNjcmliaW5nIHRoZSBVVEMgdGltZXpvbmVcbiAgICogQHR5cGUge0lDQUwuVGltZXpvbmV9XG4gICAqIEBjb25zdGFudFxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIElDQUwuVGltZXpvbmUudXRjVGltZXpvbmUgPSBJQ0FMLlRpbWV6b25lLmZyb21EYXRhKHtcbiAgICB0emlkOiBcIlVUQ1wiXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5zdGFuY2UgZGVzY3JpYmluZyB0aGUgbG9jYWwgdGltZXpvbmVcbiAgICogQHR5cGUge0lDQUwuVGltZXpvbmV9XG4gICAqIEBjb25zdGFudFxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZSA9IElDQUwuVGltZXpvbmUuZnJvbURhdGEoe1xuICAgIHR6aWQ6IFwiZmxvYXRpbmdcIlxuICB9KTtcblxuICAvKipcbiAgICogQWRqdXN0IGEgdGltZXpvbmUgY2hhbmdlIG9iamVjdC5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5nZSAgICAgVGhlIHRpbWV6b25lIGNoYW5nZSBvYmplY3RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRheXMgICAgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBkYXlzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBob3VycyAgICAgIFRoZSBleHRyYSBhbW91bnQgb2YgaG91cnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbnV0ZXMgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBtaW51dGVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmRzICAgIFRoZSBleHRyYSBhbW91bnQgb2Ygc2Vjb25kc1xuICAgKi9cbiAgSUNBTC5UaW1lem9uZS5hZGp1c3RfY2hhbmdlID0gZnVuY3Rpb24gaWNhbHRpbWV6b25lX2FkanVzdF9jaGFuZ2UoY2hhbmdlLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcykge1xuICAgIHJldHVybiBJQ0FMLlRpbWUucHJvdG90eXBlLmFkanVzdC5jYWxsKFxuICAgICAgY2hhbmdlLFxuICAgICAgZGF5cyxcbiAgICAgIGhvdXJzLFxuICAgICAgbWludXRlcyxcbiAgICAgIHNlY29uZHMsXG4gICAgICBjaGFuZ2VcbiAgICApO1xuICB9O1xuXG4gIElDQUwuVGltZXpvbmUuX21pbmltdW1FeHBhbnNpb25ZZWFyID0gLTE7XG4gIElDQUwuVGltZXpvbmUuTUFYX1lFQVIgPSAyMDM1OyAvLyBUT0RPIHRoaXMgaXMgYmVjYXVzZSBvZiB0aW1lX3QsIHdoaWNoIHdlIGRvbid0IG5lZWQuIFN0aWxsIHVzZWZ1bGw/XG4gIElDQUwuVGltZXpvbmUuRVhUUkFfQ09WRVJBR0UgPSA1O1xufSkoKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLlRpbWV6b25lU2VydmljZSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHpvbmVzO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFNpbmdsZXRvbiBjbGFzcyB0byBjb250YWluIHRpbWV6b25lcy4gIFJpZ2h0IG5vdyBpdCBpcyBhbGwgbWFudWFsIHJlZ2lzdHJ5IGluXG4gICAqIHRoZSBmdXR1cmUgd2UgbWF5IHVzZSB0aGlzIGNsYXNzIHRvIGRvd25sb2FkIHRpbWV6b25lIGluZm9ybWF0aW9uIG9yIGhhbmRsZVxuICAgKiBsb2FkaW5nIHByZS1leHBhbmRlZCB0aW1lem9uZXMuXG4gICAqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQGFsaWFzIElDQUwuVGltZXpvbmVTZXJ2aWNlXG4gICAqL1xuICB2YXIgVGltZXpvbmVTZXJ2aWNlID0ge1xuICAgIGdldCBjb3VudCgpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh6b25lcykubGVuZ3RoO1xuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB6b25lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB2YXIgdXRjID0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZTtcblxuICAgICAgem9uZXMuWiA9IHV0YztcbiAgICAgIHpvbmVzLlVUQyA9IHV0YztcbiAgICAgIHpvbmVzLkdNVCA9IHV0YztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRpbWV6b25lIGlkIGhhcyBiZWVuIHJlZ2lzdGVyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHppZCAgICAgVGltZXpvbmUgaWRlbnRpZmllciAoZS5nLiBBbWVyaWNhL0xvc19BbmdlbGVzKVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBGYWxzZSwgd2hlbiBub3QgcHJlc2VudFxuICAgICAqL1xuICAgIGhhczogZnVuY3Rpb24odHppZCkge1xuICAgICAgcmV0dXJuICEhem9uZXNbdHppZF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB0aW1lem9uZSBieSBpdHMgdHppZCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR6aWQgICAgIFRpbWV6b25lIGlkZW50aWZpZXIgKGUuZy4gQW1lcmljYS9Mb3NfQW5nZWxlcylcbiAgICAgKiBAcmV0dXJuIHs/SUNBTC5UaW1lem9uZX0gVGhlIHRpbWV6b25lLCBvciBudWxsIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24odHppZCkge1xuICAgICAgcmV0dXJuIHpvbmVzW3R6aWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSB0aW1lem9uZSBvYmplY3Qgb3IgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmc9fSBuYW1lXG4gICAgICogICAgICAgIFRoZSBuYW1lIG9mIHRoZSB0aW1lem9uZS4gRGVmYXVsdHMgdG8gdGhlIGNvbXBvbmVudCdzIFRaSUQgaWYgbm90XG4gICAgICogICAgICAgIHBhc3NlZC5cbiAgICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fElDQUwuVGltZXpvbmV9IHpvbmVcbiAgICAgKiAgICAgICAgVGhlIGluaXRpYWxpemVkIHpvbmUgb3IgdnRpbWV6b25lLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbihuYW1lLCB0aW1lem9uZSkge1xuICAgICAgaWYgKG5hbWUgaW5zdGFuY2VvZiBJQ0FMLkNvbXBvbmVudCkge1xuICAgICAgICBpZiAobmFtZS5uYW1lID09PSAndnRpbWV6b25lJykge1xuICAgICAgICAgIHRpbWV6b25lID0gbmV3IElDQUwuVGltZXpvbmUobmFtZSk7XG4gICAgICAgICAgbmFtZSA9IHRpbWV6b25lLnR6aWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRpbWV6b25lIGluc3RhbmNlb2YgSUNBTC5UaW1lem9uZSkge1xuICAgICAgICB6b25lc1tuYW1lXSA9IHRpbWV6b25lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGltZXpvbmUgbXVzdCBiZSBJQ0FMLlRpbWV6b25lIG9yIElDQUwuQ29tcG9uZW50Jyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB0aW1lem9uZSBieSBpdHMgdHppZCBmcm9tIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR6aWQgICAgIFRpbWV6b25lIGlkZW50aWZpZXIgKGUuZy4gQW1lcmljYS9Mb3NfQW5nZWxlcylcbiAgICAgKiBAcmV0dXJuIHs/SUNBTC5UaW1lem9uZX0gVGhlIHJlbW92ZWQgdGltZXpvbmUsIG9yIG51bGwgaWYgbm90IHJlZ2lzdGVyZWRcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKHR6aWQpIHtcbiAgICAgIHJldHVybiAoZGVsZXRlIHpvbmVzW3R6aWRdKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gaW5pdGlhbGl6ZSBkZWZhdWx0c1xuICBUaW1lem9uZVNlcnZpY2UucmVzZXQoKTtcblxuICByZXR1cm4gVGltZXpvbmVTZXJ2aWNlO1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogaUNhbGVuZGFyIFRpbWUgcmVwcmVzZW50YXRpb24gKHNpbWlsYXIgdG8gSlMgRGF0ZSBvYmplY3QpLiAgRnVsbHlcbiAgICogaW5kZXBlbmRlbnQgb2Ygc3lzdGVtIChPUykgdGltZXpvbmUgLyB0aW1lLiAgVW5saWtlIEpTIERhdGUsIHRoZSBtb250aFxuICAgKiBKYW51YXJ5IGlzIDEsIG5vdCB6ZXJvLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgdGltZSA9IG5ldyBJQ0FMLlRpbWUoe1xuICAgKiAgIHllYXI6IDIwMTIsXG4gICAqICAgbW9udGg6IDEwLFxuICAgKiAgIGRheTogMTFcbiAgICogICBtaW51dGU6IDAsXG4gICAqICAgc2Vjb25kOiAwLFxuICAgKiAgIGlzRGF0ZTogZmFsc2VcbiAgICogfSk7XG4gICAqXG4gICAqXG4gICAqIEBhbGlhcyBJQ0FMLlRpbWVcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICBUaW1lIGluaXRpYWxpemF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS55ZWFyICAgICBUaGUgeWVhciBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5tb250aCAgICBUaGUgbW9udGggZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEuZGF5ICAgICAgVGhlIGRheSBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5ob3VyICAgICBUaGUgaG91ciBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5taW51dGUgICBUaGUgbWludXRlIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLnNlY29uZCAgIFRoZSBzZWNvbmQgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBkYXRhLmlzRGF0ZSAgSWYgdHJ1ZSwgdGhlIGluc3RhbmNlIHJlcHJlc2VudHMgYSBkYXRlIChhc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHBvc2VkIHRvIGEgZGF0ZS10aW1lKVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmV9IHpvbmUgdGltZXpvbmUgdGhpcyBwb3NpdGlvbiBvY2N1cnMgaW5cbiAgICovXG4gIElDQUwuVGltZSA9IGZ1bmN0aW9uIGljYWx0aW1lKGRhdGEsIHpvbmUpIHtcbiAgICB0aGlzLndyYXBwZWRKU09iamVjdCA9IHRoaXM7XG4gICAgdmFyIHRpbWUgPSB0aGlzLl90aW1lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8qIHRpbWUgZGVmYXVsdHMgKi9cbiAgICB0aW1lLnllYXIgPSAwO1xuICAgIHRpbWUubW9udGggPSAxO1xuICAgIHRpbWUuZGF5ID0gMTtcbiAgICB0aW1lLmhvdXIgPSAwO1xuICAgIHRpbWUubWludXRlID0gMDtcbiAgICB0aW1lLnNlY29uZCA9IDA7XG4gICAgdGltZS5pc0RhdGUgPSBmYWxzZTtcblxuICAgIHRoaXMuZnJvbURhdGEoZGF0YSwgem9uZSk7XG4gIH07XG5cbiAgSUNBTC5UaW1lLl9kb3dDYWNoZSA9IHt9O1xuICBJQ0FMLlRpbWUuX3duQ2FjaGUgPSB7fTtcblxuICBJQ0FMLlRpbWUucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNsYXNzIGlkZW50aWZpZXIuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcImljYWx0aW1lXCJcbiAgICAgKi9cbiAgICBpY2FsY2xhc3M6IFwiaWNhbHRpbWVcIixcbiAgICBfY2FjaGVkVW5peFRpbWU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBuYW1lLCB0byBiZSB1c2VkIGluIHRoZSBqQ2FsIG9iamVjdC4gVGhpcyB2YWx1ZSBtYXkgY2hhbmdlIGFuZFxuICAgICAqIGlzIHN0cmljdGx5IGRlZmluZWQgYnkgdGhlIHtAbGluayBJQ0FMLlRpbWUjaXNEYXRlIGlzRGF0ZX0gbWVtYmVyLlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJkYXRlLXRpbWVcIlxuICAgICAqL1xuICAgIGdldCBpY2FsdHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzRGF0ZSA/ICdkYXRlJyA6ICdkYXRlLXRpbWUnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGltZXpvbmUgZm9yIHRoaXMgdGltZS5cbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lem9uZX1cbiAgICAgKi9cbiAgICB6b25lOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgdXNlcyB0byBpbmRpY2F0ZSB0aGF0IGEgY2hhbmdlIGhhcyBiZWVuIG1hZGUgYW5kIHRoZSBuZXh0IHJlYWRcbiAgICAgKiBvcGVyYXRpb24gbXVzdCBhdHRlbXB0IHRvIG5vcm1hbGl6ZSB0aGUgdmFsdWUgKGZvciBleGFtcGxlIGNoYW5naW5nIHRoZVxuICAgICAqIGRheSB0byAzMykuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wZW5kaW5nTm9ybWFsaXphdGlvbjogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIHRpbWUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgICAgICAgICAgVGhlIGNsb25lZCBvYmplY3RcbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IElDQUwuVGltZSh0aGlzLl90aW1lLCB0aGlzLnpvbmUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgdGltZSBpbnN0YW5jZSB0byBlcG9jaCB0aW1lXG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIGljYWx0aW1lX3Jlc2V0KCkge1xuICAgICAgdGhpcy5mcm9tRGF0YShJQ0FMLlRpbWUuZXBvY2hUaW1lKTtcbiAgICAgIHRoaXMuem9uZSA9IElDQUwuVGltZXpvbmUudXRjVGltZXpvbmU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSB0aW1lIGluc3RhbmNlIHRvIHRoZSBnaXZlbiBkYXRlL3RpbWUgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXIgICAgICAgICAgICAgVGhlIHllYXIgdG8gc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1vbnRoICAgICAgICAgICAgVGhlIG1vbnRoIHRvIHNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXkgICAgICAgICAgICAgIFRoZSBkYXkgdG8gc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhvdXIgICAgICAgICAgICAgVGhlIGhvdXIgdG8gc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbnV0ZSAgICAgICAgICAgVGhlIG1pbnV0ZSB0byBzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kICAgICAgICAgICBUaGUgc2Vjb25kIHRvIHNldFxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lem9uZX0gdGltZXpvbmUgIFRoZSB0aW1lem9uZSB0byBzZXRcbiAgICAgKi9cbiAgICByZXNldFRvOiBmdW5jdGlvbiBpY2FsdGltZV9yZXNldFRvKHllYXIsIG1vbnRoLCBkYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3VyLCBtaW51dGUsIHNlY29uZCwgdGltZXpvbmUpIHtcbiAgICAgIHRoaXMuZnJvbURhdGEoe1xuICAgICAgICB5ZWFyOiB5ZWFyLFxuICAgICAgICBtb250aDogbW9udGgsXG4gICAgICAgIGRheTogZGF5LFxuICAgICAgICBob3VyOiBob3VyLFxuICAgICAgICBtaW51dGU6IG1pbnV0ZSxcbiAgICAgICAgc2Vjb25kOiBzZWNvbmQsXG4gICAgICAgIHpvbmU6IHRpbWV6b25lXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIGZyb20gdGhlIEphdmFzY3JpcHQgZGF0ZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P0RhdGV9IGFEYXRlICAgICBUaGUgSmF2YXNjcmlwdCBEYXRlIHRvIHJlYWQsIG9yIG51bGwgdG8gcmVzZXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVzZVVUQyAgSWYgdHJ1ZSwgdGhlIFVUQyB2YWx1ZXMgb2YgdGhlIGRhdGUgd2lsbCBiZSB1c2VkXG4gICAgICovXG4gICAgZnJvbUpTRGF0ZTogZnVuY3Rpb24gaWNhbHRpbWVfZnJvbUpTRGF0ZShhRGF0ZSwgdXNlVVRDKSB7XG4gICAgICBpZiAoIWFEYXRlKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh1c2VVVEMpIHtcbiAgICAgICAgICB0aGlzLnpvbmUgPSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lO1xuICAgICAgICAgIHRoaXMueWVhciA9IGFEYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgdGhpcy5tb250aCA9IGFEYXRlLmdldFVUQ01vbnRoKCkgKyAxO1xuICAgICAgICAgIHRoaXMuZGF5ID0gYURhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgIHRoaXMuaG91ciA9IGFEYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgICAgdGhpcy5taW51dGUgPSBhRGF0ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgICAgdGhpcy5zZWNvbmQgPSBhRGF0ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy56b25lID0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lO1xuICAgICAgICAgIHRoaXMueWVhciA9IGFEYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgdGhpcy5tb250aCA9IGFEYXRlLmdldE1vbnRoKCkgKyAxO1xuICAgICAgICAgIHRoaXMuZGF5ID0gYURhdGUuZ2V0RGF0ZSgpO1xuICAgICAgICAgIHRoaXMuaG91ciA9IGFEYXRlLmdldEhvdXJzKCk7XG4gICAgICAgICAgdGhpcy5taW51dGUgPSBhRGF0ZS5nZXRNaW51dGVzKCk7XG4gICAgICAgICAgdGhpcy5zZWNvbmQgPSBhRGF0ZS5nZXRTZWNvbmRzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIHVzaW5nIG1lbWJlcnMgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgICAgVGltZSBpbml0aWFsaXphdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEueWVhciAgICAgIFRoZSB5ZWFyIGZvciB0aGlzIGRhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLm1vbnRoICAgICBUaGUgbW9udGggZm9yIHRoaXMgZGF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuZGF5ICAgICAgIFRoZSBkYXkgZm9yIHRoaXMgZGF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuaG91ciAgICAgIFRoZSBob3VyIGZvciB0aGlzIGRhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLm1pbnV0ZSAgICBUaGUgbWludXRlIGZvciB0aGlzIGRhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLnNlY29uZCAgICBUaGUgc2Vjb25kIGZvciB0aGlzIGRhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBhRGF0YS5pc0RhdGUgICBJZiB0cnVlLCB0aGUgaW5zdGFuY2UgcmVwcmVzZW50cyBhIGRhdGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhcyBvcHBvc2VkIHRvIGEgZGF0ZS10aW1lKVxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lem9uZT19IGFab25lICAgIFRpbWV6b25lIHRoaXMgcG9zaXRpb24gb2NjdXJzIGluXG4gICAgICovXG4gICAgZnJvbURhdGE6IGZ1bmN0aW9uIGZyb21EYXRhKGFEYXRhLCBhWm9uZSkge1xuICAgICAgaWYgKGFEYXRhKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhRGF0YSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhRGF0YSwga2V5KSkge1xuICAgICAgICAgICAgLy8gaWNhbCB0eXBlIGNhbm5vdCBiZSBzZXRcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdpY2FsdHlwZScpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpc1trZXldID0gYURhdGFba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFab25lKSB7XG4gICAgICAgIHRoaXMuem9uZSA9IGFab25lO1xuICAgICAgfVxuXG4gICAgICBpZiAoYURhdGEgJiYgIShcImlzRGF0ZVwiIGluIGFEYXRhKSkge1xuICAgICAgICB0aGlzLmlzRGF0ZSA9ICEoXCJob3VyXCIgaW4gYURhdGEpO1xuICAgICAgfSBlbHNlIGlmIChhRGF0YSAmJiAoXCJpc0RhdGVcIiBpbiBhRGF0YSkpIHtcbiAgICAgICAgdGhpcy5pc0RhdGUgPSBhRGF0YS5pc0RhdGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhRGF0YSAmJiBcInRpbWV6b25lXCIgaW4gYURhdGEpIHtcbiAgICAgICAgdmFyIHpvbmUgPSBJQ0FMLlRpbWV6b25lU2VydmljZS5nZXQoXG4gICAgICAgICAgYURhdGEudGltZXpvbmVcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnpvbmUgPSB6b25lIHx8IElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFEYXRhICYmIFwiem9uZVwiIGluIGFEYXRhKSB7XG4gICAgICAgIHRoaXMuem9uZSA9IGFEYXRhLnpvbmU7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy56b25lKSB7XG4gICAgICAgIHRoaXMuem9uZSA9IElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2FjaGVkVW5peFRpbWUgPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZGF5IG9mIHdlZWsuXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGFXZWVrU3RhcnRcbiAgICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lLndlZWtEYXl9XG4gICAgICovXG4gICAgZGF5T2ZXZWVrOiBmdW5jdGlvbiBpY2FsdGltZV9kYXlPZldlZWsoYVdlZWtTdGFydCkge1xuICAgICAgdmFyIGZpcnN0RG93ID0gYVdlZWtTdGFydCB8fCBJQ0FMLlRpbWUuU1VOREFZO1xuICAgICAgdmFyIGRvd0NhY2hlS2V5ID0gKHRoaXMueWVhciA8PCAxMikgKyAodGhpcy5tb250aCA8PCA4KSArICh0aGlzLmRheSA8PCAzKSArIGZpcnN0RG93O1xuICAgICAgaWYgKGRvd0NhY2hlS2V5IGluIElDQUwuVGltZS5fZG93Q2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVGltZS5fZG93Q2FjaGVbZG93Q2FjaGVLZXldO1xuICAgICAgfVxuXG4gICAgICAvLyBVc2luZyBaZWxsZXIncyBhbGdvcml0aG1cbiAgICAgIHZhciBxID0gdGhpcy5kYXk7XG4gICAgICB2YXIgbSA9IHRoaXMubW9udGggKyAodGhpcy5tb250aCA8IDMgPyAxMiA6IDApO1xuICAgICAgdmFyIFkgPSB0aGlzLnllYXIgLSAodGhpcy5tb250aCA8IDMgPyAxIDogMCk7XG5cbiAgICAgIHZhciBoID0gKHEgKyBZICsgSUNBTC5oZWxwZXJzLnRydW5jKCgobSArIDEpICogMjYpIC8gMTApICsgSUNBTC5oZWxwZXJzLnRydW5jKFkgLyA0KSk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHRydWUgLyogZ3JlZ29yaWFuICovKSB7XG4gICAgICAgIGggKz0gSUNBTC5oZWxwZXJzLnRydW5jKFkgLyAxMDApICogNiArIElDQUwuaGVscGVycy50cnVuYyhZIC8gNDAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGggKz0gNTtcbiAgICAgIH1cblxuICAgICAgLy8gTm9ybWFsaXplIHRvIDEgPSB3a3N0XG4gICAgICBoID0gKChoICsgNyAtIGZpcnN0RG93KSAlIDcpICsgMTtcbiAgICAgIElDQUwuVGltZS5fZG93Q2FjaGVbZG93Q2FjaGVLZXldID0gaDtcbiAgICAgIHJldHVybiBoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGRheSBvZiB5ZWFyLlxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBkYXlPZlllYXI6IGZ1bmN0aW9uIGRheU9mWWVhcigpIHtcbiAgICAgIHZhciBpc19sZWFwID0gKElDQUwuVGltZS5pc0xlYXBZZWFyKHRoaXMueWVhcikgPyAxIDogMCk7XG4gICAgICB2YXIgZGl5cG0gPSBJQ0FMLlRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoO1xuICAgICAgcmV0dXJuIGRpeXBtW2lzX2xlYXBdW3RoaXMubW9udGggLSAxXSArIHRoaXMuZGF5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHJld291bmQgdG8gdGhlIHN0YXJ0IG9mIHRoZVxuICAgICAqIHdlZWsuIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWYgdGhpc1xuICAgICAqIGlzIGEgZGF0ZS10aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGFXZWVrU3RhcnRcbiAgICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgIFRoZSBzdGFydCBvZiB0aGUgd2VlayAoY2xvbmVkKVxuICAgICAqL1xuICAgIHN0YXJ0T2ZXZWVrOiBmdW5jdGlvbiBzdGFydE9mV2VlayhhV2Vla1N0YXJ0KSB7XG4gICAgICB2YXIgZmlyc3REb3cgPSBhV2Vla1N0YXJ0IHx8IElDQUwuVGltZS5TVU5EQVk7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgcmVzdWx0LmRheSAtPSAoKHRoaXMuZGF5T2ZXZWVrKCkgKyA3IC0gZmlyc3REb3cpICUgNyk7XG4gICAgICByZXN1bHQuaXNEYXRlID0gdHJ1ZTtcbiAgICAgIHJlc3VsdC5ob3VyID0gMDtcbiAgICAgIHJlc3VsdC5taW51dGUgPSAwO1xuICAgICAgcmVzdWx0LnNlY29uZCA9IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHNoaWZ0ZWQgdG8gdGhlIGVuZCBvZiB0aGUgd2Vlay5cbiAgICAgKiBUaGUgcmVzdWx0aW5nIElDQUwuVGltZSBpbnN0YW5jZSBpcyBvZiBpY2FsdHlwZSBkYXRlLCBldmVuIGlmIHRoaXMgaXMgYVxuICAgICAqIGRhdGUtdGltZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lLndlZWtEYXk9fSBhV2Vla1N0YXJ0XG4gICAgICogICAgICAgIFRoZSB3ZWVrIHN0YXJ0IHdlZWtkYXksIGRlZmF1bHRzIHRvIFNVTkRBWVxuICAgICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICBUaGUgZW5kIG9mIHRoZSB3ZWVrIChjbG9uZWQpXG4gICAgICovXG4gICAgZW5kT2ZXZWVrOiBmdW5jdGlvbiBlbmRPZldlZWsoYVdlZWtTdGFydCkge1xuICAgICAgdmFyIGZpcnN0RG93ID0gYVdlZWtTdGFydCB8fCBJQ0FMLlRpbWUuU1VOREFZO1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIHJlc3VsdC5kYXkgKz0gKDcgLSB0aGlzLmRheU9mV2VlaygpICsgZmlyc3REb3cgLSBJQ0FMLlRpbWUuU1VOREFZKSAlIDc7XG4gICAgICByZXN1bHQuaXNEYXRlID0gdHJ1ZTtcbiAgICAgIHJlc3VsdC5ob3VyID0gMDtcbiAgICAgIHJlc3VsdC5taW51dGUgPSAwO1xuICAgICAgcmVzdWx0LnNlY29uZCA9IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHJld291bmQgdG8gdGhlIHN0YXJ0IG9mIHRoZVxuICAgICAqIG1vbnRoLiBUaGUgcmVzdWx0aW5nIElDQUwuVGltZSBpbnN0YW5jZSBpcyBvZiBpY2FsdHlwZSBkYXRlLCBldmVuIGlmXG4gICAgICogdGhpcyBpcyBhIGRhdGUtdGltZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICBUaGUgc3RhcnQgb2YgdGhlIG1vbnRoIChjbG9uZWQpXG4gICAgICovXG4gICAgc3RhcnRPZk1vbnRoOiBmdW5jdGlvbiBzdGFydE9mTW9udGgoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgcmVzdWx0LmRheSA9IDE7XG4gICAgICByZXN1bHQuaXNEYXRlID0gdHJ1ZTtcbiAgICAgIHJlc3VsdC5ob3VyID0gMDtcbiAgICAgIHJlc3VsdC5taW51dGUgPSAwO1xuICAgICAgcmVzdWx0LnNlY29uZCA9IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHNoaWZ0ZWQgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICAgKiBtb250aC4gIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWZcbiAgICAgKiB0aGlzIGlzIGEgZGF0ZS10aW1lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgIFRoZSBlbmQgb2YgdGhlIG1vbnRoIChjbG9uZWQpXG4gICAgICovXG4gICAgZW5kT2ZNb250aDogZnVuY3Rpb24gZW5kT2ZNb250aCgpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICByZXN1bHQuZGF5ID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHJlc3VsdC5tb250aCwgcmVzdWx0LnllYXIpO1xuICAgICAgcmVzdWx0LmlzRGF0ZSA9IHRydWU7XG4gICAgICByZXN1bHQuaG91ciA9IDA7XG4gICAgICByZXN1bHQubWludXRlID0gMDtcbiAgICAgIHJlc3VsdC5zZWNvbmQgPSAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgZGF0ZS90aW1lLCByZXdvdW5kIHRvIHRoZSBzdGFydCBvZiB0aGVcbiAgICAgKiB5ZWFyLiBUaGUgcmVzdWx0aW5nIElDQUwuVGltZSBpbnN0YW5jZSBpcyBvZiBpY2FsdHlwZSBkYXRlLCBldmVuIGlmXG4gICAgICogdGhpcyBpcyBhIGRhdGUtdGltZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICBUaGUgc3RhcnQgb2YgdGhlIHllYXIgKGNsb25lZClcbiAgICAgKi9cbiAgICBzdGFydE9mWWVhcjogZnVuY3Rpb24gc3RhcnRPZlllYXIoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgcmVzdWx0LmRheSA9IDE7XG4gICAgICByZXN1bHQubW9udGggPSAxO1xuICAgICAgcmVzdWx0LmlzRGF0ZSA9IHRydWU7XG4gICAgICByZXN1bHQuaG91ciA9IDA7XG4gICAgICByZXN1bHQubWludXRlID0gMDtcbiAgICAgIHJlc3VsdC5zZWNvbmQgPSAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgZGF0ZS90aW1lLCBzaGlmdGVkIHRvIHRoZSBlbmQgb2YgdGhlXG4gICAgICogeWVhci4gIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWZcbiAgICAgKiB0aGlzIGlzIGEgZGF0ZS10aW1lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgIFRoZSBlbmQgb2YgdGhlIHllYXIgKGNsb25lZClcbiAgICAgKi9cbiAgICBlbmRPZlllYXI6IGZ1bmN0aW9uIGVuZE9mWWVhcigpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICByZXN1bHQuZGF5ID0gMzE7XG4gICAgICByZXN1bHQubW9udGggPSAxMjtcbiAgICAgIHJlc3VsdC5pc0RhdGUgPSB0cnVlO1xuICAgICAgcmVzdWx0LmhvdXIgPSAwO1xuICAgICAgcmVzdWx0Lm1pbnV0ZSA9IDA7XG4gICAgICByZXN1bHQuc2Vjb25kID0gMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpcnN0IGNhbGN1bGF0ZXMgdGhlIHN0YXJ0IG9mIHRoZSB3ZWVrLCB0aGVuIHJldHVybnMgdGhlIGRheSBvZiB5ZWFyIGZvclxuICAgICAqIHRoaXMgZGF0ZS4gSWYgdGhlIGRheSBmYWxscyBpbnRvIHRoZSBwcmV2aW91cyB5ZWFyLCB0aGUgZGF5IGlzIHplcm8gb3IgbmVnYXRpdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5PX0gYUZpcnN0RGF5T2ZXZWVrXG4gICAgICogICAgICAgIFRoZSB3ZWVrIHN0YXJ0IHdlZWtkYXksIGRlZmF1bHRzIHRvIFNVTkRBWVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgIFRoZSBjYWxjdWxhdGVkIGRheSBvZiB5ZWFyXG4gICAgICovXG4gICAgc3RhcnREb3lXZWVrOiBmdW5jdGlvbiBzdGFydERveVdlZWsoYUZpcnN0RGF5T2ZXZWVrKSB7XG4gICAgICB2YXIgZmlyc3REb3cgPSBhRmlyc3REYXlPZldlZWsgfHwgSUNBTC5UaW1lLlNVTkRBWTtcbiAgICAgIHZhciBkZWx0YSA9IHRoaXMuZGF5T2ZXZWVrKCkgLSBmaXJzdERvdztcbiAgICAgIGlmIChkZWx0YSA8IDApIGRlbHRhICs9IDc7XG4gICAgICByZXR1cm4gdGhpcy5kYXlPZlllYXIoKSAtIGRlbHRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRvbWluaWNhbCBsZXR0ZXIgZm9yIHRoZSBjdXJyZW50IHllYXIuIExldHRlcnMgcmFuZ2UgZnJvbSBBIC0gR1xuICAgICAqIGZvciBjb21tb24geWVhcnMsIGFuZCBBRyB0byBHRiBmb3IgbGVhcCB5ZWFycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5ciAgICAgICAgICAgVGhlIHllYXIgdG8gcmV0cmlldmUgdGhlIGxldHRlciBmb3JcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgIFRoZSBkb21pbmljYWwgbGV0dGVyLlxuICAgICAqL1xuICAgIGdldERvbWluaWNhbExldHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gSUNBTC5UaW1lLmdldERvbWluaWNhbExldHRlcih0aGlzLnllYXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbnRoV2Vla0RheSByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBtb250aCAobm90IGRheSkuICBUaGVcbiAgICAgKiByZXR1cm5lZCB2YWx1ZSBpcyBhIGRheSByZWxhdGl2ZSB0aGUgbW9udGggdGhhdCB0aGlzIG1vbnRoIGJlbG9uZ3MgdG8gc29cbiAgICAgKiAxIHdvdWxkIGluZGljYXRlIHRoZSBmaXJzdCBvZiB0aGUgbW9udGggYW5kIDQwIHdvdWxkIGluZGljYXRlIGEgZGF5IGluXG4gICAgICogdGhlIGZvbGxvd2luZyBtb250aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF5T2ZXZWVrICAgRGF5IG9mIHRoZSB3ZWVrIHNlZSB0aGUgZGF5IG5hbWUgY29uc3RhbnRzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFQb3MgICAgICAgICBOdGggb2NjdXJyZW5jZSBvZiBhIGdpdmVuIHdlZWsgZGF5IHZhbHVlc1xuICAgICAqICAgICAgICBvZiAxIGFuZCAwIGJvdGggaW5kaWNhdGUgdGhlIGZpcnN0IHdlZWtkYXkgb2YgdGhhdCB0eXBlLiBhUG9zIG1heVxuICAgICAqICAgICAgICBiZSBlaXRoZXIgcG9zaXRpdmUgb3IgbmVnYXRpdmVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gbnVtZXJpYyB2YWx1ZSBpbmRpY2F0aW5nIGEgZGF5IHJlbGF0aXZlXG4gICAgICogICAgICAgICAgICAgICAgICAgdG8gdGhlIGN1cnJlbnQgbW9udGggb2YgdGhpcyB0aW1lIG9iamVjdFxuICAgICAqL1xuICAgIG50aFdlZWtEYXk6IGZ1bmN0aW9uIGljYWx0aW1lX250aFdlZWtEYXkoYURheU9mV2VlaywgYVBvcykge1xuICAgICAgdmFyIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHRoaXMubW9udGgsIHRoaXMueWVhcik7XG4gICAgICB2YXIgd2Vla2RheTtcbiAgICAgIHZhciBwb3MgPSBhUG9zO1xuXG4gICAgICB2YXIgc3RhcnQgPSAwO1xuXG4gICAgICB2YXIgb3RoZXJEYXkgPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICBvdGhlckRheS5kYXkgPSAxO1xuXG4gICAgICAgIC8vIGJlY2F1c2UgMCBtZWFucyBubyBwb3NpdGlvbiBoYXMgYmVlbiBnaXZlblxuICAgICAgICAvLyAxIGFuZCAwIGluZGljYXRlIHRoZSBzYW1lIGRheS5cbiAgICAgICAgaWYgKHBvcyAhPSAwKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHRoZSBleHRyYSBudW1lcmljIHZhbHVlXG4gICAgICAgICAgcG9zLS07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgY3VycmVudCBzdGFydCBvZmZzZXQgdG8gY3VycmVudCBkYXkuXG4gICAgICAgIHN0YXJ0ID0gb3RoZXJEYXkuZGF5O1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGN1cnJlbnQgZGF5IG9mIHdlZWtcbiAgICAgICAgdmFyIHN0YXJ0RG93ID0gb3RoZXJEYXkuZGF5T2ZXZWVrKCk7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gY3VycmVudFxuICAgICAgICAvLyBkYXkgb2YgdGhlIHdlZWsgYW5kIGRlc2lyZWQgZGF5IG9mIHRoZSB3ZWVrXG4gICAgICAgIHZhciBvZmZzZXQgPSBhRGF5T2ZXZWVrIC0gc3RhcnREb3c7XG5cblxuICAgICAgICAvLyBpZiB0aGUgb2Zmc2V0IGdvZXMgaW50byB0aGUgcGFzdFxuICAgICAgICAvLyB3ZWVrIHdlIGFkZCA3IHNvIGl0IGdvZXMgaW50byB0aGUgbmV4dFxuICAgICAgICAvLyB3ZWVrLiBXZSBvbmx5IHdhbnQgdG8gZ28gZm9yd2FyZCBpbiB0aW1lIGhlcmUuXG4gICAgICAgIGlmIChvZmZzZXQgPCAwKVxuICAgICAgICAgIC8vIHRoaXMgaXMgcmVhbGx5IGltcG9ydGFudCBvdGhlcndpc2Ugd2Ugd291bGRcbiAgICAgICAgICAvLyBlbmQgdXAgd2l0aCBkYXRlcyBmcm9tIGluIHRoZSBwYXN0LlxuICAgICAgICAgIG9mZnNldCArPSA3O1xuXG4gICAgICAgIC8vIGFkZCBvZmZzZXQgdG8gc3RhcnQgc28gc3RhcnQgaXMgdGhlIHNhbWVcbiAgICAgICAgLy8gZGF5IG9mIHRoZSB3ZWVrIGFzIHRoZSBkZXNpcmVkIGRheSBvZiB3ZWVrLlxuICAgICAgICBzdGFydCArPSBvZmZzZXQ7XG5cbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBhcmUgZ29pbmcgdG8gYWRkIChhbmQgbXVsdGlwbHkpXG4gICAgICAgIC8vIHRoZSBudW1lcmljIHZhbHVlIG9mIHRoZSBkYXkgd2Ugc3VidHJhY3QgaXRcbiAgICAgICAgLy8gZnJvbSB0aGUgc3RhcnQgcG9zaXRpb24gc28gbm90IHRvIGFkZCBpdCB0d2ljZS5cbiAgICAgICAgc3RhcnQgLT0gYURheU9mV2VlaztcblxuICAgICAgICAvLyBzZXQgd2VlayBkYXlcbiAgICAgICAgd2Vla2RheSA9IGFEYXlPZldlZWs7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIHRoZW4gd2Ugc2V0IGl0IHRvIHRoZSBsYXN0IGRheSBpbiB0aGUgY3VycmVudCBtb250aFxuICAgICAgICBvdGhlckRheS5kYXkgPSBkYXlzSW5Nb250aDtcblxuICAgICAgICAvLyBmaW5kIHRoZSBlbmRzIHdlZWtkYXlcbiAgICAgICAgdmFyIGVuZERvdyA9IG90aGVyRGF5LmRheU9mV2VlaygpO1xuXG4gICAgICAgIHBvcysrO1xuXG4gICAgICAgIHdlZWtkYXkgPSAoZW5kRG93IC0gYURheU9mV2Vlayk7XG5cbiAgICAgICAgaWYgKHdlZWtkYXkgPCAwKSB7XG4gICAgICAgICAgd2Vla2RheSArPSA3O1xuICAgICAgICB9XG5cbiAgICAgICAgd2Vla2RheSA9IGRheXNJbk1vbnRoIC0gd2Vla2RheTtcbiAgICAgIH1cblxuICAgICAgd2Vla2RheSArPSBwb3MgKiA3O1xuXG4gICAgICByZXR1cm4gc3RhcnQgKyB3ZWVrZGF5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgY3VycmVudCB0aW1lIGlzIHRoZSBudGggd2Vla2RheSwgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnRcbiAgICAgKiBtb250aC4gIFdpbGwgYWx3YXlzIHJldHVybiBmYWxzZSB3aGVuIHJ1bGUgcmVzb2x2ZXMgb3V0c2lkZSBvZiBjdXJyZW50XG4gICAgICogbW9udGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5fSBhRGF5T2ZXZWVrICAgICAgIERheSBvZiB3ZWVrIHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFQb3MgICAgICAgICAgICAgICAgICAgICAgICBSZWxhdGl2ZSBwb3NpdGlvblxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJ1ZSwgaWYgaXQgaXMgdGhlIG50aCB3ZWVrZGF5XG4gICAgICovXG4gICAgaXNOdGhXZWVrRGF5OiBmdW5jdGlvbihhRGF5T2ZXZWVrLCBhUG9zKSB7XG4gICAgICB2YXIgZG93ID0gdGhpcy5kYXlPZldlZWsoKTtcblxuICAgICAgaWYgKGFQb3MgPT09IDAgJiYgZG93ID09PSBhRGF5T2ZXZWVrKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgcG9zXG4gICAgICB2YXIgZGF5ID0gdGhpcy5udGhXZWVrRGF5KGFEYXlPZldlZWssIGFQb3MpO1xuXG4gICAgICBpZiAoZGF5ID09PSB0aGlzLmRheSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBJU08gODYwMSB3ZWVrIG51bWJlci4gVGhlIGZpcnN0IHdlZWsgb2YgYSB5ZWFyIGlzIHRoZVxuICAgICAqIHdlZWsgdGhhdCBjb250YWlucyB0aGUgZmlyc3QgVGh1cnNkYXkuIFRoZSB5ZWFyIGNhbiBoYXZlIDUzIHdlZWtzLCBpZlxuICAgICAqIEphbnVhcnkgMXN0IGlzIGEgRnJpZGF5LlxuICAgICAqXG4gICAgICogTm90ZSB0aGVyZSBhcmUgcmVnaW9ucyB3aGVyZSB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhciBpcyB0aGUgb25lIHRoYXRcbiAgICAgKiBzdGFydHMgb24gSmFudWFyeSAxc3QsIHdoaWNoIG1heSBvZmZzZXQgdGhlIHdlZWsgbnVtYmVyLiBBbHNvLCBpZiBhXG4gICAgICogZGlmZmVyZW50IHdlZWsgc3RhcnQgaXMgc3BlY2lmaWVkLCB0aGlzIHdpbGwgYWxzbyBhZmZlY3QgdGhlIHdlZWtcbiAgICAgKiBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc2VlIElDQUwuVGltZS53ZWVrT25lU3RhcnRzXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheX0gYVdlZWtTdGFydCAgICAgICAgVGhlIHdlZWtkYXkgdGhlIHdlZWsgc3RhcnRzIHdpdGhcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgSVNPIHdlZWsgbnVtYmVyXG4gICAgICovXG4gICAgd2Vla051bWJlcjogZnVuY3Rpb24gd2Vla051bWJlcihhV2Vla1N0YXJ0KSB7XG4gICAgICB2YXIgd25DYWNoZUtleSA9ICh0aGlzLnllYXIgPDwgMTIpICsgKHRoaXMubW9udGggPDwgOCkgKyAodGhpcy5kYXkgPDwgMykgKyBhV2Vla1N0YXJ0O1xuICAgICAgaWYgKHduQ2FjaGVLZXkgaW4gSUNBTC5UaW1lLl93bkNhY2hlKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlRpbWUuX3duQ2FjaGVbd25DYWNoZUtleV07XG4gICAgICB9XG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIGNvdXJ0ZXN0eSBvZiBKdWxpYW4gQnVja25hbGwsIHB1Ymxpc2hlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAgICAgIC8vIGh0dHA6Ly93d3cuYm95ZXQuY29tL2FydGljbGVzL3B1Ymxpc2hlZGFydGljbGVzL2NhbGN1bGF0aW5ndGhlaXNvd2Vla251bWIuaHRtbFxuICAgICAgLy8gcGx1cyBzb21lIGZpeGVzIHRvIGJlIGFibGUgdG8gdXNlIGRpZmZlcmVudCB3ZWVrIHN0YXJ0cy5cbiAgICAgIHZhciB3ZWVrMTtcblxuICAgICAgdmFyIGR0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgZHQuaXNEYXRlID0gdHJ1ZTtcbiAgICAgIHZhciBpc295ZWFyID0gdGhpcy55ZWFyO1xuXG4gICAgICBpZiAoZHQubW9udGggPT0gMTIgJiYgZHQuZGF5ID4gMjUpIHtcbiAgICAgICAgd2VlazEgPSBJQ0FMLlRpbWUud2Vla09uZVN0YXJ0cyhpc295ZWFyICsgMSwgYVdlZWtTdGFydCk7XG4gICAgICAgIGlmIChkdC5jb21wYXJlKHdlZWsxKSA8IDApIHtcbiAgICAgICAgICB3ZWVrMSA9IElDQUwuVGltZS53ZWVrT25lU3RhcnRzKGlzb3llYXIsIGFXZWVrU3RhcnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzb3llYXIrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2VlazEgPSBJQ0FMLlRpbWUud2Vla09uZVN0YXJ0cyhpc295ZWFyLCBhV2Vla1N0YXJ0KTtcbiAgICAgICAgaWYgKGR0LmNvbXBhcmUod2VlazEpIDwgMCkge1xuICAgICAgICAgIHdlZWsxID0gSUNBTC5UaW1lLndlZWtPbmVTdGFydHMoLS1pc295ZWFyLCBhV2Vla1N0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZGF5c0JldHdlZW4gPSAoZHQuc3VidHJhY3REYXRlKHdlZWsxKS50b1NlY29uZHMoKSAvIDg2NDAwKTtcbiAgICAgIHZhciBhbnN3ZXIgPSBJQ0FMLmhlbHBlcnMudHJ1bmMoZGF5c0JldHdlZW4gLyA3KSArIDE7XG4gICAgICBJQ0FMLlRpbWUuX3duQ2FjaGVbd25DYWNoZUtleV0gPSBhbnN3ZXI7XG4gICAgICByZXR1cm4gYW5zd2VyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBkdXJhdGlvbiB0byB0aGUgY3VycmVudCB0aW1lLiBUaGUgaW5zdGFuY2UgaXMgbW9kaWZpZWQgaW5cbiAgICAgKiBwbGFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5EdXJhdGlvbn0gYUR1cmF0aW9uICAgICAgICAgVGhlIGR1cmF0aW9uIHRvIGFkZFxuICAgICAqL1xuICAgIGFkZER1cmF0aW9uOiBmdW5jdGlvbiBpY2FsdGltZV9hZGQoYUR1cmF0aW9uKSB7XG4gICAgICB2YXIgbXVsdCA9IChhRHVyYXRpb24uaXNOZWdhdGl2ZSA/IC0xIDogMSk7XG5cbiAgICAgIC8vIGJlY2F1c2Ugb2YgdGhlIGR1cmF0aW9uIG9wdGltaXphdGlvbnMgaXQgaXMgbXVjaFxuICAgICAgLy8gbW9yZSBlZmZpY2llbnQgdG8gZ3JhYiBhbGwgdGhlIHZhbHVlcyB1cCBmcm9udFxuICAgICAgLy8gdGhlbiBzZXQgdGhlbSBkaXJlY3RseSAod2hpY2ggd2lsbCBhdm9pZCBhIG5vcm1hbGl6YXRpb24gY2FsbCkuXG4gICAgICAvLyBTbyB3ZSBkb24ndCBhY3R1YWxseSBub3JtYWxpemUgdW50aWwgd2UgbmVlZCBpdC5cbiAgICAgIHZhciBzZWNvbmQgPSB0aGlzLnNlY29uZDtcbiAgICAgIHZhciBtaW51dGUgPSB0aGlzLm1pbnV0ZTtcbiAgICAgIHZhciBob3VyID0gdGhpcy5ob3VyO1xuICAgICAgdmFyIGRheSA9IHRoaXMuZGF5O1xuXG4gICAgICBzZWNvbmQgKz0gbXVsdCAqIGFEdXJhdGlvbi5zZWNvbmRzO1xuICAgICAgbWludXRlICs9IG11bHQgKiBhRHVyYXRpb24ubWludXRlcztcbiAgICAgIGhvdXIgKz0gbXVsdCAqIGFEdXJhdGlvbi5ob3VycztcbiAgICAgIGRheSArPSBtdWx0ICogYUR1cmF0aW9uLmRheXM7XG4gICAgICBkYXkgKz0gbXVsdCAqIDcgKiBhRHVyYXRpb24ud2Vla3M7XG5cbiAgICAgIHRoaXMuc2Vjb25kID0gc2Vjb25kO1xuICAgICAgdGhpcy5taW51dGUgPSBtaW51dGU7XG4gICAgICB0aGlzLmhvdXIgPSBob3VyO1xuICAgICAgdGhpcy5kYXkgPSBkYXk7XG5cbiAgICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3QgdGhlIGRhdGUgZGV0YWlscyAoX2V4Y2x1ZGluZ18gdGltZXpvbmUpLiAgVXNlZnVsIGZvciBmaW5kaW5nXG4gICAgICogdGhlIHJlbGF0aXZlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gdGltZSBvYmplY3RzIGV4Y2x1ZGluZyB0aGVpclxuICAgICAqIHRpbWV6b25lIGRpZmZlcmVuY2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IGFEYXRlICAgICBUaGUgZGF0ZSB0byBzdWJzdHJhY3RcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgICAgIFRoZSBkaWZmZXJlbmNlIGFzIGEgZHVyYXRpb25cbiAgICAgKi9cbiAgICBzdWJ0cmFjdERhdGU6IGZ1bmN0aW9uIGljYWx0aW1lX3N1YnRyYWN0KGFEYXRlKSB7XG4gICAgICB2YXIgdW5peFRpbWUgPSB0aGlzLnRvVW5peFRpbWUoKSArIHRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICB2YXIgb3RoZXIgPSBhRGF0ZS50b1VuaXhUaW1lKCkgKyBhRGF0ZS51dGNPZmZzZXQoKTtcbiAgICAgIHJldHVybiBJQ0FMLkR1cmF0aW9uLmZyb21TZWNvbmRzKHVuaXhUaW1lIC0gb3RoZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdCB0aGUgZGF0ZSBkZXRhaWxzLCB0YWtpbmcgdGltZXpvbmVzIGludG8gYWNjb3VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lfSBhRGF0ZSAgVGhlIGRhdGUgdG8gc3VidHJhY3RcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgVGhlIGRpZmZlcmVuY2UgaW4gZHVyYXRpb25cbiAgICAgKi9cbiAgICBzdWJ0cmFjdERhdGVUejogZnVuY3Rpb24gaWNhbHRpbWVfc3VidHJhY3RfYWJzKGFEYXRlKSB7XG4gICAgICB2YXIgdW5peFRpbWUgPSB0aGlzLnRvVW5peFRpbWUoKTtcbiAgICAgIHZhciBvdGhlciA9IGFEYXRlLnRvVW5peFRpbWUoKTtcbiAgICAgIHJldHVybiBJQ0FMLkR1cmF0aW9uLmZyb21TZWNvbmRzKHVuaXhUaW1lIC0gb3RoZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB0aGUgSUNBTC5UaW1lIGluc3RhbmNlIHdpdGggYW5vdGhlciBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuRHVyYXRpb259IGFPdGhlciAgICAgICAgVGhlIGluc3RhbmNlIHRvIGNvbXBhcmUgd2l0aFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAtMSwgMCBvciAxIGZvciBsZXNzL2VxdWFsL2dyZWF0ZXJcbiAgICAgKi9cbiAgICBjb21wYXJlOiBmdW5jdGlvbiBpY2FsdGltZV9jb21wYXJlKG90aGVyKSB7XG4gICAgICB2YXIgYSA9IHRoaXMudG9Vbml4VGltZSgpO1xuICAgICAgdmFyIGIgPSBvdGhlci50b1VuaXhUaW1lKCk7XG5cbiAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICBpZiAoYiA+IGEpIHJldHVybiAtMTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyBvbmx5IHRoZSBkYXRlIHBhcnQgb2YgdGhpcyBpbnN0YW5jZSB3aXRoIGFub3RoZXIgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLkR1cmF0aW9ufSBvdGhlciAgICAgICAgIFRoZSBpbnN0YW5jZSB0byBjb21wYXJlIHdpdGhcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmV9IHR6ICAgICAgICAgICAgVGhlIHRpbWV6b25lIHRvIGNvbXBhcmUgaW5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgLTEsIDAgb3IgMSBmb3IgbGVzcy9lcXVhbC9ncmVhdGVyXG4gICAgICovXG4gICAgY29tcGFyZURhdGVPbmx5VHo6IGZ1bmN0aW9uIGljYWx0aW1lX2NvbXBhcmVEYXRlT25seVR6KG90aGVyLCB0eikge1xuICAgICAgZnVuY3Rpb24gY21wKGF0dHIpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVGltZS5fY21wX2F0dHIoYSwgYiwgYXR0cik7XG4gICAgICB9XG4gICAgICB2YXIgYSA9IHRoaXMuY29udmVydFRvWm9uZSh0eik7XG4gICAgICB2YXIgYiA9IG90aGVyLmNvbnZlcnRUb1pvbmUodHopO1xuICAgICAgdmFyIHJjID0gMDtcblxuICAgICAgaWYgKChyYyA9IGNtcChcInllYXJcIikpICE9IDApIHJldHVybiByYztcbiAgICAgIGlmICgocmMgPSBjbXAoXCJtb250aFwiKSkgIT0gMCkgcmV0dXJuIHJjO1xuICAgICAgaWYgKChyYyA9IGNtcChcImRheVwiKSkgIT0gMCkgcmV0dXJuIHJjO1xuXG4gICAgICByZXR1cm4gcmM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGluc3RhbmNlIGludG8gYW5vdGhlciB0aW1lem9uZS4gVGhlIHJldHVybmVkIElDQUwuVGltZVxuICAgICAqIGluc3RhbmNlIGlzIGFsd2F5cyBhIGNvcHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmV9IHpvbmUgICAgICBUaGUgem9uZSB0byBjb252ZXJ0IHRvXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgICAgICAgICAgVGhlIGNvcHksIGNvbnZlcnRlZCB0byB0aGUgem9uZVxuICAgICAqL1xuICAgIGNvbnZlcnRUb1pvbmU6IGZ1bmN0aW9uIGNvbnZlcnRUb1pvbmUoem9uZSkge1xuICAgICAgdmFyIGNvcHkgPSB0aGlzLmNsb25lKCk7XG4gICAgICB2YXIgem9uZV9lcXVhbHMgPSAodGhpcy56b25lLnR6aWQgPT0gem9uZS50emlkKTtcblxuICAgICAgaWYgKCF0aGlzLmlzRGF0ZSAmJiAhem9uZV9lcXVhbHMpIHtcbiAgICAgICAgSUNBTC5UaW1lem9uZS5jb252ZXJ0X3RpbWUoY29weSwgdGhpcy56b25lLCB6b25lKTtcbiAgICAgIH1cblxuICAgICAgY29weS56b25lID0gem9uZTtcbiAgICAgIHJldHVybiBjb3B5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBVVEMgb2Zmc2V0IG9mIHRoZSBjdXJyZW50IGRhdGUvdGltZSBpbiB0aGUgdGltZXpvbmUgaXQgaXNcbiAgICAgKiBpbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgIFVUQyBvZmZzZXQgaW4gc2Vjb25kc1xuICAgICAqL1xuICAgIHV0Y09mZnNldDogZnVuY3Rpb24gdXRjX29mZnNldCgpIHtcbiAgICAgIGlmICh0aGlzLnpvbmUgPT0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lIHx8XG4gICAgICAgICAgdGhpcy56b25lID09IElDQUwuVGltZXpvbmUudXRjVGltZXpvbmUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy56b25lLnV0Y09mZnNldCh0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBSRkMgNTU0NSBjb21wbGlhbnQgaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gaWNhbCBkYXRlL2RhdGUtdGltZVxuICAgICAqL1xuICAgIHRvSUNBTFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RyaW5nID0gdGhpcy50b1N0cmluZygpO1xuXG4gICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLmRlc2lnbi5pY2FsZW5kYXIudmFsdWVbJ2RhdGUtdGltZSddLnRvSUNBTChzdHJpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIElDQUwuZGVzaWduLmljYWxlbmRhci52YWx1ZS5kYXRlLnRvSUNBTChzdHJpbmcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZGF0ZS90aW1lLCBpbiBqQ2FsIGZvcm1cbiAgICAgKiAoaW5jbHVkaW5nIDogYW5kIC0gc2VwYXJhdG9ycykuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLnllYXIgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgIElDQUwuaGVscGVycy5wYWQyKHRoaXMubW9udGgpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICBJQ0FMLmhlbHBlcnMucGFkMih0aGlzLmRheSk7XG5cbiAgICAgIGlmICghdGhpcy5pc0RhdGUpIHtcbiAgICAgICAgICByZXN1bHQgKz0gJ1QnICsgSUNBTC5oZWxwZXJzLnBhZDIodGhpcy5ob3VyKSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgIElDQUwuaGVscGVycy5wYWQyKHRoaXMubWludXRlKSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgIElDQUwuaGVscGVycy5wYWQyKHRoaXMuc2Vjb25kKTtcblxuICAgICAgICBpZiAodGhpcy56b25lID09PSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lKSB7XG4gICAgICAgICAgcmVzdWx0ICs9ICdaJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY3VycmVudCBpbnN0YW5jZSB0byBhIEphdmFzY3JpcHQgZGF0ZVxuICAgICAqIEByZXR1cm4ge0RhdGV9XG4gICAgICovXG4gICAgdG9KU0RhdGU6IGZ1bmN0aW9uIHRvSlNEYXRlKCkge1xuICAgICAgaWYgKHRoaXMuem9uZSA9PSBJQ0FMLlRpbWV6b25lLmxvY2FsVGltZXpvbmUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMueWVhciwgdGhpcy5tb250aCAtIDEsIHRoaXMuZGF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy55ZWFyLCB0aGlzLm1vbnRoIC0gMSwgdGhpcy5kYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaG91ciwgdGhpcy5taW51dGUsIHRoaXMuc2Vjb25kLCAwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudG9Vbml4VGltZSgpICogMTAwMCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9ub3JtYWxpemU6IGZ1bmN0aW9uIGljYWx0aW1lX25vcm1hbGl6ZSgpIHtcbiAgICAgIHZhciBpc0RhdGUgPSB0aGlzLl90aW1lLmlzRGF0ZTtcbiAgICAgIGlmICh0aGlzLl90aW1lLmlzRGF0ZSkge1xuICAgICAgICB0aGlzLl90aW1lLmhvdXIgPSAwO1xuICAgICAgICB0aGlzLl90aW1lLm1pbnV0ZSA9IDA7XG4gICAgICAgIHRoaXMuX3RpbWUuc2Vjb25kID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRqdXN0KDAsIDAsIDAsIDApO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0IHRoZSBkYXRlL3RpbWUgYnkgdGhlIGdpdmVuIG9mZnNldFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFFeHRyYURheXMgICAgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBkYXlzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFFeHRyYUhvdXJzICAgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBob3Vyc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRXh0cmFNaW51dGVzICAgIFRoZSBleHRyYSBhbW91bnQgb2YgbWludXRlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRXh0cmFTZWNvbmRzICAgIFRoZSBleHRyYSBhbW91bnQgb2Ygc2Vjb25kc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYVRpbWUgICAgICAgICAgIFRoZSB0aW1lIHRvIGFkanVzdCwgZGVmYXVsdHMgdG8gdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50IGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFkanVzdDogZnVuY3Rpb24gaWNhbHRpbWVfYWRqdXN0KGFFeHRyYURheXMsIGFFeHRyYUhvdXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFFeHRyYU1pbnV0ZXMsIGFFeHRyYVNlY29uZHMsIGFUaW1lKSB7XG5cbiAgICAgIHZhciBtaW51dGVzT3ZlcmZsb3csIGhvdXJzT3ZlcmZsb3csXG4gICAgICAgICAgZGF5c092ZXJmbG93ID0gMCwgeWVhcnNPdmVyZmxvdyA9IDA7XG5cbiAgICAgIHZhciBzZWNvbmQsIG1pbnV0ZSwgaG91ciwgZGF5O1xuICAgICAgdmFyIGRheXNJbk1vbnRoO1xuXG4gICAgICB2YXIgdGltZSA9IGFUaW1lIHx8IHRoaXMuX3RpbWU7XG5cbiAgICAgIGlmICghdGltZS5pc0RhdGUpIHtcbiAgICAgICAgc2Vjb25kID0gdGltZS5zZWNvbmQgKyBhRXh0cmFTZWNvbmRzO1xuICAgICAgICB0aW1lLnNlY29uZCA9IHNlY29uZCAlIDYwO1xuICAgICAgICBtaW51dGVzT3ZlcmZsb3cgPSBJQ0FMLmhlbHBlcnMudHJ1bmMoc2Vjb25kIC8gNjApO1xuICAgICAgICBpZiAodGltZS5zZWNvbmQgPCAwKSB7XG4gICAgICAgICAgdGltZS5zZWNvbmQgKz0gNjA7XG4gICAgICAgICAgbWludXRlc092ZXJmbG93LS07XG4gICAgICAgIH1cblxuICAgICAgICBtaW51dGUgPSB0aW1lLm1pbnV0ZSArIGFFeHRyYU1pbnV0ZXMgKyBtaW51dGVzT3ZlcmZsb3c7XG4gICAgICAgIHRpbWUubWludXRlID0gbWludXRlICUgNjA7XG4gICAgICAgIGhvdXJzT3ZlcmZsb3cgPSBJQ0FMLmhlbHBlcnMudHJ1bmMobWludXRlIC8gNjApO1xuICAgICAgICBpZiAodGltZS5taW51dGUgPCAwKSB7XG4gICAgICAgICAgdGltZS5taW51dGUgKz0gNjA7XG4gICAgICAgICAgaG91cnNPdmVyZmxvdy0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaG91ciA9IHRpbWUuaG91ciArIGFFeHRyYUhvdXJzICsgaG91cnNPdmVyZmxvdztcblxuICAgICAgICB0aW1lLmhvdXIgPSBob3VyICUgMjQ7XG4gICAgICAgIGRheXNPdmVyZmxvdyA9IElDQUwuaGVscGVycy50cnVuYyhob3VyIC8gMjQpO1xuICAgICAgICBpZiAodGltZS5ob3VyIDwgMCkge1xuICAgICAgICAgIHRpbWUuaG91ciArPSAyNDtcbiAgICAgICAgICBkYXlzT3ZlcmZsb3ctLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICAgIC8vIEFkanVzdCBtb250aCBhbmQgeWVhciBmaXJzdCwgYmVjYXVzZSB3ZSBuZWVkIHRvIGtub3cgd2hhdCBtb250aCB0aGUgZGF5XG4gICAgICAvLyBpcyBpbiBiZWZvcmUgYWRqdXN0aW5nIGl0LlxuICAgICAgaWYgKHRpbWUubW9udGggPiAxMikge1xuICAgICAgICB5ZWFyc092ZXJmbG93ID0gSUNBTC5oZWxwZXJzLnRydW5jKCh0aW1lLm1vbnRoIC0gMSkgLyAxMik7XG4gICAgICB9IGVsc2UgaWYgKHRpbWUubW9udGggPCAxKSB7XG4gICAgICAgIHllYXJzT3ZlcmZsb3cgPSBJQ0FMLmhlbHBlcnMudHJ1bmModGltZS5tb250aCAvIDEyKSAtIDE7XG4gICAgICB9XG5cbiAgICAgIHRpbWUueWVhciArPSB5ZWFyc092ZXJmbG93O1xuICAgICAgdGltZS5tb250aCAtPSAxMiAqIHllYXJzT3ZlcmZsb3c7XG5cbiAgICAgIC8vIE5vdyB0YWtlIGNhcmUgb2YgdGhlIGRheXMgKGFuZCBhZGp1c3QgbW9udGggaWYgbmVlZGVkKVxuICAgICAgZGF5ID0gdGltZS5kYXkgKyBhRXh0cmFEYXlzICsgZGF5c092ZXJmbG93O1xuXG4gICAgICBpZiAoZGF5ID4gMCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodGltZS5tb250aCwgdGltZS55ZWFyKTtcbiAgICAgICAgICBpZiAoZGF5IDw9IGRheXNJbk1vbnRoKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aW1lLm1vbnRoKys7XG4gICAgICAgICAgaWYgKHRpbWUubW9udGggPiAxMikge1xuICAgICAgICAgICAgdGltZS55ZWFyKys7XG4gICAgICAgICAgICB0aW1lLm1vbnRoID0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXkgLT0gZGF5c0luTW9udGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChkYXkgPD0gMCkge1xuICAgICAgICAgIGlmICh0aW1lLm1vbnRoID09IDEpIHtcbiAgICAgICAgICAgIHRpbWUueWVhci0tO1xuICAgICAgICAgICAgdGltZS5tb250aCA9IDEyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aW1lLm1vbnRoLS07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF5ICs9IElDQUwuVGltZS5kYXlzSW5Nb250aCh0aW1lLm1vbnRoLCB0aW1lLnllYXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRpbWUuZGF5ID0gZGF5O1xuXG4gICAgICB0aGlzLl9jYWNoZWRVbml4VGltZSA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSBmcm9tIHVuaXggdGltZSwgdGhlIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlXG4gICAgICogSmFudWFyeSAxc3QsIDE5NzAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kcyAgICAgIFRoZSBzZWNvbmRzIHRvIHNldCB1cCB3aXRoXG4gICAgICovXG4gICAgZnJvbVVuaXhUaW1lOiBmdW5jdGlvbiBmcm9tVW5peFRpbWUoc2Vjb25kcykge1xuICAgICAgdGhpcy56b25lID0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZTtcbiAgICAgIHZhciBlcG9jaCA9IElDQUwuVGltZS5lcG9jaFRpbWUuY2xvbmUoKTtcbiAgICAgIGVwb2NoLmFkanVzdCgwLCAwLCAwLCBzZWNvbmRzKTtcblxuICAgICAgdGhpcy55ZWFyID0gZXBvY2gueWVhcjtcbiAgICAgIHRoaXMubW9udGggPSBlcG9jaC5tb250aDtcbiAgICAgIHRoaXMuZGF5ID0gZXBvY2guZGF5O1xuICAgICAgdGhpcy5ob3VyID0gZXBvY2guaG91cjtcbiAgICAgIHRoaXMubWludXRlID0gZXBvY2gubWludXRlO1xuICAgICAgdGhpcy5zZWNvbmQgPSBNYXRoLmZsb29yKGVwb2NoLnNlY29uZCk7XG5cbiAgICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGN1cnJlbnQgaW5zdGFuY2UgdG8gc2Vjb25kcyBzaW5jZSBKYW51YXJ5IDFzdCAxOTcwLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgIFNlY29uZHMgc2luY2UgMTk3MFxuICAgICAqL1xuICAgIHRvVW5peFRpbWU6IGZ1bmN0aW9uIHRvVW5peFRpbWUoKSB7XG4gICAgICBpZiAodGhpcy5fY2FjaGVkVW5peFRpbWUgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFVuaXhUaW1lO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XG5cbiAgICAgIC8vIHdlIHVzZSB0aGUgb2Zmc2V0IHRyaWNrIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB3ZSBhcmUgZ2V0dGluZyB0aGUgYWN0dWFsIFVUQyB0aW1lXG4gICAgICB2YXIgbXMgPSBEYXRlLlVUQyhcbiAgICAgICAgdGhpcy55ZWFyLFxuICAgICAgICB0aGlzLm1vbnRoIC0gMSxcbiAgICAgICAgdGhpcy5kYXksXG4gICAgICAgIHRoaXMuaG91cixcbiAgICAgICAgdGhpcy5taW51dGUsXG4gICAgICAgIHRoaXMuc2Vjb25kIC0gb2Zmc2V0XG4gICAgICApO1xuXG4gICAgICAvLyBzZWNvbmRzXG4gICAgICB0aGlzLl9jYWNoZWRVbml4VGltZSA9IG1zIC8gMTAwMDtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRVbml4VGltZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGltZSB0byBpbnRvIE9iamVjdCB3aGljaCBjYW4gYmUgc2VyaWFsaXplZCB0aGVuIHJlLWNyZWF0ZWRcbiAgICAgKiB1c2luZyB0aGUgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHRvSlNPTiB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgY2FsbGVkXG4gICAgICogdmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeShteXRpbWUpO1xuICAgICAqXG4gICAgICogdmFyIGRlc2VyaWFsaXplZCA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICpcbiAgICAgKiB2YXIgdGltZSA9IG5ldyBJQ0FMLlRpbWUoZGVzZXJpYWxpemVkKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvcHkgPSBbXG4gICAgICAgICd5ZWFyJyxcbiAgICAgICAgJ21vbnRoJyxcbiAgICAgICAgJ2RheScsXG4gICAgICAgICdob3VyJyxcbiAgICAgICAgJ21pbnV0ZScsXG4gICAgICAgICdzZWNvbmQnLFxuICAgICAgICAnaXNEYXRlJ1xuICAgICAgXTtcblxuICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSBjb3B5Lmxlbmd0aDtcbiAgICAgIHZhciBwcm9wO1xuXG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHByb3AgPSBjb3B5W2ldO1xuICAgICAgICByZXN1bHRbcHJvcF0gPSB0aGlzW3Byb3BdO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy56b25lKSB7XG4gICAgICAgIHJlc3VsdC50aW1lem9uZSA9IHRoaXMuem9uZS50emlkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICB9O1xuXG4gIChmdW5jdGlvbiBzZXR1cE5vcm1hbGl6ZUF0dHJpYnV0ZXMoKSB7XG4gICAgLy8gVGhpcyBuZWVkcyB0byBydW4gYmVmb3JlIGFueSBpbnN0YW5jZXMgYXJlIGNyZWF0ZWQhXG4gICAgZnVuY3Rpb24gZGVmaW5lQXR0cihhdHRyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSUNBTC5UaW1lLnByb3RvdHlwZSwgYXR0ciwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldFRpbWVBdHRyKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nTm9ybWFsaXphdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fbm9ybWFsaXplKCk7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nTm9ybWFsaXphdGlvbiA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lW2F0dHJdO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldFRpbWVBdHRyKHZhbCkge1xuICAgICAgICAgIC8vIENoZWNrIGlmIGlzRGF0ZSB3aWxsIGJlIHNldCBhbmQgaWYgd2FzIG5vdCBzZXQgdG8gbm9ybWFsaXplIGRhdGUuXG4gICAgICAgICAgLy8gVGhpcyBhdm9pZHMgbG9zaW5nIGRheXMgd2hlbiBzZWNvbmRzLCBtaW51dGVzIGFuZCBob3VycyBhcmUgemVyb2VkXG4gICAgICAgICAgLy8gd2hhdCBub3JtYWxpemUgd2lsbCBkbyB3aGVuIHRpbWUgaXMgYSBkYXRlLlxuICAgICAgICAgIGlmIChhdHRyID09PSBcImlzRGF0ZVwiICYmIHZhbCAmJiAhdGhpcy5fdGltZS5pc0RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0KDAsIDAsIDAsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jYWNoZWRVbml4VGltZSA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fcGVuZGluZ05vcm1hbGl6YXRpb24gPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX3RpbWVbYXR0cl0gPSB2YWw7XG5cbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKFwiZGVmaW5lUHJvcGVydHlcIiBpbiBPYmplY3QpIHtcbiAgICAgIGRlZmluZUF0dHIoXCJ5ZWFyXCIpO1xuICAgICAgZGVmaW5lQXR0cihcIm1vbnRoXCIpO1xuICAgICAgZGVmaW5lQXR0cihcImRheVwiKTtcbiAgICAgIGRlZmluZUF0dHIoXCJob3VyXCIpO1xuICAgICAgZGVmaW5lQXR0cihcIm1pbnV0ZVwiKTtcbiAgICAgIGRlZmluZUF0dHIoXCJzZWNvbmRcIik7XG4gICAgICBkZWZpbmVBdHRyKFwiaXNEYXRlXCIpO1xuICAgIH1cbiAgfSkoKTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF5cyBpbiB0aGUgZ2l2ZW4gbW9udGhcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1vbnRoICAgICAgVGhlIG1vbnRoIHRvIGNoZWNrXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyICAgICAgIFRoZSB5ZWFyIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgIFRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGUgbW9udGhcbiAgICovXG4gIElDQUwuVGltZS5kYXlzSW5Nb250aCA9IGZ1bmN0aW9uIGljYWx0aW1lX2RheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKSB7XG4gICAgdmFyIF9kYXlzSW5Nb250aCA9IFswLCAzMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTtcbiAgICB2YXIgZGF5cyA9IDMwO1xuXG4gICAgaWYgKG1vbnRoIDwgMSB8fCBtb250aCA+IDEyKSByZXR1cm4gZGF5cztcblxuICAgIGRheXMgPSBfZGF5c0luTW9udGhbbW9udGhdO1xuXG4gICAgaWYgKG1vbnRoID09IDIpIHtcbiAgICAgIGRheXMgKz0gSUNBTC5UaW1lLmlzTGVhcFllYXIoeWVhcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRheXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgeWVhciBpcyBhIGxlYXAgeWVhclxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0geWVhciAgICAgICBUaGUgeWVhciB0byBjaGVja1xuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICBUcnVlLCBpZiB0aGUgeWVhciBpcyBhIGxlYXAgeWVhclxuICAgKi9cbiAgSUNBTC5UaW1lLmlzTGVhcFllYXIgPSBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICBpZiAoeWVhciA8PSAxNzUyKSB7XG4gICAgICByZXR1cm4gKCh5ZWFyICUgNCkgPT0gMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoKCh5ZWFyICUgNCA9PSAwKSAmJiAoeWVhciAlIDEwMCAhPSAwKSkgfHwgKHllYXIgJSA0MDAgPT0gMCkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IElDQUwuVGltZSBmcm9tIHRoZSBkYXkgb2YgeWVhciBhbmQgeWVhci4gVGhlIGRhdGUgaXMgcmV0dXJuZWRcbiAgICogaW4gZmxvYXRpbmcgdGltZXpvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF5T2ZZZWFyICAgICBUaGUgZGF5IG9mIHllYXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFZZWFyICAgICAgICAgIFRoZSB5ZWFyIHRvIGNyZWF0ZSB0aGUgaW5zdGFuY2UgaW5cbiAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgICAgICAgIFRoZSBjcmVhdGVkIGluc3RhbmNlIHdpdGggdGhlIGNhbGN1bGF0ZWQgZGF0ZVxuICAgKi9cbiAgSUNBTC5UaW1lLmZyb21EYXlPZlllYXIgPSBmdW5jdGlvbiBpY2FsdGltZV9mcm9tRGF5T2ZZZWFyKGFEYXlPZlllYXIsIGFZZWFyKSB7XG4gICAgdmFyIHllYXIgPSBhWWVhcjtcbiAgICB2YXIgZG95ID0gYURheU9mWWVhcjtcbiAgICB2YXIgdHQgPSBuZXcgSUNBTC5UaW1lKCk7XG4gICAgdHQuYXV0b19ub3JtYWxpemUgPSBmYWxzZTtcbiAgICB2YXIgaXNfbGVhcCA9IChJQ0FMLlRpbWUuaXNMZWFwWWVhcih5ZWFyKSA/IDEgOiAwKTtcblxuICAgIGlmIChkb3kgPCAxKSB7XG4gICAgICB5ZWFyLS07XG4gICAgICBpc19sZWFwID0gKElDQUwuVGltZS5pc0xlYXBZZWFyKHllYXIpID8gMSA6IDApO1xuICAgICAgZG95ICs9IElDQUwuVGltZS5kYXlzSW5ZZWFyUGFzc2VkTW9udGhbaXNfbGVhcF1bMTJdO1xuICAgICAgcmV0dXJuIElDQUwuVGltZS5mcm9tRGF5T2ZZZWFyKGRveSwgeWVhcik7XG4gICAgfSBlbHNlIGlmIChkb3kgPiBJQ0FMLlRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoW2lzX2xlYXBdWzEyXSkge1xuICAgICAgaXNfbGVhcCA9IChJQ0FMLlRpbWUuaXNMZWFwWWVhcih5ZWFyKSA/IDEgOiAwKTtcbiAgICAgIGRveSAtPSBJQ0FMLlRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoW2lzX2xlYXBdWzEyXTtcbiAgICAgIHllYXIrKztcbiAgICAgIHJldHVybiBJQ0FMLlRpbWUuZnJvbURheU9mWWVhcihkb3ksIHllYXIpO1xuICAgIH1cblxuICAgIHR0LnllYXIgPSB5ZWFyO1xuICAgIHR0LmlzRGF0ZSA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBtb250aCA9IDExOyBtb250aCA+PSAwOyBtb250aC0tKSB7XG4gICAgICBpZiAoZG95ID4gSUNBTC5UaW1lLmRheXNJblllYXJQYXNzZWRNb250aFtpc19sZWFwXVttb250aF0pIHtcbiAgICAgICAgdHQubW9udGggPSBtb250aCArIDE7XG4gICAgICAgIHR0LmRheSA9IGRveSAtIElDQUwuVGltZS5kYXlzSW5ZZWFyUGFzc2VkTW9udGhbaXNfbGVhcF1bbW9udGhdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0dC5hdXRvX25vcm1hbGl6ZSA9IHRydWU7XG4gICAgcmV0dXJuIHR0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZSBmcm9tIGEgZGF0ZSBzdHJpbmcsIGUuZyAyMDE1LTAxLTAyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCAgICAgICAgICAgICAgICBVc2Uge0BsaW5rIElDQUwuVGltZS5mcm9tRGF0ZVN0cmluZ30gaW5zdGVhZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyICAgICAgICBUaGUgc3RyaW5nIHRvIGNyZWF0ZSBmcm9tXG4gICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICAgIFRoZSBkYXRlL3RpbWUgaW5zdGFuY2VcbiAgICovXG4gIElDQUwuVGltZS5mcm9tU3RyaW5ndjIgPSBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0cikge1xuICAgIHJldHVybiBuZXcgSUNBTC5UaW1lKHtcbiAgICAgIHllYXI6IHBhcnNlSW50KHN0ci5zdWJzdHIoMCwgNCksIDEwKSxcbiAgICAgIG1vbnRoOiBwYXJzZUludChzdHIuc3Vic3RyKDUsIDIpLCAxMCksXG4gICAgICBkYXk6IHBhcnNlSW50KHN0ci5zdWJzdHIoOCwgMiksIDEwKSxcbiAgICAgIGlzRGF0ZTogdHJ1ZVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZSBmcm9tIGEgZGF0ZSBzdHJpbmcsIGUuZyAyMDE1LTAxLTAyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVZhbHVlICAgICBUaGUgc3RyaW5nIHRvIGNyZWF0ZSBmcm9tXG4gICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICAgIFRoZSBkYXRlL3RpbWUgaW5zdGFuY2VcbiAgICovXG4gIElDQUwuVGltZS5mcm9tRGF0ZVN0cmluZyA9IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgIC8vIERhdGVzIHNob3VsZCBoYXZlIG5vIHRpbWV6b25lLlxuICAgIC8vIEdvb2dsZSBsaWtlcyB0byBzb21ldGltZXMgc3BlY2lmeSBaIG9uIGRhdGVzXG4gICAgLy8gd2Ugc3BlY2lmaWNhbGx5IGlnbm9yZSB0aGF0IHRvIGF2b2lkIGlzc3Vlcy5cblxuICAgIC8vIFlZWVktTU0tRERcbiAgICAvLyAyMDEyLTEwLTEwXG4gICAgcmV0dXJuIG5ldyBJQ0FMLlRpbWUoe1xuICAgICAgeWVhcjogSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KGFWYWx1ZS5zdWJzdHIoMCwgNCkpLFxuICAgICAgbW9udGg6IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChhVmFsdWUuc3Vic3RyKDUsIDIpKSxcbiAgICAgIGRheTogSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KGFWYWx1ZS5zdWJzdHIoOCwgMikpLFxuICAgICAgaXNEYXRlOiB0cnVlXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gYSBkYXRlLXRpbWUgc3RyaW5nLCBlLmdcbiAgICogMjAxNS0wMS0wMlQwMzowNDowNS4gSWYgYSBwcm9wZXJ0eSBpcyBzcGVjaWZpZWQsIHRoZSB0aW1lem9uZSBpcyBzZXQgdXBcbiAgICogZnJvbSB0aGUgcHJvcGVydHkncyBUWklEIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFWYWx1ZSAgICAgICAgIFRoZSBzdHJpbmcgdG8gY3JlYXRlIGZyb21cbiAgICogQHBhcmFtIHtJQ0FMLlByb3BlcnR5PX0gcHJvcCAgIFRoZSBwcm9wZXJ0eSB0aGUgZGF0ZSBiZWxvbmdzIHRvXG4gICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICAgICAgICBUaGUgZGF0ZS90aW1lIGluc3RhbmNlXG4gICAqL1xuICBJQ0FMLlRpbWUuZnJvbURhdGVUaW1lU3RyaW5nID0gZnVuY3Rpb24oYVZhbHVlLCBwcm9wKSB7XG4gICAgaWYgKGFWYWx1ZS5sZW5ndGggPCAxOSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnaW52YWxpZCBkYXRlLXRpbWUgdmFsdWU6IFwiJyArIGFWYWx1ZSArICdcIidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHpvbmU7XG5cbiAgICBpZiAoYVZhbHVlWzE5XSAmJiBhVmFsdWVbMTldID09PSAnWicpIHtcbiAgICAgIHpvbmUgPSAnWic7XG4gICAgfSBlbHNlIGlmIChwcm9wKSB7XG4gICAgICB6b25lID0gcHJvcC5nZXRQYXJhbWV0ZXIoJ3R6aWQnKTtcbiAgICB9XG5cbiAgICAvLyAyMDEyLTEwLTEwVDEwOjEwOjEwKFopP1xuICAgIHZhciB0aW1lID0gbmV3IElDQUwuVGltZSh7XG4gICAgICB5ZWFyOiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cigwLCA0KSksXG4gICAgICBtb250aDogSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KGFWYWx1ZS5zdWJzdHIoNSwgMikpLFxuICAgICAgZGF5OiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cig4LCAyKSksXG4gICAgICBob3VyOiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cigxMSwgMikpLFxuICAgICAgbWludXRlOiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cigxNCwgMikpLFxuICAgICAgc2Vjb25kOiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cigxNywgMikpLFxuICAgICAgdGltZXpvbmU6IHpvbmVcbiAgICB9KTtcblxuICAgIHJldHVybiB0aW1lO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZSBmcm9tIGEgZGF0ZSBvciBkYXRlLXRpbWUgc3RyaW5nLFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVZhbHVlICAgICAgICAgVGhlIHN0cmluZyB0byBjcmVhdGUgZnJvbVxuICAgKiBAcGFyYW0ge0lDQUwuUHJvcGVydHk9fSBwcm9wICAgVGhlIHByb3BlcnR5IHRoZSBkYXRlIGJlbG9uZ3MgdG9cbiAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgICAgICAgIFRoZSBkYXRlL3RpbWUgaW5zdGFuY2VcbiAgICovXG4gIElDQUwuVGltZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gZnJvbVN0cmluZyhhVmFsdWUsIGFQcm9wZXJ0eSkge1xuICAgIGlmIChhVmFsdWUubGVuZ3RoID4gMTApIHtcbiAgICAgIHJldHVybiBJQ0FMLlRpbWUuZnJvbURhdGVUaW1lU3RyaW5nKGFWYWx1ZSwgYVByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIElDQUwuVGltZS5mcm9tRGF0ZVN0cmluZyhhVmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBJQ0FMLlRpbWUgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gSmF2YXNjcmlwdCBEYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gez9EYXRlfSBhRGF0ZSAgICAgVGhlIEphdmFzY3JpcHQgRGF0ZSB0byByZWFkLCBvciBudWxsIHRvIHJlc2V0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlVVRDICBJZiB0cnVlLCB0aGUgVVRDIHZhbHVlcyBvZiB0aGUgZGF0ZSB3aWxsIGJlIHVzZWRcbiAgICovXG4gIElDQUwuVGltZS5mcm9tSlNEYXRlID0gZnVuY3Rpb24gZnJvbUpTRGF0ZShhRGF0ZSwgdXNlVVRDKSB7XG4gICAgdmFyIHR0ID0gbmV3IElDQUwuVGltZSgpO1xuICAgIHJldHVybiB0dC5mcm9tSlNEYXRlKGFEYXRlLCB1c2VVVEMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZSBmcm9tIHRoZSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYURhdGEgICAgICAgICAgICBUaW1lIGluaXRpYWxpemF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEueWVhciAgICAgIFRoZSB5ZWFyIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5tb250aCAgICAgVGhlIG1vbnRoIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5kYXkgICAgICAgVGhlIGRheSBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuaG91ciAgICAgIFRoZSBob3VyIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5taW51dGUgICAgVGhlIG1pbnV0ZSBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuc2Vjb25kICAgIFRoZSBzZWNvbmQgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBhRGF0YS5pc0RhdGUgICBJZiB0cnVlLCB0aGUgaW5zdGFuY2UgcmVwcmVzZW50cyBhIGRhdGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYXMgb3Bwb3NlZCB0byBhIGRhdGUtdGltZSlcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWV6b25lPX0gYVpvbmUgICAgVGltZXpvbmUgdGhpcyBwb3NpdGlvbiBvY2N1cnMgaW5cbiAgICovXG4gIElDQUwuVGltZS5mcm9tRGF0YSA9IGZ1bmN0aW9uIGZyb21EYXRhKGFEYXRhLCBhWm9uZSkge1xuICAgIHZhciB0ID0gbmV3IElDQUwuVGltZSgpO1xuICAgIHJldHVybiB0LmZyb21EYXRhKGFEYXRhLCBhWm9uZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gdGhlIGN1cnJlbnQgbW9tZW50LlxuICAgKiBUaGUgaW5zdGFuY2UgaXMg4oCcZmxvYXRpbmfigJ0gLSBoYXMgbm8gdGltZXpvbmUgcmVsYXRpb24uXG4gICAqIFRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBjb25zaWRlcmluZyB0aGUgdGltZSB6b25lLCBjYWxsXG4gICAqIElDQUwuVGltZS5mcm9tSlNEYXRlKG5ldyBEYXRlKCksIHRydWUpXG4gICAqIEByZXR1cm4ge0lDQUwuVGltZX1cbiAgICovXG4gIElDQUwuVGltZS5ub3cgPSBmdW5jdGlvbiBpY2FsdGltZV9ub3coKSB7XG4gICAgcmV0dXJuIElDQUwuVGltZS5mcm9tSlNEYXRlKG5ldyBEYXRlKCksIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF0ZSBvbiB3aGljaCBJU08gd2VlayBudW1iZXIgMSBzdGFydHMuXG4gICAqXG4gICAqIEBzZWUgSUNBTC5UaW1lI3dlZWtOdW1iZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFZZWFyICAgICAgICAgICAgICAgICAgVGhlIHllYXIgdG8gc2VhcmNoIGluXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lLndlZWtEYXk9fSBhV2Vla1N0YXJ0IFRoZSB3ZWVrIHN0YXJ0IHdlZWtkYXksIHVzZWQgZm9yIGNhbGN1bGF0aW9uLlxuICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgICAgICAgICAgICBUaGUgZGF0ZSBvbiB3aGljaCB3ZWVrIG51bWJlciAxIHN0YXJ0c1xuICAgKi9cbiAgSUNBTC5UaW1lLndlZWtPbmVTdGFydHMgPSBmdW5jdGlvbiB3ZWVrT25lU3RhcnRzKGFZZWFyLCBhV2Vla1N0YXJ0KSB7XG4gICAgdmFyIHQgPSBJQ0FMLlRpbWUuZnJvbURhdGEoe1xuICAgICAgeWVhcjogYVllYXIsXG4gICAgICBtb250aDogMSxcbiAgICAgIGRheTogMSxcbiAgICAgIGlzRGF0ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdmFyIGRvdyA9IHQuZGF5T2ZXZWVrKCk7XG4gICAgdmFyIHdrc3QgPSBhV2Vla1N0YXJ0IHx8IElDQUwuVGltZS5ERUZBVUxUX1dFRUtfU1RBUlQ7XG4gICAgaWYgKGRvdyA+IElDQUwuVGltZS5USFVSU0RBWSkge1xuICAgICAgdC5kYXkgKz0gNztcbiAgICB9XG4gICAgaWYgKHdrc3QgPiBJQ0FMLlRpbWUuVEhVUlNEQVkpIHtcbiAgICAgIHQuZGF5IC09IDc7XG4gICAgfVxuXG4gICAgdC5kYXkgLT0gZG93IC0gd2tzdDtcblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRvbWluaWNhbCBsZXR0ZXIgZm9yIHRoZSBnaXZlbiB5ZWFyLiBMZXR0ZXJzIHJhbmdlIGZyb20gQSAtIEcgZm9yXG4gICAqIGNvbW1vbiB5ZWFycywgYW5kIEFHIHRvIEdGIGZvciBsZWFwIHllYXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0geXIgICAgICAgICAgIFRoZSB5ZWFyIHRvIHJldHJpZXZlIHRoZSBsZXR0ZXIgZm9yXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgVGhlIGRvbWluaWNhbCBsZXR0ZXIuXG4gICAqL1xuICBJQ0FMLlRpbWUuZ2V0RG9taW5pY2FsTGV0dGVyID0gZnVuY3Rpb24oeXIpIHtcbiAgICB2YXIgTFRSUyA9IFwiR0ZFRENCQVwiO1xuICAgIHZhciBkb20gPSAoeXIgKyAoeXIgLyA0IHwgMCkgKyAoeXIgLyA0MDAgfCAwKSAtICh5ciAvIDEwMCB8IDApIC0gMSkgJSA3O1xuICAgIHZhciBpc0xlYXAgPSBJQ0FMLlRpbWUuaXNMZWFwWWVhcih5cik7XG4gICAgaWYgKGlzTGVhcCkge1xuICAgICAgcmV0dXJuIExUUlNbKGRvbSArIDYpICUgN10gKyBMVFJTW2RvbV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBMVFJTW2RvbV07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBKYW51YXJ5IDFzdCwgMTk3MCBhcyBhbiBJQ0FMLlRpbWUuXG4gICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAqIEBjb25zdGFudFxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIElDQUwuVGltZS5lcG9jaFRpbWUgPSBJQ0FMLlRpbWUuZnJvbURhdGEoe1xuICAgIHllYXI6IDE5NzAsXG4gICAgbW9udGg6IDEsXG4gICAgZGF5OiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBpc0RhdGU6IGZhbHNlLFxuICAgIHRpbWV6b25lOiBcIlpcIlxuICB9KTtcblxuICBJQ0FMLlRpbWUuX2NtcF9hdHRyID0gZnVuY3Rpb24gX2NtcF9hdHRyKGEsIGIsIGF0dHIpIHtcbiAgICBpZiAoYVthdHRyXSA+IGJbYXR0cl0pIHJldHVybiAxO1xuICAgIGlmIChhW2F0dHJdIDwgYlthdHRyXSkgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgZGF5cyB0aGF0IGhhdmUgcGFzc2VkIGluIHRoZSB5ZWFyIGFmdGVyIGEgZ2l2ZW4gbW9udGguIFRoZSBhcnJheSBoYXNcbiAgICogdHdvIG1lbWJlcnMsIG9uZSBiZWluZyBhbiBhcnJheSBvZiBwYXNzZWQgZGF5cyBmb3Igbm9uLWxlYXAgeWVhcnMsIHRoZVxuICAgKiBvdGhlciBhbmFsb2cgZm9yIGxlYXAgeWVhcnMuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBpc0xlYXBZZWFyID0gSUNBTC5UaW1lLmlzTGVhcFllYXIoeWVhcik7XG4gICAqIHZhciBwYXNzZWREYXlzID0gSUNBTC5UaW1lLmRheXNJblllYXJQYXNzZWRNb250aFtpc0xlYXBZZWFyXVttb250aF07XG4gICAqIEB0eXBlIHtBcnJheS48QXJyYXkuPE51bWJlcj4+fVxuICAgKi9cbiAgSUNBTC5UaW1lLmRheXNJblllYXJQYXNzZWRNb250aCA9IFtcbiAgICBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzQsIDM2NV0sXG4gICAgWzAsIDMxLCA2MCwgOTEsIDEyMSwgMTUyLCAxODIsIDIxMywgMjQ0LCAyNzQsIDMwNSwgMzM1LCAzNjZdXG4gIF07XG5cbiAgLyoqXG4gICAqIFRoZSB3ZWVrZGF5LCAxID0gU1VOREFZLCA3ID0gU0FUVVJEQVkuIEFjY2VzcyB2aWFcbiAgICogSUNBTC5UaW1lLk1PTkRBWSwgSUNBTC5UaW1lLlRVRVNEQVksIC4uLlxuICAgKlxuICAgKiBAdHlwZWRlZiB7TnVtYmVyfSB3ZWVrRGF5XG4gICAqIEBtZW1iZXJvZiBJQ0FMLlRpbWVcbiAgICovXG5cbiAgSUNBTC5UaW1lLlNVTkRBWSA9IDE7XG4gIElDQUwuVGltZS5NT05EQVkgPSAyO1xuICBJQ0FMLlRpbWUuVFVFU0RBWSA9IDM7XG4gIElDQUwuVGltZS5XRURORVNEQVkgPSA0O1xuICBJQ0FMLlRpbWUuVEhVUlNEQVkgPSA1O1xuICBJQ0FMLlRpbWUuRlJJREFZID0gNjtcbiAgSUNBTC5UaW1lLlNBVFVSREFZID0gNztcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgd2Vla2RheSBmb3IgdGhlIFdLU1QgcGFydC5cbiAgICogQGNvbnN0YW50XG4gICAqIEBkZWZhdWx0IElDQUwuVGltZS5NT05EQVlcbiAgICovXG4gIElDQUwuVGltZS5ERUZBVUxUX1dFRUtfU1RBUlQgPSBJQ0FMLlRpbWUuTU9OREFZO1xufSkoKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxNSAqL1xuXG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBEZXNjcmliZXMgYSB2Q2FyZCB0aW1lLCB3aGljaCBoYXMgc2xpZ2h0IGRpZmZlcmVuY2VzIHRvIHRoZSBJQ0FMLlRpbWUuXG4gICAqIFByb3BlcnRpZXMgY2FuIGJlIG51bGwgaWYgbm90IHNwZWNpZmllZCwgZm9yIGV4YW1wbGUgZm9yIGRhdGVzIHdpdGhcbiAgICogcmVkdWNlZCBhY2N1cmFjeSBvciB0cnVuY2F0aW9uLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgY3VycmVudGx5IG5vdCBhbGwgbWV0aG9kcyBhcmUgY29ycmVjdGx5IHJlLWltcGxlbWVudGVkIGZvclxuICAgKiBWQ2FyZFRpbWUuIEZvciBleGFtcGxlLCBjb21wYXJpc29uIHdpbGwgaGF2ZSB1bmRlZmluZWQgcmVzdWx0cyB3aGVuIHNvbWVcbiAgICogbWVtYmVycyBhcmUgbnVsbC5cbiAgICpcbiAgICogQWxzbywgbm9ybWFsaXphdGlvbiBpcyBub3QgeWV0IGltcGxlbWVudGVkIGZvciB0aGlzIGNsYXNzIVxuICAgKlxuICAgKiBAYWxpYXMgSUNBTC5WQ2FyZFRpbWVcbiAgICogQGNsYXNzXG4gICAqIEBleHRlbmRzIHtJQ0FMLlRpbWV9XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGRhdGEgZm9yIHRoZSB0aW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS55ZWFyICAgICAgICAgICAgICAgICAgICAgVGhlIHllYXIgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEubW9udGggICAgICAgICAgICAgICAgICAgIFRoZSBtb250aCBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5kYXkgICAgICAgICAgICAgICAgICAgICAgVGhlIGRheSBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5ob3VyICAgICAgICAgICAgICAgICAgICAgVGhlIGhvdXIgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEubWludXRlICAgICAgICAgICAgICAgICAgIFRoZSBtaW51dGUgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEuc2Vjb25kICAgICAgICAgICAgICAgICAgIFRoZSBzZWNvbmQgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmV8SUNBTC5VdGNPZmZzZXR9IHpvbmUgICAgIFRoZSB0aW1lem9uZSB0byB1c2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IGljYWx0eXBlICAgICAgICAgICAgICAgICAgICAgICBUaGUgdHlwZSBmb3IgdGhpcyBkYXRlL3RpbWUgb2JqZWN0XG4gICAqL1xuICBJQ0FMLlZDYXJkVGltZSA9IGZ1bmN0aW9uKGRhdGEsIHpvbmUsIGljYWx0eXBlKSB7XG4gICAgdGhpcy53cmFwcGVkSlNPYmplY3QgPSB0aGlzO1xuICAgIHZhciB0aW1lID0gdGhpcy5fdGltZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB0aW1lLnllYXIgPSBudWxsO1xuICAgIHRpbWUubW9udGggPSBudWxsO1xuICAgIHRpbWUuZGF5ID0gbnVsbDtcbiAgICB0aW1lLmhvdXIgPSBudWxsO1xuICAgIHRpbWUubWludXRlID0gbnVsbDtcbiAgICB0aW1lLnNlY29uZCA9IG51bGw7XG5cbiAgICB0aGlzLmljYWx0eXBlID0gaWNhbHR5cGUgfHwgXCJkYXRlLWFuZC1vci10aW1lXCI7XG5cbiAgICB0aGlzLmZyb21EYXRhKGRhdGEsIHpvbmUpO1xuICB9O1xuICBJQ0FMLmhlbHBlcnMuaW5oZXJpdHMoSUNBTC5UaW1lLCBJQ0FMLlZDYXJkVGltZSwgLyoqIEBsZW5kcyBJQ0FMLlZDYXJkVGltZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgaWRlbnRpZmllci5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwidmNhcmR0aW1lXCJcbiAgICAgKi9cbiAgICBpY2FsY2xhc3M6IFwidmNhcmR0aW1lXCIsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBuYW1lLCB0byBiZSB1c2VkIGluIHRoZSBqQ2FsIG9iamVjdC5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwiZGF0ZS1hbmQtb3ItdGltZVwiXG4gICAgICovXG4gICAgaWNhbHR5cGU6IFwiZGF0ZS1hbmQtb3ItdGltZVwiLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRpbWV6b25lLiBUaGlzIGNhbiBlaXRoZXIgYmUgZmxvYXRpbmcsIFVUQywgb3IgYW4gaW5zdGFuY2Ugb2ZcbiAgICAgKiBJQ0FMLlV0Y09mZnNldC5cbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lem9uZXxJQ0FMLlV0Y09GZnNldH1cbiAgICAgKi9cbiAgICB6b25lOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSB2Y2FyZCBkYXRlL3RpbWUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7SUNBTC5WQ2FyZFRpbWV9ICAgICBUaGUgY2xvbmVkIG9iamVjdFxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgSUNBTC5WQ2FyZFRpbWUodGhpcy5fdGltZSwgdGhpcy56b25lLCB0aGlzLmljYWx0eXBlKTtcbiAgICB9LFxuXG4gICAgX25vcm1hbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGluaGVyaXRkb2NcbiAgICAgKi9cbiAgICB1dGNPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuem9uZSBpbnN0YW5jZW9mIElDQUwuVXRjT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnpvbmUudG9TZWNvbmRzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gSUNBTC5UaW1lLnByb3RvdHlwZS51dGNPZmZzZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBSRkMgNjM1MCBjb21wbGlhbnQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgdmNhcmQgZGF0ZS90aW1lIHN0cmluZ1xuICAgICAqL1xuICAgIHRvSUNBTFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gSUNBTC5kZXNpZ24udmNhcmQudmFsdWVbdGhpcy5pY2FsdHlwZV0udG9JQ0FMKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBkYXRlL3RpbWUsIGluIGpDYXJkIGZvcm1cbiAgICAgKiAoaW5jbHVkaW5nIDogYW5kIC0gc2VwYXJhdG9ycykuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBwMiA9IElDQUwuaGVscGVycy5wYWQyO1xuICAgICAgdmFyIHkgPSB0aGlzLnllYXIsIG0gPSB0aGlzLm1vbnRoLCBkID0gdGhpcy5kYXk7XG4gICAgICB2YXIgaCA9IHRoaXMuaG91ciwgbW0gPSB0aGlzLm1pbnV0ZSwgcyA9IHRoaXMuc2Vjb25kO1xuXG4gICAgICB2YXIgaGFzWWVhciA9IHkgIT09IG51bGwsIGhhc01vbnRoID0gbSAhPT0gbnVsbCwgaGFzRGF5ID0gZCAhPT0gbnVsbDtcbiAgICAgIHZhciBoYXNIb3VyID0gaCAhPT0gbnVsbCwgaGFzTWludXRlID0gbW0gIT09IG51bGwsIGhhc1NlY29uZCA9IHMgIT09IG51bGw7XG5cbiAgICAgIHZhciBkYXRlcGFydCA9IChoYXNZZWFyID8gcDIoeSkgKyAoaGFzTW9udGggfHwgaGFzRGF5ID8gJy0nIDogJycpIDogKGhhc01vbnRoIHx8IGhhc0RheSA/ICctLScgOiAnJykpICtcbiAgICAgICAgICAgICAgICAgICAgIChoYXNNb250aCA/IHAyKG0pIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgIChoYXNEYXkgPyAnLScgKyBwMihkKSA6ICcnKTtcbiAgICAgIHZhciB0aW1lcGFydCA9IChoYXNIb3VyID8gcDIoaCkgOiAnLScpICsgKGhhc0hvdXIgJiYgaGFzTWludXRlID8gJzonIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgIChoYXNNaW51dGUgPyBwMihtbSkgOiAnJykgKyAoIWhhc0hvdXIgJiYgIWhhc01pbnV0ZSA/ICctJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAoaGFzTWludXRlICYmIGhhc1NlY29uZCA/ICc6JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAoaGFzU2Vjb25kID8gcDIocykgOiAnJyk7XG5cbiAgICAgIHZhciB6b25lO1xuICAgICAgaWYgKHRoaXMuem9uZSA9PT0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZSkge1xuICAgICAgICB6b25lID0gJ1onO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnpvbmUgaW5zdGFuY2VvZiBJQ0FMLlV0Y09mZnNldCkge1xuICAgICAgICB6b25lID0gdGhpcy56b25lLnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuem9uZSA9PT0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lKSB7XG4gICAgICAgIHpvbmUgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy56b25lIGluc3RhbmNlb2YgSUNBTC5UaW1lem9uZSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gSUNBTC5VdGNPZmZzZXQuZnJvbVNlY29uZHModGhpcy56b25lLnV0Y09mZnNldCh0aGlzKSk7XG4gICAgICAgIHpvbmUgPSBvZmZzZXQudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHpvbmUgPSAnJztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0aGlzLmljYWx0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJ0aW1lXCI6XG4gICAgICAgICAgcmV0dXJuIHRpbWVwYXJ0ICsgem9uZTtcbiAgICAgICAgY2FzZSBcImRhdGUtYW5kLW9yLXRpbWVcIjpcbiAgICAgICAgY2FzZSBcImRhdGUtdGltZVwiOlxuICAgICAgICAgIHJldHVybiBkYXRlcGFydCArICh0aW1lcGFydCA9PSAnLS0nID8gJycgOiAnVCcgKyB0aW1lcGFydCArIHpvbmUpO1xuICAgICAgICBjYXNlIFwiZGF0ZVwiOlxuICAgICAgICAgIHJldHVybiBkYXRlcGFydDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5WQ2FyZFRpbWUgaW5zdGFuY2UgZnJvbSBhIGRhdGUgYW5kL29yIHRpbWUgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVZhbHVlICAgICBUaGUgc3RyaW5nIHRvIGNyZWF0ZSBmcm9tXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhSWNhbFR5cGUgIFRoZSB0eXBlIGZvciB0aGlzIGluc3RhbmNlLCBlLmcuIGRhdGUtYW5kLW9yLXRpbWVcbiAgICogQHJldHVybiB7SUNBTC5WQ2FyZFRpbWV9ICAgVGhlIGRhdGUvdGltZSBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5WQ2FyZFRpbWUuZnJvbURhdGVBbmRPclRpbWVTdHJpbmcgPSBmdW5jdGlvbihhVmFsdWUsIGFJY2FsVHlwZSkge1xuICAgIGZ1bmN0aW9uIHBhcnQodiwgcywgZSkge1xuICAgICAgcmV0dXJuIHYgPyBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQodi5zdWJzdHIocywgZSkpIDogbnVsbDtcbiAgICB9XG4gICAgdmFyIHBhcnRzID0gYVZhbHVlLnNwbGl0KCdUJyk7XG4gICAgdmFyIGR0ID0gcGFydHNbMF0sIHRteiA9IHBhcnRzWzFdO1xuICAgIHZhciBzcGxpdHpvbmUgPSB0bXogPyBJQ0FMLmRlc2lnbi52Y2FyZC52YWx1ZS50aW1lLl9zcGxpdFpvbmUodG16KSA6IFtdO1xuICAgIHZhciB6b25lID0gc3BsaXR6b25lWzBdLCB0bSA9IHNwbGl0em9uZVsxXTtcblxuICAgIHZhciBzdG9pID0gSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50O1xuICAgIHZhciBkdGxlbiA9IGR0ID8gZHQubGVuZ3RoIDogMDtcbiAgICB2YXIgdG1sZW4gPSB0bSA/IHRtLmxlbmd0aCA6IDA7XG5cbiAgICB2YXIgaGFzRGFzaERhdGUgPSBkdCAmJiBkdFswXSA9PSAnLScgJiYgZHRbMV0gPT0gJy0nO1xuICAgIHZhciBoYXNEYXNoVGltZSA9IHRtICYmIHRtWzBdID09ICctJztcblxuICAgIHZhciBvID0ge1xuICAgICAgeWVhcjogaGFzRGFzaERhdGUgPyBudWxsIDogcGFydChkdCwgMCwgNCksXG4gICAgICBtb250aDogaGFzRGFzaERhdGUgJiYgKGR0bGVuID09IDQgfHwgZHRsZW4gPT0gNykgPyBwYXJ0KGR0LCAyLCAyKSA6IGR0bGVuID09IDcgPyBwYXJ0KGR0LCA1LCAyKSA6IGR0bGVuID09IDEwID8gcGFydChkdCwgNSwgMikgOiBudWxsLFxuICAgICAgZGF5OiBkdGxlbiA9PSA1ID8gcGFydChkdCwgMywgMikgOiBkdGxlbiA9PSA3ICYmIGhhc0Rhc2hEYXRlID8gcGFydChkdCwgNSwgMikgOiBkdGxlbiA9PSAxMCA/IHBhcnQoZHQsIDgsIDIpIDogbnVsbCxcblxuICAgICAgaG91cjogaGFzRGFzaFRpbWUgPyBudWxsIDogcGFydCh0bSwgMCwgMiksXG4gICAgICBtaW51dGU6IGhhc0Rhc2hUaW1lICYmIHRtbGVuID09IDMgPyBwYXJ0KHRtLCAxLCAyKSA6IHRtbGVuID4gNCA/IGhhc0Rhc2hUaW1lID8gcGFydCh0bSwgMSwgMikgOiBwYXJ0KHRtLCAzLCAyKSA6IG51bGwsXG4gICAgICBzZWNvbmQ6IHRtbGVuID09IDQgPyBwYXJ0KHRtLCAyLCAyKSA6IHRtbGVuID09IDYgPyBwYXJ0KHRtLCA0LCAyKSA6IHRtbGVuID09IDggPyBwYXJ0KHRtLCA2LCAyKSA6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKHpvbmUgPT0gJ1onKSB7XG4gICAgICB6b25lID0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZTtcbiAgICB9IGVsc2UgaWYgKHpvbmUgJiYgem9uZVszXSA9PSAnOicpIHtcbiAgICAgIHpvbmUgPSBJQ0FMLlV0Y09mZnNldC5mcm9tU3RyaW5nKHpvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB6b25lID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IElDQUwuVkNhcmRUaW1lKG8sIHpvbmUsIGFJY2FsVHlwZSk7XG4gIH07XG59KSgpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIERPV19NQVAgPSB7XG4gICAgU1U6IElDQUwuVGltZS5TVU5EQVksXG4gICAgTU86IElDQUwuVGltZS5NT05EQVksXG4gICAgVFU6IElDQUwuVGltZS5UVUVTREFZLFxuICAgIFdFOiBJQ0FMLlRpbWUuV0VETkVTREFZLFxuICAgIFRIOiBJQ0FMLlRpbWUuVEhVUlNEQVksXG4gICAgRlI6IElDQUwuVGltZS5GUklEQVksXG4gICAgU0E6IElDQUwuVGltZS5TQVRVUkRBWVxuICB9O1xuXG4gIHZhciBSRVZFUlNFX0RPV19NQVAgPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIERPV19NQVApIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChET1dfTUFQLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIFJFVkVSU0VfRE9XX01BUFtET1dfTUFQW2tleV1dID0ga2V5O1xuICAgIH1cbiAgfVxuXG4gIHZhciBDT1BZX1BBUlRTID0gW1wiQllTRUNPTkRcIiwgXCJCWU1JTlVURVwiLCBcIkJZSE9VUlwiLCBcIkJZREFZXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQllNT05USERBWVwiLCBcIkJZWUVBUkRBWVwiLCBcIkJZV0VFS05PXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQllNT05USFwiLCBcIkJZU0VUUE9TXCJdO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgXCJyZWN1clwiIHZhbHVlIHR5cGUsIHdpdGggdmFyaW91cyBjYWxjdWxhdGlvblxuICAgKiBhbmQgbWFuaXB1bGF0aW9uIG1ldGhvZHMuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAYWxpYXMgSUNBTC5SZWN1clxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBtZW1iZXJzIG9mIHRoZSByZWN1cnJlbmNlXG4gICAqIEBwYXJhbSB7SUNBTC5SZWN1ci5mcmVxdWVuY3lWYWx1ZXM9fSBkYXRhLmZyZXEgICAgIFRoZSBmcmVxdWVuY3kgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmludGVydmFsICAgICAgICAgICAgICAgICAgICAgVGhlIElOVEVSVkFMIHZhbHVlXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lLndlZWtEYXk9fSBkYXRhLndrc3QgICAgICAgICAgICAgIFRoZSB3ZWVrIHN0YXJ0IHZhbHVlXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lPX0gZGF0YS51bnRpbCAgICAgICAgICAgICAgICAgICAgIFRoZSBlbmQgb2YgdGhlIHJlY3VycmVuY2Ugc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5jb3VudCAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZXNcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnlzZWNvbmQgICAgICAgICAgICAgVGhlIHNlY29uZHMgZm9yIHRoZSBCWVNFQ09ORCBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5bWludXRlICAgICAgICAgICAgIFRoZSBtaW51dGVzIGZvciB0aGUgQllNSU5VVEUgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieWhvdXIgICAgICAgICAgICAgICBUaGUgaG91cnMgZm9yIHRoZSBCWUhPVVIgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+PX0gZGF0YS5ieWRheSAgICAgICAgICAgICAgICBUaGUgQllEQVkgdmFsdWVzXG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5bW9udGhkYXkgICAgICAgICAgIFRoZSBkYXlzIGZvciB0aGUgQllNT05USERBWSBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5eWVhcmRheSAgICAgICAgICAgIFRoZSBkYXlzIGZvciB0aGUgQllZRUFSREFZIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnl3ZWVrbm8gICAgICAgICAgICAgVGhlIHdlZWtzIGZvciB0aGUgQllXRUVLTk8gcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieW1vbnRoICAgICAgICAgICAgICBUaGUgbW9udGggZm9yIHRoZSBCWU1PTlRIIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnlzZXRwb3MgICAgICAgICAgICAgVGhlIHBvc2l0aW9uYWxzIGZvciB0aGUgQllTRVRQT1MgcGFydFxuICAgKi9cbiAgSUNBTC5SZWN1ciA9IGZ1bmN0aW9uIGljYWxyZWN1cihkYXRhKSB7XG4gICAgdGhpcy53cmFwcGVkSlNPYmplY3QgPSB0aGlzO1xuICAgIHRoaXMucGFydHMgPSB7fTtcblxuICAgIGlmIChkYXRhICYmIHR5cGVvZihkYXRhKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMuZnJvbURhdGEoZGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIElDQUwuUmVjdXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBob2xkaW5nIHRoZSBCWS1wYXJ0cyBvZiB0aGUgcmVjdXJyZW5jZSBydWxlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBwYXJ0czogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcnZhbCB2YWx1ZSBmb3IgdGhlIHJlY3VycmVuY2UgcnVsZS5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGludGVydmFsOiAxLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHdlZWsgc3RhcnQgZGF5XG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lLndlZWtEYXl9XG4gICAgICogQGRlZmF1bHQgSUNBTC5UaW1lLk1PTkRBWVxuICAgICAqL1xuICAgIHdrc3Q6IElDQUwuVGltZS5NT05EQVksXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZW5kIG9mIHRoZSByZWN1cnJlbmNlXG4gICAgICogQHR5cGUgez9JQ0FMLlRpbWV9XG4gICAgICovXG4gICAgdW50aWw6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2Ygb2NjdXJyZW5jZXNcbiAgICAgKiBAdHlwZSB7P051bWJlcn1cbiAgICAgKi9cbiAgICBjb3VudDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmVxdWVuY3kgdmFsdWUuXG4gICAgICogQHR5cGUge0lDQUwuUmVjdXIuZnJlcXVlbmN5VmFsdWVzfVxuICAgICAqL1xuICAgIGZyZXE6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgaWRlbnRpZmllci5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwiaWNhbHJlY3VyXCJcbiAgICAgKi9cbiAgICBpY2FsY2xhc3M6IFwiaWNhbHJlY3VyXCIsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBuYW1lLCB0byBiZSB1c2VkIGluIHRoZSBqQ2FsIG9iamVjdC5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwicmVjdXJcIlxuICAgICAqL1xuICAgIGljYWx0eXBlOiBcInJlY3VyXCIsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgaXRlcmF0b3IgZm9yIHRoaXMgcmVjdXJyZW5jZSBydWxlLiBUaGUgcGFzc2VkIHN0YXJ0IGRhdGVcbiAgICAgKiBtdXN0IGJlIHRoZSBzdGFydCBkYXRlIG9mIHRoZSBldmVudCwgbm90IHRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgdG9cbiAgICAgKiBzZWFyY2ggaW4uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciByZWN1ciA9IGNvbXAuZ2V0Rmlyc3RQcm9wZXJ0eVZhbHVlKCdycnVsZScpO1xuICAgICAqIHZhciBkdHN0YXJ0ID0gY29tcC5nZXRGaXJzdFByb3BlcnR5VmFsdWUoJ2R0c3RhcnQnKTtcbiAgICAgKiB2YXIgaXRlciA9IHJlY3VyLml0ZXJhdG9yKGR0c3RhcnQpO1xuICAgICAqIGZvciAodmFyIG5leHQgPSBpdGVyLm5leHQoKTsgbmV4dDsgbmV4dCA9IGl0ZXIubmV4dCgpKSB7XG4gICAgICogICBpZiAobmV4dC5jb21wYXJlKHJhbmdlU3RhcnQpIDwgMCkge1xuICAgICAqICAgICBjb250aW51ZTtcbiAgICAgKiAgIH1cbiAgICAgKiAgIGNvbnNvbGUubG9nKG5leHQudG9TdHJpbmcoKSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IGFTdGFydCAgICAgICAgVGhlIGl0ZW0ncyBzdGFydCBkYXRlXG4gICAgICogQHJldHVybiB7SUNBTC5SZWN1ckl0ZXJhdG9yfSAgICAgVGhlIHJlY3VycmVuY2UgaXRlcmF0b3JcbiAgICAgKi9cbiAgICBpdGVyYXRvcjogZnVuY3Rpb24oYVN0YXJ0KSB7XG4gICAgICByZXR1cm4gbmV3IElDQUwuUmVjdXJJdGVyYXRvcih7XG4gICAgICAgIHJ1bGU6IHRoaXMsXG4gICAgICAgIGR0c3RhcnQ6IGFTdGFydFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgcmVjdXJyZW5jZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlJlY3VyfSAgICAgIFRoZSBjbG9uZWQgb2JqZWN0XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyBJQ0FMLlJlY3VyKHRoaXMudG9KU09OKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgcnVsZSBpcyBmaW5pdGUsIGkuZS4gaGFzIGEgY291bnQgb3IgdW50aWwgcGFydC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBUcnVlLCBpZiB0aGUgcnVsZSBpcyBmaW5pdGVcbiAgICAgKi9cbiAgICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNmaW5pdGUoKSB7XG4gICAgICByZXR1cm4gISEodGhpcy5jb3VudCB8fCB0aGlzLnVudGlsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHJ1bGUgaGFzIGEgY291bnQgcGFydCwgYW5kIG5vdCBsaW1pdGVkIGJ5IGFuIHVudGlsXG4gICAgICogcGFydC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBUcnVlLCBpZiB0aGUgcnVsZSBpcyBieSBjb3VudFxuICAgICAqL1xuICAgIGlzQnlDb3VudDogZnVuY3Rpb24gaXNieWNvdW50KCkge1xuICAgICAgcmV0dXJuICEhKHRoaXMuY291bnQgJiYgIXRoaXMudW50aWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY29tcG9uZW50IChwYXJ0KSB0byB0aGUgcmVjdXJyZW5jZSBydWxlLiBUaGlzIGlzIG5vdCBhIGNvbXBvbmVudFxuICAgICAqIGluIHRoZSBzZW5zZSBvZiB7QGxpbmsgSUNBTC5Db21wb25lbnR9LCBidXQgYSBwYXJ0IG9mIHRoZSByZWN1cnJlbmNlXG4gICAgICogcnVsZSwgaS5lLiBCWU1PTlRILlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFUeXBlICAgICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudCBwYXJ0XG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGFWYWx1ZSAgICAgVGhlIGNvbXBvbmVudCB2YWx1ZVxuICAgICAqL1xuICAgIGFkZENvbXBvbmVudDogZnVuY3Rpb24gYWRkUGFydChhVHlwZSwgYVZhbHVlKSB7XG4gICAgICB2YXIgdWNuYW1lID0gYVR5cGUudG9VcHBlckNhc2UoKTtcbiAgICAgIGlmICh1Y25hbWUgaW4gdGhpcy5wYXJ0cykge1xuICAgICAgICB0aGlzLnBhcnRzW3VjbmFtZV0ucHVzaChhVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJ0c1t1Y25hbWVdID0gW2FWYWx1ZV07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbXBvbmVudCB2YWx1ZSBmb3IgdGhlIGdpdmVuIGJ5LXBhcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYVR5cGUgICAgICAgIFRoZSBjb21wb25lbnQgcGFydCBuYW1lXG4gICAgICogQHBhcmFtIHtBcnJheX0gYVZhbHVlcyAgICAgICBUaGUgY29tcG9uZW50IHZhbHVlc1xuICAgICAqL1xuICAgIHNldENvbXBvbmVudDogZnVuY3Rpb24gc2V0Q29tcG9uZW50KGFUeXBlLCBhVmFsdWVzKSB7XG4gICAgICB0aGlzLnBhcnRzW2FUeXBlLnRvVXBwZXJDYXNlKCldID0gYVZhbHVlcy5zbGljZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIChhIGNvcHkpIG9mIHRoZSByZXF1ZXN0ZWQgY29tcG9uZW50IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFUeXBlICAgICAgICBUaGUgY29tcG9uZW50IHBhcnQgbmFtZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgVGhlIGNvbXBvbmVudCBwYXJ0IHZhbHVlXG4gICAgICovXG4gICAgZ2V0Q29tcG9uZW50OiBmdW5jdGlvbiBnZXRDb21wb25lbnQoYVR5cGUpIHtcbiAgICAgIHZhciB1Y25hbWUgPSBhVHlwZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgcmV0dXJuICh1Y25hbWUgaW4gdGhpcy5wYXJ0cyA/IHRoaXMucGFydHNbdWNuYW1lXS5zbGljZSgpIDogW10pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG5leHQgb2NjdXJyZW5jZSBhZnRlciB0aGUgZ2l2ZW4gcmVjdXJyZW5jZSBpZC4gU2VlIHRoZVxuICAgICAqIGd1aWRlIG9uIHtAdHV0b3JpYWwgdGVybWlub2xvZ3l9IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBOT1RFOiBDdXJyZW50bHksIHRoaXMgbWV0aG9kIGl0ZXJhdGVzIGFsbCBvY2N1cnJlbmNlcyBmcm9tIHRoZSBzdGFydFxuICAgICAqIGRhdGUuIEl0IHNob3VsZCBub3QgYmUgY2FsbGVkIGluIGEgbG9vcCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91XG4gICAgICogd291bGQgbGlrZSB0byBnZXQgbW9yZSB0aGFuIG9uZSBvY2N1cnJlbmNlLCB5b3UgY2FuIGl0ZXJhdGUgdGhlXG4gICAgICogb2NjdXJyZW5jZXMgbWFudWFsbHksIHNlZSB0aGUgZXhhbXBsZSBvbiB0aGVcbiAgICAgKiB7QGxpbmsgSUNBTC5SZWN1ciNpdGVyYXRvciBpdGVyYXRvcn0gbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IGFTdGFydFRpbWUgICAgICAgIFRoZSBzdGFydCBvZiB0aGUgZXZlbnQgc2VyaWVzXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IGFSZWN1cnJlbmNlSWQgICAgIFRoZSBkYXRlIG9mIHRoZSBsYXN0IG9jY3VycmVuY2VcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgICAgICAgICAgVGhlIG5leHQgb2NjdXJyZW5jZSBhZnRlclxuICAgICAqL1xuICAgIGdldE5leHRPY2N1cnJlbmNlOiBmdW5jdGlvbiBnZXROZXh0T2NjdXJyZW5jZShhU3RhcnRUaW1lLCBhUmVjdXJyZW5jZUlkKSB7XG4gICAgICB2YXIgaXRlciA9IHRoaXMuaXRlcmF0b3IoYVN0YXJ0VGltZSk7XG4gICAgICB2YXIgbmV4dCwgY2R0O1xuXG4gICAgICBkbyB7XG4gICAgICAgIG5leHQgPSBpdGVyLm5leHQoKTtcbiAgICAgIH0gd2hpbGUgKG5leHQgJiYgbmV4dC5jb21wYXJlKGFSZWN1cnJlbmNlSWQpIDw9IDApO1xuXG4gICAgICBpZiAobmV4dCAmJiBhUmVjdXJyZW5jZUlkLnpvbmUpIHtcbiAgICAgICAgbmV4dC56b25lID0gYVJlY3VycmVuY2VJZC56b25lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSB1c2luZyBtZW1iZXJzIGZyb20gdGhlIHBhc3NlZCBkYXRhIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHJlY3VycmVuY2VcbiAgICAgKiBAcGFyYW0ge0lDQUwuUmVjdXIuZnJlcXVlbmN5VmFsdWVzPX0gZGF0YS5mcmVxICAgICBUaGUgZnJlcXVlbmN5IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmludGVydmFsICAgICAgICAgICAgICAgICAgICAgVGhlIElOVEVSVkFMIHZhbHVlXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGRhdGEud2tzdCAgICAgICAgICAgICAgVGhlIHdlZWsgc3RhcnQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZT19IGRhdGEudW50aWwgICAgICAgICAgICAgICAgICAgICBUaGUgZW5kIG9mIHRoZSByZWN1cnJlbmNlIHNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5jb3VudCAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXNlY29uZCAgICAgICAgICAgICBUaGUgc2Vjb25kcyBmb3IgdGhlIEJZU0VDT05EIHBhcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieW1pbnV0ZSAgICAgICAgICAgICBUaGUgbWludXRlcyBmb3IgdGhlIEJZTUlOVVRFIHBhcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieWhvdXIgICAgICAgICAgICAgICBUaGUgaG91cnMgZm9yIHRoZSBCWUhPVVIgcGFydFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz49fSBkYXRhLmJ5ZGF5ICAgICAgICAgICAgICAgIFRoZSBCWURBWSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieW1vbnRoZGF5ICAgICAgICAgICBUaGUgZGF5cyBmb3IgdGhlIEJZTU9OVEhEQVkgcGFydFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5eWVhcmRheSAgICAgICAgICAgIFRoZSBkYXlzIGZvciB0aGUgQllZRUFSREFZIHBhcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXdlZWtubyAgICAgICAgICAgICBUaGUgd2Vla3MgZm9yIHRoZSBCWVdFRUtOTyBwYXJ0XG4gICAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnltb250aCAgICAgICAgICAgICAgVGhlIG1vbnRoIGZvciB0aGUgQllNT05USCBwYXJ0XG4gICAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnlzZXRwb3MgICAgICAgICAgICAgVGhlIHBvc2l0aW9uYWxzIGZvciB0aGUgQllTRVRQT1MgcGFydFxuICAgICAqL1xuICAgIGZyb21EYXRhOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICB2YXIgdWNrZXkgPSBrZXkudG9VcHBlckNhc2UoKTtcblxuICAgICAgICBpZiAodWNrZXkgaW4gcGFydERlc2lnbikge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFba2V5XSkpIHtcbiAgICAgICAgICAgIHRoaXMucGFydHNbdWNrZXldID0gZGF0YVtrZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcnRzW3Vja2V5XSA9IFtkYXRhW2tleV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzW2tleV0gPSBkYXRhW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaW50ZXJ2YWwgJiYgdHlwZW9mIHRoaXMuaW50ZXJ2YWwgIT0gXCJudW1iZXJcIikge1xuICAgICAgICBvcHRpb25EZXNpZ24uSU5URVJWQUwodGhpcy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLndrc3QgJiYgdHlwZW9mIHRoaXMud2tzdCAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRoaXMud2tzdCA9IElDQUwuUmVjdXIuaWNhbERheVRvTnVtZXJpY0RheSh0aGlzLndrc3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy51bnRpbCAmJiAhKHRoaXMudW50aWwgaW5zdGFuY2VvZiBJQ0FMLlRpbWUpKSB7XG4gICAgICAgIHRoaXMudW50aWwgPSBJQ0FMLlRpbWUuZnJvbVN0cmluZyh0aGlzLnVudGlsKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGpDYWwgcmVwcmVzZW50YXRpb24gb2YgdGhpcyByZWN1cnJlbmNlIHR5cGUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJlcy5mcmVxID0gdGhpcy5mcmVxO1xuXG4gICAgICBpZiAodGhpcy5jb3VudCkge1xuICAgICAgICByZXMuY291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pbnRlcnZhbCA+IDEpIHtcbiAgICAgICAgcmVzLmludGVydmFsID0gdGhpcy5pbnRlcnZhbDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgayBpbiB0aGlzLnBhcnRzKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXRoaXMucGFydHMuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga3BhcnRzID0gdGhpcy5wYXJ0c1trXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa3BhcnRzKSAmJiBrcGFydHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICByZXNbay50b0xvd2VyQ2FzZSgpXSA9IGtwYXJ0c1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNbay50b0xvd2VyQ2FzZSgpXSA9IElDQUwuaGVscGVycy5jbG9uZSh0aGlzLnBhcnRzW2tdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy51bnRpbCkge1xuICAgICAgICByZXMudW50aWwgPSB0aGlzLnVudGlsLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAoJ3drc3QnIGluIHRoaXMgJiYgdGhpcy53a3N0ICE9PSBJQ0FMLlRpbWUuREVGQVVMVF9XRUVLX1NUQVJUKSB7XG4gICAgICAgIHJlcy53a3N0ID0gSUNBTC5SZWN1ci5udW1lcmljRGF5VG9JY2FsRGF5KHRoaXMud2tzdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcmVjdXJyZW5jZSBydWxlLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gaWNhbHJlY3VyX3RvU3RyaW5nKCkge1xuICAgICAgLy8gVE9ETyByZXRhaW4gb3JkZXJcbiAgICAgIHZhciBzdHIgPSBcIkZSRVE9XCIgKyB0aGlzLmZyZXE7XG4gICAgICBpZiAodGhpcy5jb3VudCkge1xuICAgICAgICBzdHIgKz0gXCI7Q09VTlQ9XCIgKyB0aGlzLmNvdW50O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaW50ZXJ2YWwgPiAxKSB7XG4gICAgICAgIHN0ciArPSBcIjtJTlRFUlZBTD1cIiArIHRoaXMuaW50ZXJ2YWw7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrIGluIHRoaXMucGFydHMpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHRoaXMucGFydHMuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICBzdHIgKz0gXCI7XCIgKyBrICsgXCI9XCIgKyB0aGlzLnBhcnRzW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy51bnRpbCkge1xuICAgICAgICBzdHIgKz0gJztVTlRJTD0nICsgdGhpcy51bnRpbC50b0lDQUxTdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmICgnd2tzdCcgaW4gdGhpcyAmJiB0aGlzLndrc3QgIT09IElDQUwuVGltZS5ERUZBVUxUX1dFRUtfU1RBUlQpIHtcbiAgICAgICAgc3RyICs9ICc7V0tTVD0nICsgSUNBTC5SZWN1ci5udW1lcmljRGF5VG9JY2FsRGF5KHRoaXMud2tzdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZU51bWVyaWNWYWx1ZSh0eXBlLCBtaW4sIG1heCwgdmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdmFsdWU7XG5cbiAgICBpZiAodmFsdWVbMF0gPT09ICcrJykge1xuICAgICAgcmVzdWx0ID0gdmFsdWUuc3Vic3RyKDEpO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChyZXN1bHQpO1xuXG4gICAgaWYgKG1pbiAhPT0gdW5kZWZpbmVkICYmIHZhbHVlIDwgbWluKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIHR5cGUgKyAnOiBpbnZhbGlkIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIG11c3QgYmUgPiAnICsgbWluXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+IG1heCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICB0eXBlICsgJzogaW52YWxpZCB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBtdXN0IGJlIDwgJyArIG1pblxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gaWNhbCByZXByZXNlbnRhdGlvbiBvZiBhIGRheSAoU1UsIE1PLCBldGMuLilcbiAgICogaW50byBhIG51bWVyaWMgdmFsdWUgb2YgdGhhdCBkYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgICAgIFRoZSBpQ2FsZW5kYXIgZGF5IG5hbWVcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGFXZWVrU3RhcnRcbiAgICogICAgICAgIFRoZSB3ZWVrIHN0YXJ0IHdlZWtkYXksIGRlZmF1bHRzIHRvIFNVTkRBWVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICBOdW1lcmljIHZhbHVlIG9mIGdpdmVuIGRheVxuICAgKi9cbiAgSUNBTC5SZWN1ci5pY2FsRGF5VG9OdW1lcmljRGF5ID0gZnVuY3Rpb24gdG9OdW1lcmljRGF5KHN0cmluZywgYVdlZWtTdGFydCkge1xuICAgIC8vWFhYOiB0aGlzIGlzIGhlcmUgc28gd2UgY2FuIGRlYWxcbiAgICAvLyAgICAgd2l0aCBwb3NzaWJseSBpbnZhbGlkIHN0cmluZyB2YWx1ZXMuXG4gICAgdmFyIGZpcnN0RG93ID0gYVdlZWtTdGFydCB8fCBJQ0FMLlRpbWUuU1VOREFZO1xuICAgIHJldHVybiAoKERPV19NQVBbc3RyaW5nXSAtIGZpcnN0RG93ICsgNykgJSA3KSArIDE7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBudW1lcmljIGRheSB2YWx1ZSBpbnRvIGl0cyBpY2FsIHJlcHJlc2VudGF0aW9uIChTVSwgTU8sIGV0Yy4uKVxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtICAgICAgICBOdW1lcmljIHZhbHVlIG9mIGdpdmVuIGRheVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5PX0gYVdlZWtTdGFydFxuICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgIFRoZSBJQ0FMIGRheSB2YWx1ZSwgZS5nIFNVLE1PLC4uLlxuICAgKi9cbiAgSUNBTC5SZWN1ci5udW1lcmljRGF5VG9JY2FsRGF5ID0gZnVuY3Rpb24gdG9JY2FsRGF5KG51bSwgYVdlZWtTdGFydCkge1xuICAgIC8vWFhYOiB0aGlzIGlzIGhlcmUgc28gd2UgY2FuIGRlYWwgd2l0aCBwb3NzaWJseSBpbnZhbGlkIG51bWJlciB2YWx1ZXMuXG4gICAgLy8gICAgIEFsc28sIHRoaXMgYWxsb3dzIGNvbnNpc3RlbnQgbWFwcGluZyBiZXR3ZWVuIGRheSBudW1iZXJzIGFuZCBkYXlcbiAgICAvLyAgICAgbmFtZXMgZm9yIGV4dGVybmFsIHVzZXJzLlxuICAgIHZhciBmaXJzdERvdyA9IGFXZWVrU3RhcnQgfHwgSUNBTC5UaW1lLlNVTkRBWTtcbiAgICB2YXIgZG93ID0gKG51bSArIGZpcnN0RG93IC0gSUNBTC5UaW1lLlNVTkRBWSk7XG4gICAgaWYgKGRvdyA+IDcpIHtcbiAgICAgIGRvdyAtPSA3O1xuICAgIH1cbiAgICByZXR1cm4gUkVWRVJTRV9ET1dfTUFQW2Rvd107XG4gIH07XG5cbiAgdmFyIFZBTElEX0RBWV9OQU1FUyA9IC9eKFNVfE1PfFRVfFdFfFRIfEZSfFNBKSQvO1xuICB2YXIgVkFMSURfQllEQVlfUEFSVCA9IC9eKFsrLV0pPyg1WzAtM118WzEtNF1bMC05XXxbMS05XSk/KFNVfE1PfFRVfFdFfFRIfEZSfFNBKSQvO1xuXG4gIC8qKlxuICAgKiBQb3NzaWJsZSBmcmVxdWVuY3kgdmFsdWVzIGZvciB0aGUgRlJFUSBwYXJ0XG4gICAqIChZRUFSTFksIE1PTlRITFksIFdFRUtMWSwgREFJTFksIEhPVVJMWSwgTUlOVVRFTFksIFNFQ09ORExZKVxuICAgKlxuICAgKiBAdHlwZWRlZiB7U3RyaW5nfSBmcmVxdWVuY3lWYWx1ZXNcbiAgICogQG1lbWJlcm9mIElDQUwuUmVjdXJcbiAgICovXG5cbiAgdmFyIEFMTE9XRURfRlJFUSA9IFsnU0VDT05ETFknLCAnTUlOVVRFTFknLCAnSE9VUkxZJyxcbiAgICAgICAgICAgICAgICAgICAgICAnREFJTFknLCAnV0VFS0xZJywgJ01PTlRITFknLCAnWUVBUkxZJ107XG5cbiAgdmFyIG9wdGlvbkRlc2lnbiA9IHtcbiAgICBGUkVROiBmdW5jdGlvbih2YWx1ZSwgZGljdCwgZm10SWNhbCkge1xuICAgICAgLy8geWVzIHRoaXMgaXMgYWN0dWFsbHkgZXF1YWwgb3IgZmFzdGVyIHRoZW4gcmVnZXguXG4gICAgICAvLyB1cHNpZGUgaGVyZSBpcyB3ZSBjYW4gZW51bWVyYXRlIHRoZSB2YWxpZCB2YWx1ZXMuXG4gICAgICBpZiAoQUxMT1dFRF9GUkVRLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgICBkaWN0LmZyZXEgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnaW52YWxpZCBmcmVxdWVuY3kgXCInICsgdmFsdWUgKyAnXCIgZXhwZWN0ZWQ6IFwiJyArXG4gICAgICAgICAgQUxMT1dFRF9GUkVRLmpvaW4oJywgJykgKyAnXCInXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIENPVU5UOiBmdW5jdGlvbih2YWx1ZSwgZGljdCwgZm10SWNhbCkge1xuICAgICAgZGljdC5jb3VudCA9IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludCh2YWx1ZSk7XG4gICAgfSxcblxuICAgIElOVEVSVkFMOiBmdW5jdGlvbih2YWx1ZSwgZGljdCwgZm10SWNhbCkge1xuICAgICAgZGljdC5pbnRlcnZhbCA9IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludCh2YWx1ZSk7XG4gICAgICBpZiAoZGljdC5pbnRlcnZhbCA8IDEpIHtcbiAgICAgICAgLy8gMCBvciBuZWdhdGl2ZSB2YWx1ZXMgYXJlIG5vdCBhbGxvd2VkLCBzb21lIGVuZ2luZXMgc2VlbSB0byBnZW5lcmF0ZVxuICAgICAgICAvLyBpdCB0aG91Z2guIEFzc3VtZSAxIGluc3RlYWQuXG4gICAgICAgIGRpY3QuaW50ZXJ2YWwgPSAxO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBVTlRJTDogZnVuY3Rpb24odmFsdWUsIGRpY3QsIGZtdEljYWwpIHtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxMCkge1xuICAgICAgICBkaWN0LnVudGlsID0gSUNBTC5kZXNpZ24uaWNhbGVuZGFyLnZhbHVlWydkYXRlLXRpbWUnXS5mcm9tSUNBTCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWN0LnVudGlsID0gSUNBTC5kZXNpZ24uaWNhbGVuZGFyLnZhbHVlLmRhdGUuZnJvbUlDQUwodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKCFmbXRJY2FsKSB7XG4gICAgICAgIGRpY3QudW50aWwgPSBJQ0FMLlRpbWUuZnJvbVN0cmluZyhkaWN0LnVudGlsKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgV0tTVDogZnVuY3Rpb24odmFsdWUsIGRpY3QsIGZtdEljYWwpIHtcbiAgICAgIGlmIChWQUxJRF9EQVlfTkFNRVMudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgZGljdC53a3N0ID0gSUNBTC5SZWN1ci5pY2FsRGF5VG9OdW1lcmljRGF5KHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBXS1NUIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiJyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBwYXJ0RGVzaWduID0ge1xuICAgIEJZU0VDT05EOiBwYXJzZU51bWVyaWNWYWx1ZS5iaW5kKHRoaXMsICdCWVNFQ09ORCcsIDAsIDYwKSxcbiAgICBCWU1JTlVURTogcGFyc2VOdW1lcmljVmFsdWUuYmluZCh0aGlzLCAnQllNSU5VVEUnLCAwLCA1OSksXG4gICAgQllIT1VSOiBwYXJzZU51bWVyaWNWYWx1ZS5iaW5kKHRoaXMsICdCWUhPVVInLCAwLCAyMyksXG4gICAgQllEQVk6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoVkFMSURfQllEQVlfUEFSVC50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgQllEQVkgdmFsdWUgXCInICsgdmFsdWUgKyAnXCInKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIEJZTU9OVEhEQVk6IHBhcnNlTnVtZXJpY1ZhbHVlLmJpbmQodGhpcywgJ0JZTU9OVEhEQVknLCAtMzEsIDMxKSxcbiAgICBCWVlFQVJEQVk6IHBhcnNlTnVtZXJpY1ZhbHVlLmJpbmQodGhpcywgJ0JZWUVBUkRBWScsIC0zNjYsIDM2NiksXG4gICAgQllXRUVLTk86IHBhcnNlTnVtZXJpY1ZhbHVlLmJpbmQodGhpcywgJ0JZV0VFS05PJywgLTUzLCA1MyksXG4gICAgQllNT05USDogcGFyc2VOdW1lcmljVmFsdWUuYmluZCh0aGlzLCAnQllNT05USCcsIDEsIDEyKSxcbiAgICBCWVNFVFBPUzogcGFyc2VOdW1lcmljVmFsdWUuYmluZCh0aGlzLCAnQllTRVRQT1MnLCAtMzY2LCAzNjYpXG4gIH07XG5cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5SZWN1cn0gaW5zdGFuY2UgZnJvbSB0aGUgcGFzc2VkIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyAgICAgICAgIFRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHJldHVybiB7SUNBTC5SZWN1cn0gICAgICAgICAgIFRoZSBjcmVhdGVkIHJlY3VycmVuY2UgaW5zdGFuY2VcbiAgICovXG4gIElDQUwuUmVjdXIuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBkYXRhID0gSUNBTC5SZWN1ci5fc3RyaW5nVG9EYXRhKHN0cmluZywgZmFsc2UpO1xuICAgIHJldHVybiBuZXcgSUNBTC5SZWN1cihkYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5SZWN1cn0gaW5zdGFuY2UgdXNpbmcgbWVtYmVycyBmcm9tIHRoZSBwYXNzZWRcbiAgICogZGF0YSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHJlY3VycmVuY2VcbiAgICogQHBhcmFtIHtJQ0FMLlJlY3VyLmZyZXF1ZW5jeVZhbHVlcz19IGFEYXRhLmZyZXEgICAgVGhlIGZyZXF1ZW5jeSB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmludGVydmFsICAgICAgICAgICAgICAgICAgICBUaGUgSU5URVJWQUwgdmFsdWVcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGFEYXRhLndrc3QgICAgICAgICAgICAgVGhlIHdlZWsgc3RhcnQgdmFsdWVcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWU9fSBhRGF0YS51bnRpbCAgICAgICAgICAgICAgICAgICAgVGhlIGVuZCBvZiB0aGUgcmVjdXJyZW5jZSBzZXRcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5jb3VudCAgICAgICAgICAgICAgICAgICAgICAgVGhlIG51bWJlciBvZiBvY2N1cnJlbmNlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnlzZWNvbmQgICAgICAgICAgICBUaGUgc2Vjb25kcyBmb3IgdGhlIEJZU0VDT05EIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGFEYXRhLmJ5bWludXRlICAgICAgICAgICAgVGhlIG1pbnV0ZXMgZm9yIHRoZSBCWU1JTlVURSBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBhRGF0YS5ieWhvdXIgICAgICAgICAgICAgIFRoZSBob3VycyBmb3IgdGhlIEJZSE9VUiBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz49fSBhRGF0YS5ieWRheSAgICAgICAgICAgICAgIFRoZSBCWURBWSB2YWx1ZXNcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGFEYXRhLmJ5bW9udGhkYXkgICAgICAgICAgVGhlIGRheXMgZm9yIHRoZSBCWU1PTlRIREFZIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGFEYXRhLmJ5eWVhcmRheSAgICAgICAgICAgVGhlIGRheXMgZm9yIHRoZSBCWVlFQVJEQVkgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnl3ZWVrbm8gICAgICAgICAgICBUaGUgd2Vla3MgZm9yIHRoZSBCWVdFRUtOTyBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBhRGF0YS5ieW1vbnRoICAgICAgICAgICAgIFRoZSBtb250aCBmb3IgdGhlIEJZTU9OVEggcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnlzZXRwb3MgICAgICAgICAgICBUaGUgcG9zaXRpb25hbHMgZm9yIHRoZSBCWVNFVFBPUyBwYXJ0XG4gICAqL1xuICBJQ0FMLlJlY3VyLmZyb21EYXRhID0gZnVuY3Rpb24oYURhdGEpIHtcbiAgICByZXR1cm4gbmV3IElDQUwuUmVjdXIoYURhdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHJlY3VycmVuY2Ugc3RyaW5nIHRvIGEgZGF0YSBvYmplY3QsIHN1aXRhYmxlIGZvciB0aGUgZnJvbURhdGFcbiAgICogbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nICAgICBUaGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm10SWNhbCAgIElmIHRydWUsIHRoZSBzdHJpbmcgaXMgY29uc2lkZXJlZCB0byBiZSBhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlDYWxlbmRhciBzdHJpbmdcbiAgICogQHJldHVybiB7SUNBTC5SZWN1cn0gICAgICAgVGhlIHJlY3VycmVuY2UgaW5zdGFuY2VcbiAgICovXG4gIElDQUwuUmVjdXIuX3N0cmluZ1RvRGF0YSA9IGZ1bmN0aW9uKHN0cmluZywgZm10SWNhbCkge1xuICAgIHZhciBkaWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8vIHNwbGl0IGlzIHNsb3dlciBpbiBGRiBidXQgZmFzdCBlbm91Z2guXG4gICAgLy8gdjggaG93ZXZlciB0aGlzIGlzIGZhc3RlciB0aGVuIG1hbnVhbCBzcGxpdD9cbiAgICB2YXIgdmFsdWVzID0gc3RyaW5nLnNwbGl0KCc7Jyk7XG4gICAgdmFyIGxlbiA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcGFydHMgPSB2YWx1ZXNbaV0uc3BsaXQoJz0nKTtcbiAgICAgIHZhciB1Y25hbWUgPSBwYXJ0c1swXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgdmFyIGxjbmFtZSA9IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgbmFtZSA9IChmbXRJY2FsID8gbGNuYW1lIDogdWNuYW1lKTtcbiAgICAgIHZhciB2YWx1ZSA9IHBhcnRzWzFdO1xuXG4gICAgICBpZiAodWNuYW1lIGluIHBhcnREZXNpZ24pIHtcbiAgICAgICAgdmFyIHBhcnRBcnIgPSB2YWx1ZS5zcGxpdCgnLCcpO1xuICAgICAgICB2YXIgcGFydEFycklkeCA9IDA7XG4gICAgICAgIHZhciBwYXJ0QXJyTGVuID0gcGFydEFyci5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IHBhcnRBcnJJZHggPCBwYXJ0QXJyTGVuOyBwYXJ0QXJySWR4KyspIHtcbiAgICAgICAgICBwYXJ0QXJyW3BhcnRBcnJJZHhdID0gcGFydERlc2lnblt1Y25hbWVdKHBhcnRBcnJbcGFydEFycklkeF0pO1xuICAgICAgICB9XG4gICAgICAgIGRpY3RbbmFtZV0gPSAocGFydEFyci5sZW5ndGggPT0gMSA/IHBhcnRBcnJbMF0gOiBwYXJ0QXJyKTtcbiAgICAgIH0gZWxzZSBpZiAodWNuYW1lIGluIG9wdGlvbkRlc2lnbikge1xuICAgICAgICBvcHRpb25EZXNpZ25bdWNuYW1lXSh2YWx1ZSwgZGljdCwgZm10SWNhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEb24ndCBzd2FsbG93IHVua25vd24gdmFsdWVzLiBKdXN0IHNldCB0aGVtIGFzIHRoZXkgYXJlLlxuICAgICAgICBkaWN0W2xjbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGljdDtcbiAgfTtcbn0pKCk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG5cbi8qKlxuICogVGhpcyBzeW1ib2wgaXMgZnVydGhlciBkZXNjcmliZWQgbGF0ZXIgb25cbiAqIEBpZ25vcmVcbiAqL1xuSUNBTC5SZWN1ckl0ZXJhdG9yID0gKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIEFuIGl0ZXJhdG9yIGZvciBhIHNpbmdsZSByZWN1cnJlbmNlIHJ1bGUuIFRoaXMgY2xhc3MgdXN1YWxseSBkb2Vzbid0IGhhdmVcbiAgICogdG8gYmUgaW5zdGFuY2lhdGVkIGRpcmVjdGx5LCB0aGUgY29udmVuaWVuY2UgbWV0aG9kXG4gICAqIHtAbGluayBJQ0FMLlJlY3VyI2l0ZXJhdG9yfSBjYW4gYmUgdXNlZC5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBvcHRpb25zIG9iamVjdCBtYXkgY29udGFpbiBhZGRpdGlvbmFsIG1lbWJlcnMgd2hlbiByZXN1bWluZyBpdGVyYXRpb24gZnJvbSBhIHByZXZpb3VzIHJ1blxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIG9wdGlvbnMgb2JqZWN0IG1heSBjb250YWluIGFkZGl0aW9uYWwgbWVtYmVycyB3aGVuIHJlc3VtaW5nIGl0ZXJhdGlvblxuICAgKiBmcm9tIGEgcHJldmlvdXMgcnVuLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFsaWFzIElDQUwuUmVjdXJJdGVyYXRvclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICAgICBUaGUgaXRlcmF0b3Igb3B0aW9uc1xuICAgKiBAcGFyYW0ge0lDQUwuUmVjdXJ9IG9wdGlvbnMucnVsZSAgICAgICBUaGUgcnVsZSB0byBpdGVyYXRlLlxuICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gb3B0aW9ucy5kdHN0YXJ0ICAgICBUaGUgc3RhcnQgZGF0ZSBvZiB0aGUgZXZlbnQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbj19IG9wdGlvbnMuaW5pdGlhbGl6ZWQgIFdoZW4gdHJ1ZSwgYXNzdW1lIHRoYXQgb3B0aW9ucyBhcmVcbiAgICogICAgICAgIGZyb20gYSBwcmV2aW91c2x5IGNvbnN0cnVjdGVkIGl0ZXJhdG9yLiBJbml0aWFsaXphdGlvbiB3aWxsIG5vdCBiZVxuICAgKiAgICAgICAgcmVwZWF0ZWQuXG4gICAqL1xuICBmdW5jdGlvbiBpY2FscmVjdXJfaXRlcmF0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuZnJvbURhdGEob3B0aW9ucyk7XG4gIH1cblxuICBpY2FscmVjdXJfaXRlcmF0b3IucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogVHJ1ZSB3aGVuIGl0ZXJhdGlvbiBpcyBmaW5pc2hlZC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBjb21wbGV0ZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHJ1bGUgdGhhdCBpcyBiZWluZyBpdGVyYXRlZFxuICAgICAqIEB0eXBlIHtJQ0FMLlJlY3VyfVxuICAgICAqL1xuICAgIHJ1bGU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RhcnQgZGF0ZSBvZiB0aGUgZXZlbnQgYmVpbmcgaXRlcmF0ZWQuXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICBkdHN0YXJ0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGxhc3Qgb2NjdXJyZW5jZSB0aGF0IHdhcyByZXR1cm5lZCBmcm9tIHRoZVxuICAgICAqIHtAbGluayBJQ0FMLlJlY3VySXRlcmF0b3IjbmV4dH0gbWV0aG9kLlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgbGFzdDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZXF1ZW5jZSBudW1iZXIgZnJvbSB0aGUgb2NjdXJyZW5jZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgb2NjdXJyZW5jZV9udW1iZXI6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kaWNlcyB1c2VkIGZvciB0aGUge0BsaW5rIElDQUwuUmVjdXJJdGVyYXRvciNieV9kYXRhfSBvYmplY3QuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJ5X2luZGljZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgaXRlcmF0b3IgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGluaXRpYWxpemQgYnktZGF0YS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYnlfZGF0YTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBleHBhbmRlZCB5ZWFyZGF5c1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRheXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggaW4gdGhlIHtAbGluayBJQ0FMLlJlY3VySXRlcmF0b3IjZGF5c30gYXJyYXkuXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRheXNfaW5kZXg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSByZWN1cnJlbmNlIGl0ZXJhdG9yIGZyb20gdGhlIHBhc3NlZCBkYXRhIG9iamVjdC4gVGhpc1xuICAgICAqIG1ldGhvZCBpcyB1c3VhbGx5IG5vdCBjYWxsZWQgZGlyZWN0bHksIHlvdSBjYW4gaW5pdGlhbGl6ZSB0aGUgaXRlcmF0b3JcbiAgICAgKiB0aHJvdWdoIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgICAgIFRoZSBpdGVyYXRvciBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJQ0FMLlJlY3VyfSBvcHRpb25zLnJ1bGUgICAgICAgVGhlIHJ1bGUgdG8gaXRlcmF0ZS5cbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gb3B0aW9ucy5kdHN0YXJ0ICAgICBUaGUgc3RhcnQgZGF0ZSBvZiB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHtCb29sZWFuPX0gb3B0aW9ucy5pbml0aWFsaXplZCAgV2hlbiB0cnVlLCBhc3N1bWUgdGhhdCBvcHRpb25zIGFyZVxuICAgICAqICAgICAgICBmcm9tIGEgcHJldmlvdXNseSBjb25zdHJ1Y3RlZCBpdGVyYXRvci4gSW5pdGlhbGl6YXRpb24gd2lsbCBub3QgYmVcbiAgICAgKiAgICAgICAgcmVwZWF0ZWQuXG4gICAgICovXG4gICAgZnJvbURhdGE6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMucnVsZSA9IElDQUwuaGVscGVycy5mb3JtYXRDbGFzc1R5cGUob3B0aW9ucy5ydWxlLCBJQ0FMLlJlY3VyKTtcblxuICAgICAgaWYgKCF0aGlzLnJ1bGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpdGVyYXRvciByZXF1aXJlcyBhIChJQ0FMLlJlY3VyKSBydWxlJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZHRzdGFydCA9IElDQUwuaGVscGVycy5mb3JtYXRDbGFzc1R5cGUob3B0aW9ucy5kdHN0YXJ0LCBJQ0FMLlRpbWUpO1xuXG4gICAgICBpZiAoIXRoaXMuZHRzdGFydCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2l0ZXJhdG9yIHJlcXVpcmVzIGEgKElDQUwuVGltZSkgZHRzdGFydCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5ieV9kYXRhKSB7XG4gICAgICAgIHRoaXMuYnlfZGF0YSA9IG9wdGlvbnMuYnlfZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYnlfZGF0YSA9IElDQUwuaGVscGVycy5jbG9uZSh0aGlzLnJ1bGUucGFydHMsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5vY2N1cnJlbmNlX251bWJlcilcbiAgICAgICAgdGhpcy5vY2N1cnJlbmNlX251bWJlciA9IG9wdGlvbnMub2NjdXJyZW5jZV9udW1iZXI7XG5cbiAgICAgIHRoaXMuZGF5cyA9IG9wdGlvbnMuZGF5cyB8fCBbXTtcbiAgICAgIGlmIChvcHRpb25zLmxhc3QpIHtcbiAgICAgICAgdGhpcy5sYXN0ID0gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZShvcHRpb25zLmxhc3QsIElDQUwuVGltZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnlfaW5kaWNlcyA9IG9wdGlvbnMuYnlfaW5kaWNlcztcblxuICAgICAgaWYgKCF0aGlzLmJ5X2luZGljZXMpIHtcbiAgICAgICAgdGhpcy5ieV9pbmRpY2VzID0ge1xuICAgICAgICAgIFwiQllTRUNPTkRcIjogMCxcbiAgICAgICAgICBcIkJZTUlOVVRFXCI6IDAsXG4gICAgICAgICAgXCJCWUhPVVJcIjogMCxcbiAgICAgICAgICBcIkJZREFZXCI6IDAsXG4gICAgICAgICAgXCJCWU1PTlRIXCI6IDAsXG4gICAgICAgICAgXCJCWVdFRUtOT1wiOiAwLFxuICAgICAgICAgIFwiQllNT05USERBWVwiOiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBvcHRpb25zLmluaXRpYWxpemVkIHx8IGZhbHNlO1xuXG4gICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludGlhbGl6ZSB0aGUgaXRlcmF0b3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uIGljYWxyZWN1cl9pdGVyYXRvcl9pbml0KCkge1xuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB0aGlzLmxhc3QgPSB0aGlzLmR0c3RhcnQuY2xvbmUoKTtcbiAgICAgIHZhciBwYXJ0cyA9IHRoaXMuYnlfZGF0YTtcblxuICAgICAgaWYgKFwiQllEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICAvLyBsaWJpY2FsIGRvZXMgdGhpcyBlYXJsaWVyIHdoZW4gdGhlIHJ1bGUgaXMgbG9hZGVkLCBidXQgd2UgcG9zdHBvbmUgdG9cbiAgICAgICAgLy8gbm93IHNvIHdlIGNhbiBwcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgb3JkZXIuXG4gICAgICAgIHRoaXMuc29ydF9ieWRheV9ydWxlcyhwYXJ0cy5CWURBWSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBCWVlFQVJEQVkgYXBwYXJlcywgbm8gb3RoZXIgZGF0ZSBydWxlIHBhcnQgbWF5IGFwcGVhclxuICAgICAgaWYgKFwiQllZRUFSREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgaWYgKFwiQllNT05USFwiIGluIHBhcnRzIHx8IFwiQllXRUVLTk9cIiBpbiBwYXJ0cyB8fFxuICAgICAgICAgICAgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMgfHwgXCJCWURBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBCWVlFQVJEQVkgcnVsZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBCWVdFRUtOTyBhbmQgQllNT05USERBWSBydWxlIHBhcnRzIG1heSBub3QgYm90aCBhcHBlYXJcbiAgICAgIGlmIChcIkJZV0VFS05PXCIgaW4gcGFydHMgJiYgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQllXRUVLTk8gZG9lcyBub3QgZml0IHRvIEJZTU9OVEhEQVlcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIEZvciBNT05USExZIHJlY3VycmVuY2VzIChGUkVRPU1PTlRITFkpIG5laXRoZXIgQllZRUFSREFZIG5vclxuICAgICAgLy8gQllXRUVLTk8gbWF5IGFwcGVhci5cbiAgICAgIGlmICh0aGlzLnJ1bGUuZnJlcSA9PSBcIk1PTlRITFlcIiAmJlxuICAgICAgICAgIChcIkJZWUVBUkRBWVwiIGluIHBhcnRzIHx8IFwiQllXRUVLTk9cIiBpbiBwYXJ0cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm9yIE1PTlRITFkgcmVjdXJyZW5jZXMgbmVpdGhlciBCWVlFQVJEQVkgbm9yIEJZV0VFS05PIG1heSBhcHBlYXJcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIEZvciBXRUVLTFkgcmVjdXJyZW5jZXMgKEZSRVE9V0VFS0xZKSBuZWl0aGVyIEJZTU9OVEhEQVkgbm9yXG4gICAgICAvLyBCWVlFQVJEQVkgbWF5IGFwcGVhci5cbiAgICAgIGlmICh0aGlzLnJ1bGUuZnJlcSA9PSBcIldFRUtMWVwiICYmXG4gICAgICAgICAgKFwiQllZRUFSREFZXCIgaW4gcGFydHMgfHwgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZvciBXRUVLTFkgcmVjdXJyZW5jZXMgbmVpdGhlciBCWU1PTlRIREFZIG5vciBCWVlFQVJEQVkgbWF5IGFwcGVhclwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gQllZRUFSREFZIG1heSBvbmx5IGFwcGVhciBpbiBZRUFSTFkgcnVsZXNcbiAgICAgIGlmICh0aGlzLnJ1bGUuZnJlcSAhPSBcIllFQVJMWVwiICYmIFwiQllZRUFSREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQllZRUFSREFZIG1heSBvbmx5IGFwcGVhciBpbiBZRUFSTFkgcnVsZXNcIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdC5zZWNvbmQgPSB0aGlzLnNldHVwX2RlZmF1bHRzKFwiQllTRUNPTkRcIiwgXCJTRUNPTkRMWVwiLCB0aGlzLmR0c3RhcnQuc2Vjb25kKTtcbiAgICAgIHRoaXMubGFzdC5taW51dGUgPSB0aGlzLnNldHVwX2RlZmF1bHRzKFwiQllNSU5VVEVcIiwgXCJNSU5VVEVMWVwiLCB0aGlzLmR0c3RhcnQubWludXRlKTtcbiAgICAgIHRoaXMubGFzdC5ob3VyID0gdGhpcy5zZXR1cF9kZWZhdWx0cyhcIkJZSE9VUlwiLCBcIkhPVVJMWVwiLCB0aGlzLmR0c3RhcnQuaG91cik7XG4gICAgICB0aGlzLmxhc3QuZGF5ID0gdGhpcy5zZXR1cF9kZWZhdWx0cyhcIkJZTU9OVEhEQVlcIiwgXCJEQUlMWVwiLCB0aGlzLmR0c3RhcnQuZGF5KTtcbiAgICAgIHRoaXMubGFzdC5tb250aCA9IHRoaXMuc2V0dXBfZGVmYXVsdHMoXCJCWU1PTlRIXCIsIFwiTU9OVEhMWVwiLCB0aGlzLmR0c3RhcnQubW9udGgpO1xuXG4gICAgICBpZiAodGhpcy5ydWxlLmZyZXEgPT0gXCJXRUVLTFlcIikge1xuICAgICAgICBpZiAoXCJCWURBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgICAgdmFyIGJ5ZGF5UGFydHMgPSB0aGlzLnJ1bGVEYXlPZldlZWsocGFydHMuQllEQVlbMF0sIHRoaXMucnVsZS53a3N0KTtcbiAgICAgICAgICB2YXIgcG9zID0gYnlkYXlQYXJ0c1swXTtcbiAgICAgICAgICB2YXIgZG93ID0gYnlkYXlQYXJ0c1sxXTtcbiAgICAgICAgICB2YXIgd2tkeSA9IGRvdyAtIHRoaXMubGFzdC5kYXlPZldlZWsodGhpcy5ydWxlLndrc3QpO1xuICAgICAgICAgIGlmICgodGhpcy5sYXN0LmRheU9mV2Vlayh0aGlzLnJ1bGUud2tzdCkgPCBkb3cgJiYgd2tkeSA+PSAwKSB8fCB3a2R5IDwgMCkge1xuICAgICAgICAgICAgLy8gSW5pdGlhbCB0aW1lIGlzIGFmdGVyIGZpcnN0IGRheSBvZiBCWURBWSBkYXRhXG4gICAgICAgICAgICB0aGlzLmxhc3QuZGF5ICs9IHdrZHk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkYXlOYW1lID0gSUNBTC5SZWN1ci5udW1lcmljRGF5VG9JY2FsRGF5KHRoaXMuZHRzdGFydC5kYXlPZldlZWsoKSk7XG4gICAgICAgICAgcGFydHMuQllEQVkgPSBbZGF5TmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucnVsZS5mcmVxID09IFwiWUVBUkxZXCIpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIHRoaXMuZXhwYW5kX3llYXJfZGF5cyh0aGlzLmxhc3QueWVhcik7XG4gICAgICAgICAgaWYgKHRoaXMuZGF5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5pbmNyZW1lbnRfeWVhcih0aGlzLnJ1bGUuaW50ZXJ2YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbmV4dEJ5WWVhckRheSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ydWxlLmZyZXEgPT0gXCJNT05USExZXCIgJiYgdGhpcy5oYXNfYnlfZGF0YShcIkJZREFZXCIpKSB7XG4gICAgICAgIHZhciB0ZW1wTGFzdCA9IG51bGw7XG4gICAgICAgIHZhciBpbml0TGFzdCA9IHRoaXMubGFzdC5jbG9uZSgpO1xuICAgICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodGhpcy5sYXN0Lm1vbnRoLCB0aGlzLmxhc3QueWVhcik7XG5cbiAgICAgICAgLy8gQ2hlY2sgZXZlcnkgd2Vla2RheSBpbiBCWURBWSB3aXRoIHJlbGF0aXZlIGRvdyBhbmQgcG9zLlxuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuYnlfZGF0YS5CWURBWSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZREFZLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5sYXN0ID0gaW5pdExhc3QuY2xvbmUoKTtcbiAgICAgICAgICB2YXIgYnlkYXlQYXJ0cyA9IHRoaXMucnVsZURheU9mV2Vlayh0aGlzLmJ5X2RhdGEuQllEQVlbaV0pO1xuICAgICAgICAgIHZhciBwb3MgPSBieWRheVBhcnRzWzBdO1xuICAgICAgICAgIHZhciBkb3cgPSBieWRheVBhcnRzWzFdO1xuICAgICAgICAgIHZhciBkYXlPZk1vbnRoID0gdGhpcy5sYXN0Lm50aFdlZWtEYXkoZG93LCBwb3MpO1xuXG4gICAgICAgICAgLy8gSWYgfHBvc3wgPj0gNiwgdGhlIGJ5ZGF5IGlzIGludmFsaWQgZm9yIGEgbW9udGhseSBydWxlLlxuICAgICAgICAgIGlmIChwb3MgPj0gNiB8fCBwb3MgPD0gLTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCB2YWx1ZXMgaW4gQllEQVkgcGFydFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiBhIEJ5ZGF5IHdpdGggcG9zPSsvLTUgaXMgbm90IGluIHRoZSBjdXJyZW50IG1vbnRoIGl0XG4gICAgICAgICAgLy8gbXVzdCBiZSBzZWFyY2hlZCBpbiB0aGUgbmV4dCBtb250aHMuXG4gICAgICAgICAgaWYgKGRheU9mTW9udGggPiBkYXlzSW5Nb250aCB8fCBkYXlPZk1vbnRoIDw9IDApIHtcbiAgICAgICAgICAgIC8vIFNraXAgaWYgd2UgaGF2ZSBhbHJlYWR5IGZvdW5kIGEgXCJsYXN0XCIgaW4gdGhpcyBtb250aC5cbiAgICAgICAgICAgIGlmICh0ZW1wTGFzdCAmJiB0ZW1wTGFzdC5tb250aCA9PSBpbml0TGFzdC5tb250aCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChkYXlPZk1vbnRoID4gZGF5c0luTW9udGggfHwgZGF5T2ZNb250aCA8PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoKCk7XG4gICAgICAgICAgICAgIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHRoaXMubGFzdC5tb250aCwgdGhpcy5sYXN0LnllYXIpO1xuICAgICAgICAgICAgICBkYXlPZk1vbnRoID0gdGhpcy5sYXN0Lm50aFdlZWtEYXkoZG93LCBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBkYXlPZk1vbnRoO1xuICAgICAgICAgIGlmICghdGVtcExhc3QgfHwgdGhpcy5sYXN0LmNvbXBhcmUodGVtcExhc3QpIDwgMCkge1xuICAgICAgICAgICAgdGVtcExhc3QgPSB0aGlzLmxhc3QuY2xvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0ID0gdGVtcExhc3QuY2xvbmUoKTtcblxuICAgICAgICAvL1hYWDogVGhpcyBmZWVscyBsaWtlIGEgaGFjaywgYnV0IHdlIG5lZWQgdG8gaW5pdGlhbGl6ZVxuICAgICAgICAvLyAgICAgdGhlIEJZTU9OVEhEQVkgY2FzZSBjb3JyZWN0bHkgYW5kIGJ5RGF5QW5kTW9udGhEYXkgaGFuZGxlc1xuICAgICAgICAvLyAgICAgdGhpcyBjYXNlLiBJdCBhY2NlcHRzIGEgc3BlY2lhbCBmbGFnIHdoaWNoIHdpbGwgYXZvaWQgaW5jcmVtZW50aW5nXG4gICAgICAgIC8vICAgICB0aGUgaW5pdGlhbCB2YWx1ZSB3aXRob3V0IHRoZSBmbGFnIGRheXMgdGhhdCBtYXRjaCB0aGUgc3RhcnQgdGltZVxuICAgICAgICAvLyAgICAgd291bGQgYmUgbWlzc2VkLlxuICAgICAgICBpZiAodGhpcy5oYXNfYnlfZGF0YSgnQllNT05USERBWScpKSB7XG4gICAgICAgICAgdGhpcy5fYnlEYXlBbmRNb250aERheSh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmxhc3QuZGF5ID4gZGF5c0luTW9udGggfHwgdGhpcy5sYXN0LmRheSA9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIHZhbHVlcyBpbiBCWURBWSBwYXJ0XCIpO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZTU9OVEhEQVlcIikpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdC5kYXkgPCAwKSB7XG4gICAgICAgICAgdmFyIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHRoaXMubGFzdC5tb250aCwgdGhpcy5sYXN0LnllYXIpO1xuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBkYXlzSW5Nb250aCArIHRoaXMubGFzdC5kYXkgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIG5leHQgb2NjdXJyZW5jZSBmcm9tIHRoZSBpdGVyYXRvci5cbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgbmV4dDogZnVuY3Rpb24gaWNhbHJlY3VyX2l0ZXJhdG9yX25leHQoKSB7XG4gICAgICB2YXIgYmVmb3JlID0gKHRoaXMubGFzdCA/IHRoaXMubGFzdC5jbG9uZSgpIDogbnVsbCk7XG5cbiAgICAgIGlmICgodGhpcy5ydWxlLmNvdW50ICYmIHRoaXMub2NjdXJyZW5jZV9udW1iZXIgPj0gdGhpcy5ydWxlLmNvdW50KSB8fFxuICAgICAgICAgICh0aGlzLnJ1bGUudW50aWwgJiYgdGhpcy5sYXN0LmNvbXBhcmUodGhpcy5ydWxlLnVudGlsKSA+IDApKSB7XG5cbiAgICAgICAgLy9YWFg6IHJpZ2h0IG5vdyB0aGlzIGlzIGp1c3QgYSBmbGFnIGFuZCBoYXMgbm8gaW1wYWN0XG4gICAgICAgIC8vICAgICB3ZSBjYW4gc2ltcGxpZnkgdGhlIGFib3ZlIGNhc2UgdG8gY2hlY2sgZm9yIGNvbXBsZXRlZCBsYXRlci5cbiAgICAgICAgdGhpcy5jb21wbGV0ZWQgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vY2N1cnJlbmNlX251bWJlciA9PSAwICYmIHRoaXMubGFzdC5jb21wYXJlKHRoaXMuZHRzdGFydCkgPj0gMCkge1xuICAgICAgICAvLyBGaXJzdCBvZiBhbGwsIGdpdmUgdGhlIGluc3RhbmNlIHRoYXQgd2FzIGluaXRpYWxpemVkXG4gICAgICAgIHRoaXMub2NjdXJyZW5jZV9udW1iZXIrKztcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdDtcbiAgICAgIH1cblxuXG4gICAgICB2YXIgdmFsaWQ7XG4gICAgICBkbyB7XG4gICAgICAgIHZhbGlkID0gMTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMucnVsZS5mcmVxKSB7XG4gICAgICAgIGNhc2UgXCJTRUNPTkRMWVwiOlxuICAgICAgICAgIHRoaXMubmV4dF9zZWNvbmQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk1JTlVURUxZXCI6XG4gICAgICAgICAgdGhpcy5uZXh0X21pbnV0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiSE9VUkxZXCI6XG4gICAgICAgICAgdGhpcy5uZXh0X2hvdXIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkRBSUxZXCI6XG4gICAgICAgICAgdGhpcy5uZXh0X2RheSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiV0VFS0xZXCI6XG4gICAgICAgICAgdGhpcy5uZXh0X3dlZWsoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk1PTlRITFlcIjpcbiAgICAgICAgICB2YWxpZCA9IHRoaXMubmV4dF9tb250aCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiWUVBUkxZXCI6XG4gICAgICAgICAgdGhpcy5uZXh0X3llYXIoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICghdGhpcy5jaGVja19jb250cmFjdGluZ19ydWxlcygpIHx8XG4gICAgICAgICAgICAgICB0aGlzLmxhc3QuY29tcGFyZSh0aGlzLmR0c3RhcnQpIDwgMCB8fFxuICAgICAgICAgICAgICAgIXZhbGlkKTtcblxuICAgICAgLy8gVE9ETyBpcyB0aGlzIHZhbGlkP1xuICAgICAgaWYgKHRoaXMubGFzdC5jb21wYXJlKGJlZm9yZSkgPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTYW1lIG9jY3VycmVuY2UgZm91bmQgdHdpY2UsIHByb3RlY3RpbmcgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ5b3UgZnJvbSBkZWF0aCBieSByZWN1cnNpb25cIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnJ1bGUudW50aWwgJiYgdGhpcy5sYXN0LmNvbXBhcmUodGhpcy5ydWxlLnVudGlsKSA+IDApIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub2NjdXJyZW5jZV9udW1iZXIrKztcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbmV4dF9zZWNvbmQ6IGZ1bmN0aW9uIG5leHRfc2Vjb25kKCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dF9nZW5lcmljKFwiQllTRUNPTkRcIiwgXCJTRUNPTkRMWVwiLCBcInNlY29uZFwiLCBcIm1pbnV0ZVwiKTtcbiAgICB9LFxuXG4gICAgaW5jcmVtZW50X3NlY29uZDogZnVuY3Rpb24gaW5jcmVtZW50X3NlY29uZChpbmMpIHtcbiAgICAgIHJldHVybiB0aGlzLmluY3JlbWVudF9nZW5lcmljKGluYywgXCJzZWNvbmRcIiwgNjAsIFwibWludXRlXCIpO1xuICAgIH0sXG5cbiAgICBuZXh0X21pbnV0ZTogZnVuY3Rpb24gbmV4dF9taW51dGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0X2dlbmVyaWMoXCJCWU1JTlVURVwiLCBcIk1JTlVURUxZXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtaW51dGVcIiwgXCJob3VyXCIsIFwibmV4dF9zZWNvbmRcIik7XG4gICAgfSxcblxuICAgIGluY3JlbWVudF9taW51dGU6IGZ1bmN0aW9uIGluY3JlbWVudF9taW51dGUoaW5jKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmNyZW1lbnRfZ2VuZXJpYyhpbmMsIFwibWludXRlXCIsIDYwLCBcImhvdXJcIik7XG4gICAgfSxcblxuICAgIG5leHRfaG91cjogZnVuY3Rpb24gbmV4dF9ob3VyKCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dF9nZW5lcmljKFwiQllIT1VSXCIsIFwiSE9VUkxZXCIsIFwiaG91clwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibW9udGhkYXlcIiwgXCJuZXh0X21pbnV0ZVwiKTtcbiAgICB9LFxuXG4gICAgaW5jcmVtZW50X2hvdXI6IGZ1bmN0aW9uIGluY3JlbWVudF9ob3VyKGluYykge1xuICAgICAgdGhpcy5pbmNyZW1lbnRfZ2VuZXJpYyhpbmMsIFwiaG91clwiLCAyNCwgXCJtb250aGRheVwiKTtcbiAgICB9LFxuXG4gICAgbmV4dF9kYXk6IGZ1bmN0aW9uIG5leHRfZGF5KCkge1xuICAgICAgdmFyIGhhc19ieV9kYXkgPSAoXCJCWURBWVwiIGluIHRoaXMuYnlfZGF0YSk7XG4gICAgICB2YXIgdGhpc19mcmVxID0gKHRoaXMucnVsZS5mcmVxID09IFwiREFJTFlcIik7XG5cbiAgICAgIGlmICh0aGlzLm5leHRfaG91cigpID09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzX2ZyZXEpIHtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRfbW9udGhkYXkodGhpcy5ydWxlLmludGVydmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoZGF5KDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgbmV4dF93ZWVrOiBmdW5jdGlvbiBuZXh0X3dlZWsoKSB7XG4gICAgICB2YXIgZW5kX29mX2RhdGEgPSAwO1xuXG4gICAgICBpZiAodGhpcy5uZXh0X3dlZWtkYXlfYnlfd2VlaygpID09IDApIHtcbiAgICAgICAgcmV0dXJuIGVuZF9vZl9kYXRhO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZV0VFS05PXCIpKSB7XG4gICAgICAgIHZhciBpZHggPSArK3RoaXMuYnlfaW5kaWNlcy5CWVdFRUtOTztcblxuICAgICAgICBpZiAodGhpcy5ieV9pbmRpY2VzLkJZV0VFS05PID09IHRoaXMuYnlfZGF0YS5CWVdFRUtOTy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmJ5X2luZGljZXMuQllXRUVLTk8gPSAwO1xuICAgICAgICAgIGVuZF9vZl9kYXRhID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhBQ0sgc2hvdWxkIGJlIGZpcnN0IG1vbnRoIG9mIHRoZSB5ZWFyXG4gICAgICAgIHRoaXMubGFzdC5tb250aCA9IDE7XG4gICAgICAgIHRoaXMubGFzdC5kYXkgPSAxO1xuXG4gICAgICAgIHZhciB3ZWVrX25vID0gdGhpcy5ieV9kYXRhLkJZV0VFS05PW3RoaXMuYnlfaW5kaWNlcy5CWVdFRUtOT107XG5cbiAgICAgICAgdGhpcy5sYXN0LmRheSArPSA3ICogd2Vla19ubztcblxuICAgICAgICBpZiAoZW5kX29mX2RhdGEpIHtcbiAgICAgICAgICB0aGlzLmluY3JlbWVudF95ZWFyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBKdW1wIHRvIHRoZSBuZXh0IHdlZWtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRfbW9udGhkYXkoNyAqIHRoaXMucnVsZS5pbnRlcnZhbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbmRfb2ZfZGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIGVhY2ggYnkgZGF5IHJ1bGUgZm9yIGEgZ2l2ZW4geWVhci9tb250aC5cbiAgICAgKiBUYWtlcyBpbnRvIGFjY291bnQgb3JkZXJpbmcgYW5kIG5lZ2F0aXZlIHJ1bGVzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyICAgICAgICAgQ3VycmVudCB5ZWFyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtb250aCAgICAgICAgQ3VycmVudCBtb250aC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgcnVsZXMgICAgICAgIEFycmF5IG9mIHJ1bGVzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXl9IHNvcnRlZCBhbmQgbm9ybWFsaXplZCBydWxlcy5cbiAgICAgKiAgICAgICAgICAgICAgICAgTmVnYXRpdmUgcnVsZXMgd2lsbCBiZSBleHBhbmRlZCB0byB0aGVpclxuICAgICAqICAgICAgICAgICAgICAgICBjb3JyZWN0IHBvc2l0aXZlIHZhbHVlcyBmb3IgZWFzaWVyIHByb2Nlc3NpbmcuXG4gICAgICovXG4gICAgbm9ybWFsaXplQnlNb250aERheVJ1bGVzOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgcnVsZXMpIHtcbiAgICAgIHZhciBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aChtb250aCwgeWVhcik7XG5cbiAgICAgIC8vIFhYWDogVGhpcyBpcyBwcm9iYWJseSBiYWQgZm9yIHBlcmZvcm1hbmNlIHRvIGFsbG9jYXRlXG4gICAgICAvLyAgICAgIGEgbmV3IGFycmF5IGZvciBlYWNoIG1vbnRoIHdlIHNjYW4sIGlmIHBvc3NpYmxlXG4gICAgICAvLyAgICAgIHdlIHNob3VsZCB0cnkgdG8gb3B0aW1pemUgdGhpcy4uLlxuICAgICAgdmFyIG5ld1J1bGVzID0gW107XG5cbiAgICAgIHZhciBydWxlSWR4ID0gMDtcbiAgICAgIHZhciBsZW4gPSBydWxlcy5sZW5ndGg7XG4gICAgICB2YXIgcnVsZTtcblxuICAgICAgZm9yICg7IHJ1bGVJZHggPCBsZW47IHJ1bGVJZHgrKykge1xuICAgICAgICBydWxlID0gcnVsZXNbcnVsZUlkeF07XG5cbiAgICAgICAgLy8gaWYgdGhpcyBydWxlIGZhbGxzIG91dHNpZGUgb2YgZ2l2ZW5cbiAgICAgICAgLy8gbW9udGggZGlzY2FyZCBpdC5cbiAgICAgICAgaWYgKE1hdGguYWJzKHJ1bGUpID4gZGF5c0luTW9udGgpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5lZ2F0aXZlIGNhc2VcbiAgICAgICAgaWYgKHJ1bGUgPCAwKSB7XG4gICAgICAgICAgLy8gd2UgYWRkIChub3Qgc3VidHJhY3QgaXQgaXMgYSBuZWdhdGl2ZSBudW1iZXIpXG4gICAgICAgICAgLy8gb25lIGZyb20gdGhlIHJ1bGUgYmVjYXVzZSAxID09PSBsYXN0IGRheSBvZiBtb250aFxuICAgICAgICAgIHJ1bGUgPSBkYXlzSW5Nb250aCArIChydWxlICsgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAocnVsZSA9PT0gMCkge1xuICAgICAgICAgIC8vIHNraXAgemVybzogaXQgaXMgaW52YWxpZC5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9ubHkgYWRkIHVuaXF1ZSBpdGVtcy4uLlxuICAgICAgICBpZiAobmV3UnVsZXMuaW5kZXhPZihydWxlKSA9PT0gLTEpIHtcbiAgICAgICAgICBuZXdSdWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgLy8gdW5pcXVlIGFuZCBzb3J0XG4gICAgICByZXR1cm4gbmV3UnVsZXMuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5PVEVTOlxuICAgICAqIFdlIGFyZSBnaXZlbiBhIGxpc3Qgb2YgZGF0ZXMgaW4gdGhlIG1vbnRoIChCWU1PTlRIREFZKSAoMjMsIGV0Yy4uKVxuICAgICAqIEFsc28gd2UgYXJlIGdpdmVuIGEgbGlzdCBvZiBkYXlzIChCWURBWSkgKE1PLCAyU1UsIGV0Yy4uKSB3aGVuXG4gICAgICogYm90aCBjb25kaXRpb25zIG1hdGNoIGEgZ2l2ZW4gZGF0ZSAodGhpcy5sYXN0LmRheSkgaXRlcmF0aW9uIHN0b3BzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBpc0luaXQgICAgIFdoZW4gZ2l2ZW4gdHJ1ZSB3aWxsIG5vdCBpbmNyZW1lbnQgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgZGF5ICh0aGlzLmxhc3QpLlxuICAgICAqL1xuICAgIF9ieURheUFuZE1vbnRoRGF5OiBmdW5jdGlvbihpc0luaXQpIHtcbiAgICAgIHZhciBieU1vbnRoRGF5OyAvLyBzZXR1cCBpbiBpbml0TW9udGhcbiAgICAgIHZhciBieURheSA9IHRoaXMuYnlfZGF0YS5CWURBWTtcblxuICAgICAgdmFyIGRhdGU7XG4gICAgICB2YXIgZGF0ZUlkeCA9IDA7XG4gICAgICB2YXIgZGF0ZUxlbjsgLy8gc2V0dXAgaW4gaW5pdE1vbnRoXG4gICAgICB2YXIgZGF5TGVuID0gYnlEYXkubGVuZ3RoO1xuXG4gICAgICAvLyB3ZSBhcmUgbm90IHZhbGlkIGJ5IGRlZmF1bHRcbiAgICAgIHZhciBkYXRhSXNWYWxpZCA9IDA7XG5cbiAgICAgIHZhciBkYXlzSW5Nb250aDtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIC8vIHdlIG5lZWQgYSBjb3B5IG9mIHRoaXMsIGJlY2F1c2UgYSBEYXRlVGltZSBnZXRzIG5vcm1hbGl6ZWRcbiAgICAgIC8vIGF1dG9tYXRpY2FsbHkgaWYgdGhlIGRheSBpcyBvdXQgb2YgcmFuZ2UuIEF0IHNvbWUgcG9pbnRzIHdlXG4gICAgICAvLyBzZXQgdGhlIGxhc3QgZGF5IHRvIDAgdG8gc3RhcnQgY291bnRpbmcuXG4gICAgICB2YXIgbGFzdERheSA9IHRoaXMubGFzdC5kYXk7XG5cbiAgICAgIGZ1bmN0aW9uIGluaXRNb250aCgpIHtcbiAgICAgICAgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgoXG4gICAgICAgICAgc2VsZi5sYXN0Lm1vbnRoLCBzZWxmLmxhc3QueWVhclxuICAgICAgICApO1xuXG4gICAgICAgIGJ5TW9udGhEYXkgPSBzZWxmLm5vcm1hbGl6ZUJ5TW9udGhEYXlSdWxlcyhcbiAgICAgICAgICBzZWxmLmxhc3QueWVhcixcbiAgICAgICAgICBzZWxmLmxhc3QubW9udGgsXG4gICAgICAgICAgc2VsZi5ieV9kYXRhLkJZTU9OVEhEQVlcbiAgICAgICAgKTtcblxuICAgICAgICBkYXRlTGVuID0gYnlNb250aERheS5sZW5ndGg7XG5cbiAgICAgICAgLy8gRm9yIHRoZSBjYXNlIG9mIG1vcmUgdGhhbiBvbmUgb2NjdXJyZW5jZSBpbiBvbmUgbW9udGhcbiAgICAgICAgLy8gd2UgaGF2ZSB0byBiZSBzdXJlIHRvIHN0YXJ0IHNlYXJjaGluZyBhZnRlciB0aGUgbGFzdFxuICAgICAgICAvLyBmb3VuZCBkYXRlIG9yIGF0IHRoZSBsYXN0IEJZTU9OVEhEQVksIHVubGVzcyB3ZSBhcmVcbiAgICAgICAgLy8gaW5pdGlhbGl6aW5nIHRoZSBpdGVyYXRvciBiZWNhdXNlIGluIHRoaXMgY2FzZSB3ZSBoYXZlXG4gICAgICAgIC8vIHRvIGNvbnNpZGVyIHRoZSBsYXN0IGZvdW5kIGRhdGUgdG9vLlxuICAgICAgICB3aGlsZSAoYnlNb250aERheVtkYXRlSWR4XSA8PSBsYXN0RGF5ICYmXG4gICAgICAgICAgICAgICAhKGlzSW5pdCAmJiBieU1vbnRoRGF5W2RhdGVJZHhdID09IGxhc3REYXkpICYmXG4gICAgICAgICAgICAgICBkYXRlSWR4IDwgZGF0ZUxlbiAtIDEpIHtcbiAgICAgICAgICBkYXRlSWR4Kys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbmV4dE1vbnRoKCkge1xuICAgICAgICAvLyBzaW5jZSB0aGUgZGF5IGlzIGluY3JlbWVudGVkIGF0IHRoZSBzdGFydFxuICAgICAgICAvLyBvZiB0aGUgbG9vcCBiZWxvdywgd2UgbmVlZCB0byBzdGFydCBhdCAwXG4gICAgICAgIGxhc3REYXkgPSAwO1xuICAgICAgICBzZWxmLmluY3JlbWVudF9tb250aCgpO1xuICAgICAgICBkYXRlSWR4ID0gMDtcbiAgICAgICAgaW5pdE1vbnRoKCk7XG4gICAgICB9XG5cbiAgICAgIGluaXRNb250aCgpO1xuXG4gICAgICAvLyBzaG91bGQgY29tZSBhZnRlciBpbml0TW9udGhcbiAgICAgIGlmIChpc0luaXQpIHtcbiAgICAgICAgbGFzdERheSAtPSAxO1xuICAgICAgfVxuXG4gICAgICAvLyBVc2UgYSBjb3VudGVyIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3Agd2l0aCBtYWxmb3JtZWQgcnVsZXMuXG4gICAgICAvLyBTdG9wIGNoZWNraW5nIGFmdGVyIDQgeWVhcnMgc28gd2UgY29uc2lkZXIgYWxzbyBhIGxlYXAgeWVhci5cbiAgICAgIHZhciBtb250aHNDb3VudGVyID0gNDg7XG5cbiAgICAgIHdoaWxlICghZGF0YUlzVmFsaWQgJiYgbW9udGhzQ291bnRlcikge1xuICAgICAgICBtb250aHNDb3VudGVyLS07XG4gICAgICAgIC8vIGluY3JlbWVudCB0aGUgY3VycmVudCBkYXRlLiBUaGlzIGlzIHJlYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgb3RoZXJ3aXNlIHdlIG1heSBmYWxsIGludG8gdGhlIGluZmluaXRlXG4gICAgICAgIC8vIGxvb3AgdHJhcC4gVGhlIGluaXRpYWwgZGF0ZSB0YWtlcyBjYXJlIG9mIHRoZSBjYXNlXG4gICAgICAgIC8vIHdoZXJlIHRoZSBjdXJyZW50IGRhdGUgaXMgdGhlIGRhdGUgd2UgYXJlIGxvb2tpbmdcbiAgICAgICAgLy8gZm9yLlxuICAgICAgICBkYXRlID0gbGFzdERheSArIDE7XG5cbiAgICAgICAgaWYgKGRhdGUgPiBkYXlzSW5Nb250aCkge1xuICAgICAgICAgIG5leHRNb250aCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCBuZXh0IGRhdGVcbiAgICAgICAgdmFyIG5leHQgPSBieU1vbnRoRGF5W2RhdGVJZHgrK107XG5cbiAgICAgICAgLy8gdGhpcyBsb2dpYyBpcyBkZXBlbmRhbnQgb24gdGhlIEJZTU9OVEhEQVlTXG4gICAgICAgIC8vIGJlaW5nIGluIG9yZGVyICh3aGljaCBpcyBkb25lIGJ5ICNub3JtYWxpemVCeU1vbnRoRGF5UnVsZXMpXG4gICAgICAgIGlmIChuZXh0ID49IGRhdGUpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgbmV4dCBtb250aCBkYXkgaXMgaW4gdGhlIGZ1dHVyZSBqdW1wIHRvIGl0LlxuICAgICAgICAgIGxhc3REYXkgPSBuZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGluIHRoaXMgY2FzZSB0aGUgJ25leHQnIG1vbnRoZGF5IGhhcyBwYXN0XG4gICAgICAgICAgLy8gd2UgbXVzdCBtb3ZlIHRvIHRoZSBtb250aC5cbiAgICAgICAgICBuZXh0TW9udGgoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdyB3ZSBjYW4gbG9vcCB0aHJvdWdoIHRoZSBkYXkgcnVsZXMgdG8gc2VlXG4gICAgICAgIC8vIGlmIG9uZSBtYXRjaGVzIHRoZSBjdXJyZW50IG1vbnRoIGRhdGUuXG4gICAgICAgIGZvciAodmFyIGRheUlkeCA9IDA7IGRheUlkeCA8IGRheUxlbjsgZGF5SWR4KyspIHtcbiAgICAgICAgICB2YXIgcGFydHMgPSB0aGlzLnJ1bGVEYXlPZldlZWsoYnlEYXlbZGF5SWR4XSk7XG4gICAgICAgICAgdmFyIHBvcyA9IHBhcnRzWzBdO1xuICAgICAgICAgIHZhciBkb3cgPSBwYXJ0c1sxXTtcblxuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBsYXN0RGF5O1xuICAgICAgICAgIGlmICh0aGlzLmxhc3QuaXNOdGhXZWVrRGF5KGRvdywgcG9zKSkge1xuICAgICAgICAgICAgLy8gd2hlbiB3ZSBmaW5kIHRoZSB2YWxpZCBvbmUgd2UgY2FuIG1hcmtcbiAgICAgICAgICAgIC8vIHRoZSBjb25kaXRpb25zIGFzIG1ldCBhbmQgYnJlYWsgdGhlIGxvb3AuXG4gICAgICAgICAgICAvLyAoQmVjYXVzZSB3ZSBoYXZlIHRoaXMgY29uZGl0aW9uIGFib3ZlXG4gICAgICAgICAgICAvLyAgaXQgd2lsbCBhbHNvIGJyZWFrIHRoZSBwYXJlbnQgbG9vcCkuXG4gICAgICAgICAgICBkYXRhSXNWYWxpZCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJdCBpcyBjb21wbGV0ZWx5IHBvc3NpYmxlIHRoYXQgdGhlIGNvbWJpbmF0aW9uXG4gICAgICAgIC8vIGNhbm5vdCBiZSBtYXRjaGVkIGluIHRoZSBjdXJyZW50IG1vbnRoLlxuICAgICAgICAvLyBXaGVuIHdlIHJlYWNoIHRoZSBlbmQgb2YgcG9zc2libGUgY29tYmluYXRpb25zXG4gICAgICAgIC8vIGluIHRoZSBjdXJyZW50IG1vbnRoIHdlIGl0ZXJhdGUgdG8gdGhlIG5leHQgb25lLlxuICAgICAgICAvLyBzaW5jZSBkYXRlSWR4IGlzIGluY3JlbWVudGVkIHJpZ2h0IGFmdGVyIGdldHRpbmdcbiAgICAgICAgLy8gXCJuZXh0XCIsIHdlIGRvbid0IG5lZWQgZGF0ZUxlbiAtMSBoZXJlLlxuICAgICAgICBpZiAoIWRhdGFJc1ZhbGlkICYmIGRhdGVJZHggPT09IGRhdGVMZW4pIHtcbiAgICAgICAgICBuZXh0TW9udGgoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobW9udGhzQ291bnRlciA8PSAwKSB7XG4gICAgICAgIC8vIENoZWNrZWQgNCB5ZWFycyB3aXRob3V0IGZpbmRpbmcgYSBCeWRheSB0aGF0IG1hdGNoZXNcbiAgICAgICAgLy8gYSBCeW1vbnRoZGF5LiBNYXliZSB0aGUgcnVsZSBpcyBub3QgY29ycmVjdC5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIHZhbHVlcyBpbiBCWURBWSBjb21iaW5lZCB3aXRoIEJZTU9OVEhEQVkgcGFydHNcIik7XG4gICAgICB9XG5cblxuICAgICAgcmV0dXJuIGRhdGFJc1ZhbGlkO1xuICAgIH0sXG5cbiAgICBuZXh0X21vbnRoOiBmdW5jdGlvbiBuZXh0X21vbnRoKCkge1xuICAgICAgdmFyIHRoaXNfZnJlcSA9ICh0aGlzLnJ1bGUuZnJlcSA9PSBcIk1PTlRITFlcIik7XG4gICAgICB2YXIgZGF0YV92YWxpZCA9IDE7XG5cbiAgICAgIGlmICh0aGlzLm5leHRfaG91cigpID09IDApIHtcbiAgICAgICAgcmV0dXJuIGRhdGFfdmFsaWQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllEQVlcIikgJiYgdGhpcy5oYXNfYnlfZGF0YShcIkJZTU9OVEhEQVlcIikpIHtcbiAgICAgICAgZGF0YV92YWxpZCA9IHRoaXMuX2J5RGF5QW5kTW9udGhEYXkoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZREFZXCIpKSB7XG4gICAgICAgIHZhciBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aCh0aGlzLmxhc3QubW9udGgsIHRoaXMubGFzdC55ZWFyKTtcbiAgICAgICAgdmFyIHNldHBvcyA9IDA7XG4gICAgICAgIHZhciBzZXRwb3NfdG90YWwgPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllTRVRQT1NcIikpIHtcbiAgICAgICAgICB2YXIgbGFzdF9kYXkgPSB0aGlzLmxhc3QuZGF5O1xuICAgICAgICAgIGZvciAodmFyIGRheSA9IDE7IGRheSA8PSBkYXlzSW5Nb250aDsgZGF5KyspIHtcbiAgICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBkYXk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc19kYXlfaW5fYnlkYXkodGhpcy5sYXN0KSkge1xuICAgICAgICAgICAgICBzZXRwb3NfdG90YWwrKztcbiAgICAgICAgICAgICAgaWYgKGRheSA8PSBsYXN0X2RheSkge1xuICAgICAgICAgICAgICAgIHNldHBvcysrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBsYXN0X2RheTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFfdmFsaWQgPSAwO1xuICAgICAgICBmb3IgKHZhciBkYXkgPSB0aGlzLmxhc3QuZGF5ICsgMTsgZGF5IDw9IGRheXNJbk1vbnRoOyBkYXkrKykge1xuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBkYXk7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc19kYXlfaW5fYnlkYXkodGhpcy5sYXN0KSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc19ieV9kYXRhKFwiQllTRVRQT1NcIikgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrX3NldF9wb3NpdGlvbigrK3NldHBvcykgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrX3NldF9wb3NpdGlvbihzZXRwb3MgLSBzZXRwb3NfdG90YWwgLSAxKSkge1xuXG4gICAgICAgICAgICAgIGRhdGFfdmFsaWQgPSAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF5ID4gZGF5c0luTW9udGgpIHtcbiAgICAgICAgICB0aGlzLmxhc3QuZGF5ID0gMTtcbiAgICAgICAgICB0aGlzLmluY3JlbWVudF9tb250aCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaXNfZGF5X2luX2J5ZGF5KHRoaXMubGFzdCkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNfYnlfZGF0YShcIkJZU0VUUE9TXCIpIHx8IHRoaXMuY2hlY2tfc2V0X3Bvc2l0aW9uKDEpKSB7XG4gICAgICAgICAgICAgIGRhdGFfdmFsaWQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhX3ZhbGlkID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZTU9OVEhEQVlcIikpIHtcbiAgICAgICAgdGhpcy5ieV9pbmRpY2VzLkJZTU9OVEhEQVkrKztcblxuICAgICAgICBpZiAodGhpcy5ieV9pbmRpY2VzLkJZTU9OVEhEQVkgPj0gdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5ieV9pbmRpY2VzLkJZTU9OVEhEQVkgPSAwO1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodGhpcy5sYXN0Lm1vbnRoLCB0aGlzLmxhc3QueWVhcik7XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLmJ5X2RhdGEuQllNT05USERBWVt0aGlzLmJ5X2luZGljZXMuQllNT05USERBWV07XG5cbiAgICAgICAgaWYgKGRheSA8IDApIHtcbiAgICAgICAgICBkYXkgPSBkYXlzSW5Nb250aCArIGRheSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF5ID4gZGF5c0luTW9udGgpIHtcbiAgICAgICAgICB0aGlzLmxhc3QuZGF5ID0gMTtcbiAgICAgICAgICBkYXRhX3ZhbGlkID0gdGhpcy5pc19kYXlfaW5fYnlkYXkodGhpcy5sYXN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxhc3QuZGF5ID0gZGF5O1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoKCk7XG4gICAgICAgIHZhciBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aCh0aGlzLmxhc3QubW9udGgsIHRoaXMubGFzdC55ZWFyKTtcbiAgICAgICAgaWYgKHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZWzBdID4gZGF5c0luTW9udGgpIHtcbiAgICAgICAgICBkYXRhX3ZhbGlkID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxhc3QuZGF5ID0gdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVlbMF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGFfdmFsaWQ7XG4gICAgfSxcblxuICAgIG5leHRfd2Vla2RheV9ieV93ZWVrOiBmdW5jdGlvbiBuZXh0X3dlZWtkYXlfYnlfd2VlaygpIHtcbiAgICAgIHZhciBlbmRfb2ZfZGF0YSA9IDA7XG5cbiAgICAgIGlmICh0aGlzLm5leHRfaG91cigpID09IDApIHtcbiAgICAgICAgcmV0dXJuIGVuZF9vZl9kYXRhO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaGFzX2J5X2RhdGEoXCJCWURBWVwiKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICB2YXIgdHQgPSBuZXcgSUNBTC5UaW1lKCk7XG4gICAgICAgIHRoaXMuYnlfaW5kaWNlcy5CWURBWSsrO1xuXG4gICAgICAgIGlmICh0aGlzLmJ5X2luZGljZXMuQllEQVkgPT0gT2JqZWN0LmtleXModGhpcy5ieV9kYXRhLkJZREFZKS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmJ5X2luZGljZXMuQllEQVkgPSAwO1xuICAgICAgICAgIGVuZF9vZl9kYXRhID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2RlZF9kYXkgPSB0aGlzLmJ5X2RhdGEuQllEQVlbdGhpcy5ieV9pbmRpY2VzLkJZREFZXTtcbiAgICAgICAgdmFyIHBhcnRzID0gdGhpcy5ydWxlRGF5T2ZXZWVrKGNvZGVkX2RheSk7XG4gICAgICAgIHZhciBkb3cgPSBwYXJ0c1sxXTtcblxuICAgICAgICBkb3cgLT0gdGhpcy5ydWxlLndrc3Q7XG5cbiAgICAgICAgaWYgKGRvdyA8IDApIHtcbiAgICAgICAgICBkb3cgKz0gNztcbiAgICAgICAgfVxuXG4gICAgICAgIHR0LnllYXIgPSB0aGlzLmxhc3QueWVhcjtcbiAgICAgICAgdHQubW9udGggPSB0aGlzLmxhc3QubW9udGg7XG4gICAgICAgIHR0LmRheSA9IHRoaXMubGFzdC5kYXk7XG5cbiAgICAgICAgdmFyIHN0YXJ0T2ZXZWVrID0gdHQuc3RhcnREb3lXZWVrKHRoaXMucnVsZS53a3N0KTtcblxuICAgICAgICBpZiAoZG93ICsgc3RhcnRPZldlZWsgPCAxKSB7XG4gICAgICAgICAgLy8gVGhlIHNlbGVjdGVkIGRhdGUgaXMgaW4gdGhlIHByZXZpb3VzIHllYXJcbiAgICAgICAgICBpZiAoIWVuZF9vZl9kYXRhKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dCA9IElDQUwuVGltZS5mcm9tRGF5T2ZZZWFyKHN0YXJ0T2ZXZWVrICsgZG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3QueWVhcik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBub3JtYWxpemF0aW9uIGhvcnJvcnMgYmVsb3cgYXJlIGR1ZSB0b1xuICAgICAgICAgKiB0aGUgZmFjdCB0aGF0IHdoZW4gdGhlIHllYXIvbW9udGgvZGF5IGNoYW5nZXNcbiAgICAgICAgICogaXQgY2FuIGVmZmVjdCB0aGUgb3RoZXIgb3BlcmF0aW9ucyB0aGF0IGNvbWUgYWZ0ZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3QueWVhciA9IG5leHQueWVhcjtcbiAgICAgICAgdGhpcy5sYXN0Lm1vbnRoID0gbmV4dC5tb250aDtcbiAgICAgICAgdGhpcy5sYXN0LmRheSA9IG5leHQuZGF5O1xuXG4gICAgICAgIHJldHVybiBlbmRfb2ZfZGF0YTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbmV4dF95ZWFyOiBmdW5jdGlvbiBuZXh0X3llYXIoKSB7XG5cbiAgICAgIGlmICh0aGlzLm5leHRfaG91cigpID09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmICgrK3RoaXMuZGF5c19pbmRleCA9PSB0aGlzLmRheXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZGF5c19pbmRleCA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB0aGlzLmluY3JlbWVudF95ZWFyKHRoaXMucnVsZS5pbnRlcnZhbCk7XG4gICAgICAgICAgdGhpcy5leHBhbmRfeWVhcl9kYXlzKHRoaXMubGFzdC55ZWFyKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5kYXlzLmxlbmd0aCA9PSAwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbmV4dEJ5WWVhckRheSgpO1xuXG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuXG4gICAgX25leHRCeVllYXJEYXk6IGZ1bmN0aW9uIF9uZXh0QnlZZWFyRGF5KCkge1xuICAgICAgICB2YXIgZG95ID0gdGhpcy5kYXlzW3RoaXMuZGF5c19pbmRleF07XG4gICAgICAgIHZhciB5ZWFyID0gdGhpcy5sYXN0LnllYXI7XG4gICAgICAgIGlmIChkb3kgPCAxKSB7XG4gICAgICAgICAgICAvLyBUaW1lLmZyb21EYXlPZlllYXIoZG95LCB5ZWFyKSBpbmRleGVzIHJlbGF0aXZlIHRvIHRoZVxuICAgICAgICAgICAgLy8gc3RhcnQgb2YgdGhlIGdpdmVuIHllYXIuIFRoYXQgaXMgZGlmZmVyZW50IGZyb20gdGhlXG4gICAgICAgICAgICAvLyBzZW1hbnRpY3Mgb2YgQllZRUFSREFZIHdoZXJlIG5lZ2F0aXZlIGluZGV4ZXMgYXJlIGFuXG4gICAgICAgICAgICAvLyBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBnaXZlbiB5ZWFyLlxuICAgICAgICAgICAgZG95ICs9IDE7XG4gICAgICAgICAgICB5ZWFyICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHQgPSBJQ0FMLlRpbWUuZnJvbURheU9mWWVhcihkb3ksIHllYXIpO1xuICAgICAgICB0aGlzLmxhc3QuZGF5ID0gbmV4dC5kYXk7XG4gICAgICAgIHRoaXMubGFzdC5tb250aCA9IG5leHQubW9udGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkb3cgKGVnOiAnMVRVJywgJy0xTU8nKVxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lLndlZWtEYXk9fSBhV2Vla1N0YXJ0IFRoZSB3ZWVrIHN0YXJ0IHdlZWtkYXlcbiAgICAgKiBAcmV0dXJuIFtwb3MsIG51bWVyaWNEb3ddIChlZzogWzEsIDNdKSBudW1lcmljRG93IGlzIHJlbGF0aXZlIHRvIGFXZWVrU3RhcnRcbiAgICAgKi9cbiAgICBydWxlRGF5T2ZXZWVrOiBmdW5jdGlvbiBydWxlRGF5T2ZXZWVrKGRvdywgYVdlZWtTdGFydCkge1xuICAgICAgdmFyIG1hdGNoZXMgPSBkb3cubWF0Y2goLyhbKy1dP1swLTldKT8oTU98VFV8V0V8VEh8RlJ8U0F8U1UpLyk7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICB2YXIgcG9zID0gcGFyc2VJbnQobWF0Y2hlc1sxXSB8fCAwLCAxMCk7XG4gICAgICAgIGRvdyA9IElDQUwuUmVjdXIuaWNhbERheVRvTnVtZXJpY0RheShtYXRjaGVzWzJdLCBhV2Vla1N0YXJ0KTtcbiAgICAgICAgcmV0dXJuIFtwb3MsIGRvd107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBuZXh0X2dlbmVyaWM6IGZ1bmN0aW9uIG5leHRfZ2VuZXJpYyhhUnVsZVR5cGUsIGFJbnRlcnZhbCwgYURhdGVBdHRyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFGb2xsb3dpbmdBdHRyLCBhUHJldmlvdXNJbmNyKSB7XG4gICAgICB2YXIgaGFzX2J5X3J1bGUgPSAoYVJ1bGVUeXBlIGluIHRoaXMuYnlfZGF0YSk7XG4gICAgICB2YXIgdGhpc19mcmVxID0gKHRoaXMucnVsZS5mcmVxID09IGFJbnRlcnZhbCk7XG4gICAgICB2YXIgZW5kX29mX2RhdGEgPSAwO1xuXG4gICAgICBpZiAoYVByZXZpb3VzSW5jciAmJiB0aGlzW2FQcmV2aW91c0luY3JdKCkgPT0gMCkge1xuICAgICAgICByZXR1cm4gZW5kX29mX2RhdGE7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNfYnlfcnVsZSkge1xuICAgICAgICB0aGlzLmJ5X2luZGljZXNbYVJ1bGVUeXBlXSsrO1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5ieV9pbmRpY2VzW2FSdWxlVHlwZV07XG4gICAgICAgIHZhciBkdGEgPSB0aGlzLmJ5X2RhdGFbYVJ1bGVUeXBlXTtcblxuICAgICAgICBpZiAodGhpcy5ieV9pbmRpY2VzW2FSdWxlVHlwZV0gPT0gZHRhLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuYnlfaW5kaWNlc1thUnVsZVR5cGVdID0gMDtcbiAgICAgICAgICBlbmRfb2ZfZGF0YSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0W2FEYXRlQXR0cl0gPSBkdGFbdGhpcy5ieV9pbmRpY2VzW2FSdWxlVHlwZV1dO1xuICAgICAgfSBlbHNlIGlmICh0aGlzX2ZyZXEpIHtcbiAgICAgICAgdGhpc1tcImluY3JlbWVudF9cIiArIGFEYXRlQXR0cl0odGhpcy5ydWxlLmludGVydmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc19ieV9ydWxlICYmIGVuZF9vZl9kYXRhICYmIHRoaXNfZnJlcSkge1xuICAgICAgICB0aGlzW1wiaW5jcmVtZW50X1wiICsgYUZvbGxvd2luZ0F0dHJdKDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZW5kX29mX2RhdGE7XG4gICAgfSxcblxuICAgIGluY3JlbWVudF9tb250aGRheTogZnVuY3Rpb24gaW5jcmVtZW50X21vbnRoZGF5KGluYykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmM7IGkrKykge1xuICAgICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodGhpcy5sYXN0Lm1vbnRoLCB0aGlzLmxhc3QueWVhcik7XG4gICAgICAgIHRoaXMubGFzdC5kYXkrKztcblxuICAgICAgICBpZiAodGhpcy5sYXN0LmRheSA+IGRheXNJbk1vbnRoKSB7XG4gICAgICAgICAgdGhpcy5sYXN0LmRheSAtPSBkYXlzSW5Nb250aDtcbiAgICAgICAgICB0aGlzLmluY3JlbWVudF9tb250aCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGluY3JlbWVudF9tb250aDogZnVuY3Rpb24gaW5jcmVtZW50X21vbnRoKCkge1xuICAgICAgdGhpcy5sYXN0LmRheSA9IDE7XG4gICAgICBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZTU9OVEhcIikpIHtcbiAgICAgICAgdGhpcy5ieV9pbmRpY2VzLkJZTU9OVEgrKztcblxuICAgICAgICBpZiAodGhpcy5ieV9pbmRpY2VzLkJZTU9OVEggPT0gdGhpcy5ieV9kYXRhLkJZTU9OVEgubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5ieV9pbmRpY2VzLkJZTU9OVEggPSAwO1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50X3llYXIoMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3QubW9udGggPSB0aGlzLmJ5X2RhdGEuQllNT05USFt0aGlzLmJ5X2luZGljZXMuQllNT05USF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5ydWxlLmZyZXEgPT0gXCJNT05USExZXCIpIHtcbiAgICAgICAgICB0aGlzLmxhc3QubW9udGggKz0gdGhpcy5ydWxlLmludGVydmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubGFzdC5tb250aCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0Lm1vbnRoLS07XG4gICAgICAgIHZhciB5ZWFycyA9IElDQUwuaGVscGVycy50cnVuYyh0aGlzLmxhc3QubW9udGggLyAxMik7XG4gICAgICAgIHRoaXMubGFzdC5tb250aCAlPSAxMjtcbiAgICAgICAgdGhpcy5sYXN0Lm1vbnRoKys7XG5cbiAgICAgICAgaWYgKHllYXJzICE9IDApIHtcbiAgICAgICAgICB0aGlzLmluY3JlbWVudF95ZWFyKHllYXJzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBpbmNyZW1lbnRfeWVhcjogZnVuY3Rpb24gaW5jcmVtZW50X3llYXIoaW5jKSB7XG4gICAgICB0aGlzLmxhc3QueWVhciArPSBpbmM7XG4gICAgfSxcblxuICAgIGluY3JlbWVudF9nZW5lcmljOiBmdW5jdGlvbiBpbmNyZW1lbnRfZ2VuZXJpYyhpbmMsIGFEYXRlQXR0cixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUZhY3RvciwgYU5leHRJbmNyZW1lbnQpIHtcbiAgICAgIHRoaXMubGFzdFthRGF0ZUF0dHJdICs9IGluYztcbiAgICAgIHZhciBuZXh0dW5pdCA9IElDQUwuaGVscGVycy50cnVuYyh0aGlzLmxhc3RbYURhdGVBdHRyXSAvIGFGYWN0b3IpO1xuICAgICAgdGhpcy5sYXN0W2FEYXRlQXR0cl0gJT0gYUZhY3RvcjtcbiAgICAgIGlmIChuZXh0dW5pdCAhPSAwKSB7XG4gICAgICAgIHRoaXNbXCJpbmNyZW1lbnRfXCIgKyBhTmV4dEluY3JlbWVudF0obmV4dHVuaXQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBoYXNfYnlfZGF0YTogZnVuY3Rpb24gaGFzX2J5X2RhdGEoYVJ1bGVUeXBlKSB7XG4gICAgICByZXR1cm4gKGFSdWxlVHlwZSBpbiB0aGlzLnJ1bGUucGFydHMpO1xuICAgIH0sXG5cbiAgICBleHBhbmRfeWVhcl9kYXlzOiBmdW5jdGlvbiBleHBhbmRfeWVhcl9kYXlzKGFZZWFyKSB7XG4gICAgICB2YXIgdCA9IG5ldyBJQ0FMLlRpbWUoKTtcbiAgICAgIHRoaXMuZGF5cyA9IFtdO1xuXG4gICAgICAvLyBXZSBuZWVkIG91ciBvd24gY29weSB3aXRoIGEgZmV3IGtleXMgc2V0XG4gICAgICB2YXIgcGFydHMgPSB7fTtcbiAgICAgIHZhciBydWxlcyA9IFtcIkJZREFZXCIsIFwiQllXRUVLTk9cIiwgXCJCWU1PTlRIREFZXCIsIFwiQllNT05USFwiLCBcIkJZWUVBUkRBWVwiXTtcbiAgICAgIGZvciAodmFyIHAgaW4gcnVsZXMpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHJ1bGVzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgdmFyIHBhcnQgPSBydWxlc1twXTtcbiAgICAgICAgICBpZiAocGFydCBpbiB0aGlzLnJ1bGUucGFydHMpIHtcbiAgICAgICAgICAgIHBhcnRzW3BhcnRdID0gdGhpcy5ydWxlLnBhcnRzW3BhcnRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoXCJCWU1PTlRIXCIgaW4gcGFydHMgJiYgXCJCWVdFRUtOT1wiIGluIHBhcnRzKSB7XG4gICAgICAgIHZhciB2YWxpZCA9IDE7XG4gICAgICAgIHZhciB2YWxpZFdlZWtzID0ge307XG4gICAgICAgIHQueWVhciA9IGFZZWFyO1xuICAgICAgICB0LmlzRGF0ZSA9IHRydWU7XG5cbiAgICAgICAgZm9yICh2YXIgbW9udGhJZHggPSAwOyBtb250aElkeCA8IHRoaXMuYnlfZGF0YS5CWU1PTlRILmxlbmd0aDsgbW9udGhJZHgrKykge1xuICAgICAgICAgIHZhciBtb250aCA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIW21vbnRoSWR4XTtcbiAgICAgICAgICB0Lm1vbnRoID0gbW9udGg7XG4gICAgICAgICAgdC5kYXkgPSAxO1xuICAgICAgICAgIHZhciBmaXJzdF93ZWVrID0gdC53ZWVrTnVtYmVyKHRoaXMucnVsZS53a3N0KTtcbiAgICAgICAgICB0LmRheSA9IElDQUwuVGltZS5kYXlzSW5Nb250aChtb250aCwgYVllYXIpO1xuICAgICAgICAgIHZhciBsYXN0X3dlZWsgPSB0LndlZWtOdW1iZXIodGhpcy5ydWxlLndrc3QpO1xuICAgICAgICAgIGZvciAobW9udGhJZHggPSBmaXJzdF93ZWVrOyBtb250aElkeCA8IGxhc3Rfd2VlazsgbW9udGhJZHgrKykge1xuICAgICAgICAgICAgdmFsaWRXZWVrc1ttb250aElkeF0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHdlZWtJZHggPSAwOyB3ZWVrSWR4IDwgdGhpcy5ieV9kYXRhLkJZV0VFS05PLmxlbmd0aCAmJiB2YWxpZDsgd2Vla0lkeCsrKSB7XG4gICAgICAgICAgdmFyIHdlZWtubyA9IHRoaXMuYnlfZGF0YS5CWVdFRUtOT1t3ZWVrSWR4XTtcbiAgICAgICAgICBpZiAod2Vla25vIDwgNTIpIHtcbiAgICAgICAgICAgIHZhbGlkICY9IHZhbGlkV2Vla3Nbd2Vla0lkeF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICBkZWxldGUgcGFydHMuQllNT05USDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgcGFydHMuQllXRUVLTk87XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHBhcnRDb3VudCA9IE9iamVjdC5rZXlzKHBhcnRzKS5sZW5ndGg7XG5cbiAgICAgIGlmIChwYXJ0Q291bnQgPT0gMCkge1xuICAgICAgICB2YXIgdDEgPSB0aGlzLmR0c3RhcnQuY2xvbmUoKTtcbiAgICAgICAgdDEueWVhciA9IHRoaXMubGFzdC55ZWFyO1xuICAgICAgICB0aGlzLmRheXMucHVzaCh0MS5kYXlPZlllYXIoKSk7XG4gICAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAxICYmIFwiQllNT05USFwiIGluIHBhcnRzKSB7XG4gICAgICAgIGZvciAodmFyIG1vbnRoa2V5IGluIHRoaXMuYnlfZGF0YS5CWU1PTlRIKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKCF0aGlzLmJ5X2RhdGEuQllNT05USC5oYXNPd25Qcm9wZXJ0eShtb250aGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdDIgPSB0aGlzLmR0c3RhcnQuY2xvbmUoKTtcbiAgICAgICAgICB0Mi55ZWFyID0gYVllYXI7XG4gICAgICAgICAgdDIubW9udGggPSB0aGlzLmJ5X2RhdGEuQllNT05USFttb250aGtleV07XG4gICAgICAgICAgdDIuaXNEYXRlID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmRheXMucHVzaCh0Mi5kYXlPZlllYXIoKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDEgJiYgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgZm9yICh2YXIgbW9udGhkYXlrZXkgaW4gdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoIXRoaXMuYnlfZGF0YS5CWU1PTlRIREFZLmhhc093blByb3BlcnR5KG1vbnRoZGF5a2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0MyA9IHRoaXMuZHRzdGFydC5jbG9uZSgpO1xuICAgICAgICAgIHZhciBkYXlfID0gdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVlbbW9udGhkYXlrZXldO1xuICAgICAgICAgIGlmIChkYXlfIDwgMCkge1xuICAgICAgICAgICAgdmFyIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHQzLm1vbnRoLCBhWWVhcik7XG4gICAgICAgICAgICBkYXlfID0gZGF5XyArIGRheXNJbk1vbnRoICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdDMuZGF5ID0gZGF5XztcbiAgICAgICAgICB0My55ZWFyID0gYVllYXI7XG4gICAgICAgICAgdDMuaXNEYXRlID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmRheXMucHVzaCh0My5kYXlPZlllYXIoKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDIgJiZcbiAgICAgICAgICAgICAgICAgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMgJiZcbiAgICAgICAgICAgICAgICAgXCJCWU1PTlRIXCIgaW4gcGFydHMpIHtcbiAgICAgICAgZm9yICh2YXIgbW9udGhrZXkgaW4gdGhpcy5ieV9kYXRhLkJZTU9OVEgpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoIXRoaXMuYnlfZGF0YS5CWU1PTlRILmhhc093blByb3BlcnR5KG1vbnRoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtb250aF8gPSB0aGlzLmJ5X2RhdGEuQllNT05USFttb250aGtleV07XG4gICAgICAgICAgdmFyIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKG1vbnRoXywgYVllYXIpO1xuICAgICAgICAgIGZvciAodmFyIG1vbnRoZGF5a2V5IGluIHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkuaGFzT3duUHJvcGVydHkobW9udGhkYXlrZXkpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRheV8gPSB0aGlzLmJ5X2RhdGEuQllNT05USERBWVttb250aGRheWtleV07XG4gICAgICAgICAgICBpZiAoZGF5XyA8IDApIHtcbiAgICAgICAgICAgICAgZGF5XyA9IGRheV8gKyBkYXlzSW5Nb250aCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0LmRheSA9IGRheV87XG4gICAgICAgICAgICB0Lm1vbnRoID0gbW9udGhfO1xuICAgICAgICAgICAgdC55ZWFyID0gYVllYXI7XG4gICAgICAgICAgICB0LmlzRGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuZGF5cy5wdXNoKHQuZGF5T2ZZZWFyKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMSAmJiBcIkJZV0VFS05PXCIgaW4gcGFydHMpIHtcbiAgICAgICAgLy8gVE9ETyB1bmltcGxlbWVudGVkIGluIGxpYmljYWxcbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDIgJiZcbiAgICAgICAgICAgICAgICAgXCJCWVdFRUtOT1wiIGluIHBhcnRzICYmXG4gICAgICAgICAgICAgICAgIFwiQllNT05USERBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgIC8vIFRPRE8gdW5pbXBsZW1lbnRlZCBpbiBsaWJpY2FsXG4gICAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAxICYmIFwiQllEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICB0aGlzLmRheXMgPSB0aGlzLmRheXMuY29uY2F0KHRoaXMuZXhwYW5kX2J5X2RheShhWWVhcikpO1xuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMiAmJiBcIkJZREFZXCIgaW4gcGFydHMgJiYgXCJCWU1PTlRIXCIgaW4gcGFydHMpIHtcbiAgICAgICAgZm9yICh2YXIgbW9udGhrZXkgaW4gdGhpcy5ieV9kYXRhLkJZTU9OVEgpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoIXRoaXMuYnlfZGF0YS5CWU1PTlRILmhhc093blByb3BlcnR5KG1vbnRoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtb250aCA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIW21vbnRoa2V5XTtcbiAgICAgICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgobW9udGgsIGFZZWFyKTtcblxuICAgICAgICAgIHQueWVhciA9IGFZZWFyO1xuICAgICAgICAgIHQubW9udGggPSB0aGlzLmJ5X2RhdGEuQllNT05USFttb250aGtleV07XG4gICAgICAgICAgdC5kYXkgPSAxO1xuICAgICAgICAgIHQuaXNEYXRlID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBmaXJzdF9kb3cgPSB0LmRheU9mV2VlaygpO1xuICAgICAgICAgIHZhciBkb3lfb2Zmc2V0ID0gdC5kYXlPZlllYXIoKSAtIDE7XG5cbiAgICAgICAgICB0LmRheSA9IGRheXNJbk1vbnRoO1xuICAgICAgICAgIHZhciBsYXN0X2RvdyA9IHQuZGF5T2ZXZWVrKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZU0VUUE9TXCIpKSB7XG4gICAgICAgICAgICB2YXIgc2V0X3Bvc19jb3VudGVyID0gMDtcbiAgICAgICAgICAgIHZhciBieV9tb250aF9kYXkgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGRheSA9IDE7IGRheSA8PSBkYXlzSW5Nb250aDsgZGF5KyspIHtcbiAgICAgICAgICAgICAgdC5kYXkgPSBkYXk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmlzX2RheV9pbl9ieWRheSh0KSkge1xuICAgICAgICAgICAgICAgIGJ5X21vbnRoX2RheS5wdXNoKGRheSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgc3BJbmRleCA9IDA7IHNwSW5kZXggPCBieV9tb250aF9kYXkubGVuZ3RoOyBzcEluZGV4KyspIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tfc2V0X3Bvc2l0aW9uKHNwSW5kZXggKyAxKSB8fFxuICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja19zZXRfcG9zaXRpb24oc3BJbmRleCAtIGJ5X21vbnRoX2RheS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXlzLnB1c2goZG95X29mZnNldCArIGJ5X21vbnRoX2RheVtzcEluZGV4XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgZGF5Y29kZWRrZXkgaW4gdGhpcy5ieV9kYXRhLkJZREFZKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAoIXRoaXMuYnlfZGF0YS5CWURBWS5oYXNPd25Qcm9wZXJ0eShkYXljb2RlZGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgY29kZWRfZGF5ID0gdGhpcy5ieV9kYXRhLkJZREFZW2RheWNvZGVka2V5XTtcbiAgICAgICAgICAgICAgdmFyIGJ5ZGF5UGFydHMgPSB0aGlzLnJ1bGVEYXlPZldlZWsoY29kZWRfZGF5KTtcbiAgICAgICAgICAgICAgdmFyIHBvcyA9IGJ5ZGF5UGFydHNbMF07XG4gICAgICAgICAgICAgIHZhciBkb3cgPSBieWRheVBhcnRzWzFdO1xuICAgICAgICAgICAgICB2YXIgbW9udGhfZGF5O1xuXG4gICAgICAgICAgICAgIHZhciBmaXJzdF9tYXRjaGluZ19kYXkgPSAoKGRvdyArIDcgLSBmaXJzdF9kb3cpICUgNykgKyAxO1xuICAgICAgICAgICAgICB2YXIgbGFzdF9tYXRjaGluZ19kYXkgPSBkYXlzSW5Nb250aCAtICgobGFzdF9kb3cgKyA3IC0gZG93KSAlIDcpO1xuXG4gICAgICAgICAgICAgIGlmIChwb3MgPT0gMCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGRheSA9IGZpcnN0X21hdGNoaW5nX2RheTsgZGF5IDw9IGRheXNJbk1vbnRoOyBkYXkgKz0gNykge1xuICAgICAgICAgICAgICAgICAgdGhpcy5kYXlzLnB1c2goZG95X29mZnNldCArIGRheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBvcyA+IDApIHtcbiAgICAgICAgICAgICAgICBtb250aF9kYXkgPSBmaXJzdF9tYXRjaGluZ19kYXkgKyAocG9zIC0gMSkgKiA3O1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoX2RheSA8PSBkYXlzSW5Nb250aCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5kYXlzLnB1c2goZG95X29mZnNldCArIG1vbnRoX2RheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vbnRoX2RheSA9IGxhc3RfbWF0Y2hpbmdfZGF5ICsgKHBvcyArIDEpICogNztcblxuICAgICAgICAgICAgICAgIGlmIChtb250aF9kYXkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmRheXMucHVzaChkb3lfb2Zmc2V0ICsgbW9udGhfZGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIGRhdGVzIGluIG9yZGVyIG9mIG9jY3VycmVuY2UgKDEsMiwzLC4uLikgaW5zdGVhZFxuICAgICAgICAvLyBvZiBieSBncm91cHMgb2Ygd2Vla2RheXMgKDEsOCwxNSwuLi4sMiw5LDE2LC4uLikuXG4gICAgICAgIHRoaXMuZGF5cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTsgLy8gQ29tcGFyYXRvciBmdW5jdGlvbiBhbGxvd3MgdG8gc29ydCBudW1iZXJzLlxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMiAmJiBcIkJZREFZXCIgaW4gcGFydHMgJiYgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgdmFyIGV4cGFuZGVkRGF5cyA9IHRoaXMuZXhwYW5kX2J5X2RheShhWWVhcik7XG5cbiAgICAgICAgZm9yICh2YXIgZGF5a2V5IGluIGV4cGFuZGVkRGF5cykge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghZXhwYW5kZWREYXlzLmhhc093blByb3BlcnR5KGRheWtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGF5ID0gZXhwYW5kZWREYXlzW2RheWtleV07XG4gICAgICAgICAgdmFyIHR0ID0gSUNBTC5UaW1lLmZyb21EYXlPZlllYXIoZGF5LCBhWWVhcik7XG4gICAgICAgICAgaWYgKHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZLmluZGV4T2YodHQuZGF5KSA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRheXMucHVzaChkYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMyAmJlxuICAgICAgICAgICAgICAgICBcIkJZREFZXCIgaW4gcGFydHMgJiZcbiAgICAgICAgICAgICAgICAgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMgJiZcbiAgICAgICAgICAgICAgICAgXCJCWU1PTlRIXCIgaW4gcGFydHMpIHtcbiAgICAgICAgdmFyIGV4cGFuZGVkRGF5cyA9IHRoaXMuZXhwYW5kX2J5X2RheShhWWVhcik7XG5cbiAgICAgICAgZm9yICh2YXIgZGF5a2V5IGluIGV4cGFuZGVkRGF5cykge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghZXhwYW5kZWREYXlzLmhhc093blByb3BlcnR5KGRheWtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGF5ID0gZXhwYW5kZWREYXlzW2RheWtleV07XG4gICAgICAgICAgdmFyIHR0ID0gSUNBTC5UaW1lLmZyb21EYXlPZlllYXIoZGF5LCBhWWVhcik7XG5cbiAgICAgICAgICBpZiAodGhpcy5ieV9kYXRhLkJZTU9OVEguaW5kZXhPZih0dC5tb250aCkgPj0gMCAmJlxuICAgICAgICAgICAgICB0aGlzLmJ5X2RhdGEuQllNT05USERBWS5pbmRleE9mKHR0LmRheSkgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5kYXlzLnB1c2goZGF5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDIgJiYgXCJCWURBWVwiIGluIHBhcnRzICYmIFwiQllXRUVLTk9cIiBpbiBwYXJ0cykge1xuICAgICAgICB2YXIgZXhwYW5kZWREYXlzID0gdGhpcy5leHBhbmRfYnlfZGF5KGFZZWFyKTtcblxuICAgICAgICBmb3IgKHZhciBkYXlrZXkgaW4gZXhwYW5kZWREYXlzKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKCFleHBhbmRlZERheXMuaGFzT3duUHJvcGVydHkoZGF5a2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXkgPSBleHBhbmRlZERheXNbZGF5a2V5XTtcbiAgICAgICAgICB2YXIgdHQgPSBJQ0FMLlRpbWUuZnJvbURheU9mWWVhcihkYXksIGFZZWFyKTtcbiAgICAgICAgICB2YXIgd2Vla25vID0gdHQud2Vla051bWJlcih0aGlzLnJ1bGUud2tzdCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5ieV9kYXRhLkJZV0VFS05PLmluZGV4T2Yod2Vla25vKSkge1xuICAgICAgICAgICAgdGhpcy5kYXlzLnB1c2goZGF5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDMgJiZcbiAgICAgICAgICAgICAgICAgXCJCWURBWVwiIGluIHBhcnRzICYmXG4gICAgICAgICAgICAgICAgIFwiQllXRUVLTk9cIiBpbiBwYXJ0cyAmJlxuICAgICAgICAgICAgICAgICBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICAvLyBUT0RPIHVuaW1wbGVtdGVkIGluIGxpYmljYWxcbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDEgJiYgXCJCWVlFQVJEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICB0aGlzLmRheXMgPSB0aGlzLmRheXMuY29uY2F0KHRoaXMuYnlfZGF0YS5CWVlFQVJEQVkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kYXlzID0gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgZXhwYW5kX2J5X2RheTogZnVuY3Rpb24gZXhwYW5kX2J5X2RheShhWWVhcikge1xuXG4gICAgICB2YXIgZGF5c19saXN0ID0gW107XG4gICAgICB2YXIgdG1wID0gdGhpcy5sYXN0LmNsb25lKCk7XG5cbiAgICAgIHRtcC55ZWFyID0gYVllYXI7XG4gICAgICB0bXAubW9udGggPSAxO1xuICAgICAgdG1wLmRheSA9IDE7XG4gICAgICB0bXAuaXNEYXRlID0gdHJ1ZTtcblxuICAgICAgdmFyIHN0YXJ0X2RvdyA9IHRtcC5kYXlPZldlZWsoKTtcblxuICAgICAgdG1wLm1vbnRoID0gMTI7XG4gICAgICB0bXAuZGF5ID0gMzE7XG4gICAgICB0bXAuaXNEYXRlID0gdHJ1ZTtcblxuICAgICAgdmFyIGVuZF9kb3cgPSB0bXAuZGF5T2ZXZWVrKCk7XG4gICAgICB2YXIgZW5kX3llYXJfZGF5ID0gdG1wLmRheU9mWWVhcigpO1xuXG4gICAgICBmb3IgKHZhciBkYXlrZXkgaW4gdGhpcy5ieV9kYXRhLkJZREFZKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXRoaXMuYnlfZGF0YS5CWURBWS5oYXNPd25Qcm9wZXJ0eShkYXlrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheSA9IHRoaXMuYnlfZGF0YS5CWURBWVtkYXlrZXldO1xuICAgICAgICB2YXIgcGFydHMgPSB0aGlzLnJ1bGVEYXlPZldlZWsoZGF5KTtcbiAgICAgICAgdmFyIHBvcyA9IHBhcnRzWzBdO1xuICAgICAgICB2YXIgZG93ID0gcGFydHNbMV07XG5cbiAgICAgICAgaWYgKHBvcyA9PSAwKSB7XG4gICAgICAgICAgdmFyIHRtcF9zdGFydF9kb3kgPSAoKGRvdyArIDcgLSBzdGFydF9kb3cpICUgNykgKyAxO1xuXG4gICAgICAgICAgZm9yICh2YXIgZG95ID0gdG1wX3N0YXJ0X2RveTsgZG95IDw9IGVuZF95ZWFyX2RheTsgZG95ICs9IDcpIHtcbiAgICAgICAgICAgIGRheXNfbGlzdC5wdXNoKGRveSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAocG9zID4gMCkge1xuICAgICAgICAgIHZhciBmaXJzdDtcbiAgICAgICAgICBpZiAoZG93ID49IHN0YXJ0X2Rvdykge1xuICAgICAgICAgICAgZmlyc3QgPSBkb3cgLSBzdGFydF9kb3cgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaXJzdCA9IGRvdyAtIHN0YXJ0X2RvdyArIDg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF5c19saXN0LnB1c2goZmlyc3QgKyAocG9zIC0gMSkgKiA3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbGFzdDtcbiAgICAgICAgICBwb3MgPSAtcG9zO1xuXG4gICAgICAgICAgaWYgKGRvdyA8PSBlbmRfZG93KSB7XG4gICAgICAgICAgICBsYXN0ID0gZW5kX3llYXJfZGF5IC0gZW5kX2RvdyArIGRvdztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdCA9IGVuZF95ZWFyX2RheSAtIGVuZF9kb3cgKyBkb3cgLSA3O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRheXNfbGlzdC5wdXNoKGxhc3QgLSAocG9zIC0gMSkgKiA3KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRheXNfbGlzdDtcbiAgICB9LFxuXG4gICAgaXNfZGF5X2luX2J5ZGF5OiBmdW5jdGlvbiBpc19kYXlfaW5fYnlkYXkodHQpIHtcbiAgICAgIGZvciAodmFyIGRheWtleSBpbiB0aGlzLmJ5X2RhdGEuQllEQVkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZREFZLmhhc093blByb3BlcnR5KGRheWtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF5ID0gdGhpcy5ieV9kYXRhLkJZREFZW2RheWtleV07XG4gICAgICAgIHZhciBwYXJ0cyA9IHRoaXMucnVsZURheU9mV2VlayhkYXkpO1xuICAgICAgICB2YXIgcG9zID0gcGFydHNbMF07XG4gICAgICAgIHZhciBkb3cgPSBwYXJ0c1sxXTtcbiAgICAgICAgdmFyIHRoaXNfZG93ID0gdHQuZGF5T2ZXZWVrKCk7XG5cbiAgICAgICAgaWYgKChwb3MgPT0gMCAmJiBkb3cgPT0gdGhpc19kb3cpIHx8XG4gICAgICAgICAgICAodHQubnRoV2Vla0RheShkb3csIHBvcykgPT0gdHQuZGF5KSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgZ2l2ZW4gdmFsdWUgaXMgaW4gQllTRVRQT1MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtZXJpY30gYVBvcyBwb3NpdGlvbiB0byBjaGVjayBmb3IuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gZmFsc2UgdW5sZXNzIEJZU0VUUE9TIHJ1bGVzIGV4aXN0XG4gICAgICogICAgICAgICAgICAgICAgICAgYW5kIHRoZSBnaXZlbiB2YWx1ZSBpcyBwcmVzZW50IGluIHJ1bGVzLlxuICAgICAqL1xuICAgIGNoZWNrX3NldF9wb3NpdGlvbjogZnVuY3Rpb24gY2hlY2tfc2V0X3Bvc2l0aW9uKGFQb3MpIHtcbiAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKCdCWVNFVFBPUycpKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLmJ5X2RhdGEuQllTRVRQT1MuaW5kZXhPZihhUG9zKTtcbiAgICAgICAgLy8gbmVnYXRpdmUgbnVtYmVycyBhcmUgbm90IGZhbHNlLXlcbiAgICAgICAgcmV0dXJuIGlkeCAhPT0gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIHNvcnRfYnlkYXlfcnVsZXM6IGZ1bmN0aW9uIGljYWxyZWN1cl9zb3J0X2J5ZGF5X3J1bGVzKGFSdWxlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhUnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpOyBqKyspIHtcbiAgICAgICAgICB2YXIgb25lID0gdGhpcy5ydWxlRGF5T2ZXZWVrKGFSdWxlc1tqXSwgdGhpcy5ydWxlLndrc3QpWzFdO1xuICAgICAgICAgIHZhciB0d28gPSB0aGlzLnJ1bGVEYXlPZldlZWsoYVJ1bGVzW2ldLCB0aGlzLnJ1bGUud2tzdClbMV07XG5cbiAgICAgICAgICBpZiAob25lID4gdHdvKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gYVJ1bGVzW2ldO1xuICAgICAgICAgICAgYVJ1bGVzW2ldID0gYVJ1bGVzW2pdO1xuICAgICAgICAgICAgYVJ1bGVzW2pdID0gdG1wO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjaGVja19jb250cmFjdF9yZXN0cmljdGlvbjogZnVuY3Rpb24gY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oYVJ1bGVUeXBlLCB2KSB7XG4gICAgICB2YXIgaW5kZXhNYXBWYWx1ZSA9IGljYWxyZWN1cl9pdGVyYXRvci5faW5kZXhNYXBbYVJ1bGVUeXBlXTtcbiAgICAgIHZhciBydWxlTWFwVmFsdWUgPSBpY2FscmVjdXJfaXRlcmF0b3IuX2V4cGFuZE1hcFt0aGlzLnJ1bGUuZnJlcV1baW5kZXhNYXBWYWx1ZV07XG4gICAgICB2YXIgcGFzcyA9IGZhbHNlO1xuXG4gICAgICBpZiAoYVJ1bGVUeXBlIGluIHRoaXMuYnlfZGF0YSAmJlxuICAgICAgICAgIHJ1bGVNYXBWYWx1ZSA9PSBpY2FscmVjdXJfaXRlcmF0b3IuQ09OVFJBQ1QpIHtcblxuICAgICAgICB2YXIgcnVsZVR5cGUgPSB0aGlzLmJ5X2RhdGFbYVJ1bGVUeXBlXTtcblxuICAgICAgICBmb3IgKHZhciBieWRhdGFrZXkgaW4gcnVsZVR5cGUpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgIGlmIChydWxlVHlwZS5oYXNPd25Qcm9wZXJ0eShieWRhdGFrZXkpKSB7XG4gICAgICAgICAgICBpZiAocnVsZVR5cGVbYnlkYXRha2V5XSA9PSB2KSB7XG4gICAgICAgICAgICAgIHBhc3MgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vdCBhIGNvbnRyYWN0aW5nIGJ5cnVsZSBvciBoYXMgbm8gZGF0YSwgdGVzdCBwYXNzZXNcbiAgICAgICAgcGFzcyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFzcztcbiAgICB9LFxuXG4gICAgY2hlY2tfY29udHJhY3RpbmdfcnVsZXM6IGZ1bmN0aW9uIGNoZWNrX2NvbnRyYWN0aW5nX3J1bGVzKCkge1xuICAgICAgdmFyIGRvdyA9IHRoaXMubGFzdC5kYXlPZldlZWsoKTtcbiAgICAgIHZhciB3ZWVrTm8gPSB0aGlzLmxhc3Qud2Vla051bWJlcih0aGlzLnJ1bGUud2tzdCk7XG4gICAgICB2YXIgZG95ID0gdGhpcy5sYXN0LmRheU9mWWVhcigpO1xuXG4gICAgICByZXR1cm4gKHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWVNFQ09ORFwiLCB0aGlzLmxhc3Quc2Vjb25kKSAmJlxuICAgICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllNSU5VVEVcIiwgdGhpcy5sYXN0Lm1pbnV0ZSkgJiZcbiAgICAgICAgICAgICAgdGhpcy5jaGVja19jb250cmFjdF9yZXN0cmljdGlvbihcIkJZSE9VUlwiLCB0aGlzLmxhc3QuaG91cikgJiZcbiAgICAgICAgICAgICAgdGhpcy5jaGVja19jb250cmFjdF9yZXN0cmljdGlvbihcIkJZREFZXCIsIElDQUwuUmVjdXIubnVtZXJpY0RheVRvSWNhbERheShkb3cpKSAmJlxuICAgICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllXRUVLTk9cIiwgd2Vla05vKSAmJlxuICAgICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllNT05USERBWVwiLCB0aGlzLmxhc3QuZGF5KSAmJlxuICAgICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllNT05USFwiLCB0aGlzLmxhc3QubW9udGgpICYmXG4gICAgICAgICAgICAgIHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWVlFQVJEQVlcIiwgZG95KSk7XG4gICAgfSxcblxuICAgIHNldHVwX2RlZmF1bHRzOiBmdW5jdGlvbiBzZXR1cF9kZWZhdWx0cyhhUnVsZVR5cGUsIHJlcSwgZGVmdGltZSkge1xuICAgICAgdmFyIGluZGV4TWFwVmFsdWUgPSBpY2FscmVjdXJfaXRlcmF0b3IuX2luZGV4TWFwW2FSdWxlVHlwZV07XG4gICAgICB2YXIgcnVsZU1hcFZhbHVlID0gaWNhbHJlY3VyX2l0ZXJhdG9yLl9leHBhbmRNYXBbdGhpcy5ydWxlLmZyZXFdW2luZGV4TWFwVmFsdWVdO1xuXG4gICAgICBpZiAocnVsZU1hcFZhbHVlICE9IGljYWxyZWN1cl9pdGVyYXRvci5DT05UUkFDVCkge1xuICAgICAgICBpZiAoIShhUnVsZVR5cGUgaW4gdGhpcy5ieV9kYXRhKSkge1xuICAgICAgICAgIHRoaXMuYnlfZGF0YVthUnVsZVR5cGVdID0gW2RlZnRpbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJ1bGUuZnJlcSAhPSByZXEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ieV9kYXRhW2FSdWxlVHlwZV1bMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZ0aW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGl0ZXJhdG9yIGludG8gYSBzZXJpYWxpemUtYWJsZSBvYmplY3QuICBXaWxsIHByZXNlcnZlIGN1cnJlbnRcbiAgICAgKiBpdGVyYXRpb24gc2VxdWVuY2UgdG8gZW5zdXJlIHRoZSBzZWFtbGVzcyBjb250aW51YXRpb24gb2YgdGhlIHJlY3VycmVuY2VcbiAgICAgKiBydWxlLlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIHJlc3VsdC5pbml0aWFsaXplZCA9IHRoaXMuaW5pdGlhbGl6ZWQ7XG4gICAgICByZXN1bHQucnVsZSA9IHRoaXMucnVsZS50b0pTT04oKTtcbiAgICAgIHJlc3VsdC5kdHN0YXJ0ID0gdGhpcy5kdHN0YXJ0LnRvSlNPTigpO1xuICAgICAgcmVzdWx0LmJ5X2RhdGEgPSB0aGlzLmJ5X2RhdGE7XG4gICAgICByZXN1bHQuZGF5cyA9IHRoaXMuZGF5cztcbiAgICAgIHJlc3VsdC5sYXN0ID0gdGhpcy5sYXN0LnRvSlNPTigpO1xuICAgICAgcmVzdWx0LmJ5X2luZGljZXMgPSB0aGlzLmJ5X2luZGljZXM7XG4gICAgICByZXN1bHQub2NjdXJyZW5jZV9udW1iZXIgPSB0aGlzLm9jY3VycmVuY2VfbnVtYmVyO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcblxuICBpY2FscmVjdXJfaXRlcmF0b3IuX2luZGV4TWFwID0ge1xuICAgIFwiQllTRUNPTkRcIjogMCxcbiAgICBcIkJZTUlOVVRFXCI6IDEsXG4gICAgXCJCWUhPVVJcIjogMixcbiAgICBcIkJZREFZXCI6IDMsXG4gICAgXCJCWU1PTlRIREFZXCI6IDQsXG4gICAgXCJCWVlFQVJEQVlcIjogNSxcbiAgICBcIkJZV0VFS05PXCI6IDYsXG4gICAgXCJCWU1PTlRIXCI6IDcsXG4gICAgXCJCWVNFVFBPU1wiOiA4XG4gIH07XG5cbiAgaWNhbHJlY3VyX2l0ZXJhdG9yLl9leHBhbmRNYXAgPSB7XG4gICAgXCJTRUNPTkRMWVwiOiBbMSwgMSwgMSwgMSwgMSwgMSwgMSwgMV0sXG4gICAgXCJNSU5VVEVMWVwiOiBbMiwgMSwgMSwgMSwgMSwgMSwgMSwgMV0sXG4gICAgXCJIT1VSTFlcIjogWzIsIDIsIDEsIDEsIDEsIDEsIDEsIDFdLFxuICAgIFwiREFJTFlcIjogWzIsIDIsIDIsIDEsIDEsIDEsIDEsIDFdLFxuICAgIFwiV0VFS0xZXCI6IFsyLCAyLCAyLCAyLCAzLCAzLCAxLCAxXSxcbiAgICBcIk1PTlRITFlcIjogWzIsIDIsIDIsIDIsIDIsIDMsIDMsIDFdLFxuICAgIFwiWUVBUkxZXCI6IFsyLCAyLCAyLCAyLCAyLCAyLCAyLCAyXVxuICB9O1xuICBpY2FscmVjdXJfaXRlcmF0b3IuVU5LTk9XTiA9IDA7XG4gIGljYWxyZWN1cl9pdGVyYXRvci5DT05UUkFDVCA9IDE7XG4gIGljYWxyZWN1cl9pdGVyYXRvci5FWFBBTkQgPSAyO1xuICBpY2FscmVjdXJfaXRlcmF0b3IuSUxMRUdBTCA9IDM7XG5cbiAgcmV0dXJuIGljYWxyZWN1cl9pdGVyYXRvcjtcblxufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLlJlY3VyRXhwYW5zaW9uID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBmb3JtYXRUaW1lKGl0ZW0pIHtcbiAgICByZXR1cm4gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZShpdGVtLCBJQ0FMLlRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGFyZVRpbWUoYSwgYikge1xuICAgIHJldHVybiBhLmNvbXBhcmUoYik7XG4gIH1cblxuICBmdW5jdGlvbiBpc1JlY3VycmluZ0NvbXBvbmVudChjb21wKSB7XG4gICAgcmV0dXJuIGNvbXAuaGFzUHJvcGVydHkoJ3JkYXRlJykgfHxcbiAgICAgICAgICAgY29tcC5oYXNQcm9wZXJ0eSgncnJ1bGUnKSB8fFxuICAgICAgICAgICBjb21wLmhhc1Byb3BlcnR5KCdyZWN1cnJlbmNlLWlkJyk7XG4gIH1cblxuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBQcmltYXJ5IGNsYXNzIGZvciBleHBhbmRpbmcgcmVjdXJyaW5nIHJ1bGVzLiAgQ2FuIHRha2UgbXVsdGlwbGUgcnJ1bGVzLFxuICAgKiByZGF0ZXMsIGV4ZGF0ZShzKSBhbmQgaXRlcmF0ZSAoaW4gb3JkZXIpIG92ZXIgZWFjaCBuZXh0IG9jY3VycmVuY2UuXG4gICAqXG4gICAqIE9uY2UgaW5pdGlhbGl6ZWQgdGhpcyBjbGFzcyBjYW4gYWxzbyBiZSBzZXJpYWxpemVkIHNhdmVkIGFuZCBjb250aW51ZVxuICAgKiBpdGVyYXRpb24gZnJvbSB0aGUgbGFzdCBwb2ludC5cbiAgICpcbiAgICogTk9URTogaXQgaXMgaW50ZW5kZWQgdGhhdCB0aGlzIGNsYXNzIGlzIHRvIGJlIHVzZWRcbiAgICogICAgICAgd2l0aCBJQ0FMLkV2ZW50IHdoaWNoIGhhbmRsZXMgcmVjdXJyZW5jZSBleGNlcHRpb25zLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBhc3N1bWluZyBldmVudCBpcyBhIHBhcnNlZCBpY2FsIGNvbXBvbmVudFxuICAgKiB2YXIgZXZlbnQ7XG4gICAqXG4gICAqIHZhciBleHBhbmQgPSBuZXcgSUNBTC5SZWN1ckV4cGFuc2lvbih7XG4gICAqICAgY29tcG9uZW50OiBldmVudCxcbiAgICogICBkdHN0YXJ0OiBldmVudC5nZXRGaXJzdFByb3BlcnR5VmFsdWUoJ2R0c3RhcnQnKVxuICAgKiB9KTtcbiAgICpcbiAgICogLy8gcmVtZW1iZXIgdGhlcmUgYXJlIGluZmluaXRlIHJ1bGVzXG4gICAqIC8vIHNvIGl0IGlzIGEgZ29vZCBpZGVhIHRvIGxpbWl0IHRoZSBzY29wZVxuICAgKiAvLyBvZiB0aGUgaXRlcmF0aW9ucyB0aGVuIHJlc3VtZSBsYXRlciBvbi5cbiAgICpcbiAgICogLy8gbmV4dCBpcyBhbHdheXMgYW4gSUNBTC5UaW1lIG9yIG51bGxcbiAgICogdmFyIG5leHQ7XG4gICAqXG4gICAqIHdoaWxlIChzb21lQ29uZGl0aW9uICYmIChuZXh0ID0gZXhwYW5kLm5leHQoKSkpIHtcbiAgICogICAvLyBkbyBzb21ldGhpbmcgd2l0aCBuZXh0XG4gICAqIH1cbiAgICpcbiAgICogLy8gc2F2ZSBpbnN0YW5jZSBmb3IgbGF0ZXJcbiAgICogdmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeShleHBhbmQpO1xuICAgKlxuICAgKiAvLy4uLlxuICAgKlxuICAgKiAvLyBOT1RFOiBpZiB0aGUgY29tcG9uZW50J3MgcHJvcGVydGllcyBoYXZlXG4gICAqIC8vICAgICAgIGNoYW5nZWQgeW91IHdpbGwgbmVlZCB0byByZWJ1aWxkIHRoZVxuICAgKiAvLyAgICAgICBjbGFzcyBhbmQgc3RhcnQgb3Zlci4gVGhpcyBvbmx5IHdvcmtzXG4gICAqIC8vICAgICAgIHdoZW4gdGhlIGNvbXBvbmVudCdzIHJlY3VycmVuY2UgaW5mbyBpcyB0aGUgc2FtZS5cbiAgICogdmFyIGV4cGFuZCA9IG5ldyBJQ0FMLlJlY3VyRXhwYW5zaW9uKEpTT04ucGFyc2UoanNvbikpO1xuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIG9wdGlvbnMgb2JqZWN0IGNhbiBiZSBmaWxsZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGluaXRpYWwgdmFsdWVzLiBJdCBjYW5cbiAgICogYWxzbyBjb250YWluIGFkZGl0aW9uYWwgbWVtYmVycywgYXMgYSByZXN1bHQgb2Ygc2VyaWFsaXppbmcgYSBwcmV2aW91c1xuICAgKiBleHBhbnNpb24gc3RhdGUsIGFzIHNob3duIGluIHRoZSBleGFtcGxlLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFsaWFzIElDQUwuUmVjdXJFeHBhbnNpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIFJlY3VycmVuY2UgZXhwYW5zaW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IG9wdGlvbnMuZHRzdGFydFxuICAgKiAgICAgICAgU3RhcnQgdGltZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudD19IG9wdGlvbnMuY29tcG9uZW50XG4gICAqICAgICAgICBDb21wb25lbnQgZm9yIGV4cGFuc2lvbiwgcmVxdWlyZWQgaWYgbm90IHJlc3VtaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gUmVjdXJFeHBhbnNpb24ob3B0aW9ucykge1xuICAgIHRoaXMucnVsZURhdGVzID0gW107XG4gICAgdGhpcy5leERhdGVzID0gW107XG4gICAgdGhpcy5mcm9tRGF0YShvcHRpb25zKTtcbiAgfVxuXG4gIFJlY3VyRXhwYW5zaW9uLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBUcnVlIHdoZW4gaXRlcmF0aW9uIGlzIGZ1bGx5IGNvbXBsZXRlZC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBjb21wbGV0ZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBycnVsZSBpdGVyYXRvcnMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5SZWN1ckl0ZXJhdG9yW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBydWxlSXRlcmF0b3JzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgcmRhdGUgaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogQHR5cGUge0lDQUwuVGltZVtdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcnVsZURhdGVzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgZXhkYXRlIGluc3RhbmNlcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWVbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGV4RGF0ZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHBvc2l0aW9uIGluIHJ1bGVEYXRlcyBhcnJheS5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcnVsZURhdGVJbmM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHBvc2l0aW9uIGluIGV4RGF0ZXMgYXJyYXlcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZXhEYXRlSW5jOiAwLFxuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBuZWdhdGl2ZSBkYXRlLlxuICAgICAqXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGV4RGF0ZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgYWRkaXRpb25hbCBkYXRlLlxuICAgICAqXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJ1bGVEYXRlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgZGF0ZSBvZiByZWN1cnJpbmcgcnVsZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lfVxuICAgICAqL1xuICAgIGR0c3RhcnQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBMYXN0IGV4cGFuZGVkIHRpbWVcbiAgICAgKlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgbGFzdDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIHJlY3VycmVuY2UgZXhwYW5zaW9uIGZyb20gdGhlIGRhdGEgb2JqZWN0LiBUaGUgb3B0aW9uc1xuICAgICAqIG9iamVjdCBtYXkgYWxzbyBjb250YWluIGFkZGl0aW9uYWwgbWVtYmVycywgc2VlIHRoZVxuICAgICAqIHtAbGluayBJQ0FMLlJlY3VyRXhwYW5zaW9uIGNvbnN0cnVjdG9yfSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiAgICAgICAgUmVjdXJyZW5jZSBleHBhbnNpb24gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lfSBvcHRpb25zLmR0c3RhcnRcbiAgICAgKiAgICAgICAgU3RhcnQgdGltZSBvZiB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50PX0gb3B0aW9ucy5jb21wb25lbnRcbiAgICAgKiAgICAgICAgQ29tcG9uZW50IGZvciBleHBhbnNpb24sIHJlcXVpcmVkIGlmIG5vdCByZXN1bWluZy5cbiAgICAgKi9cbiAgICBmcm9tRGF0YTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHN0YXJ0ID0gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZShvcHRpb25zLmR0c3RhcnQsIElDQUwuVGltZSk7XG5cbiAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCcuZHRzdGFydCAoSUNBTC5UaW1lKSBtdXN0IGJlIGdpdmVuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmR0c3RhcnQgPSBzdGFydDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuX2luaXQob3B0aW9ucy5jb21wb25lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sYXN0ID0gZm9ybWF0VGltZShvcHRpb25zLmxhc3QpIHx8IHN0YXJ0LmNsb25lKCk7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLnJ1bGVJdGVyYXRvcnMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJy5ydWxlSXRlcmF0b3JzIG9yIC5jb21wb25lbnQgbXVzdCBiZSBnaXZlbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ydWxlSXRlcmF0b3JzID0gb3B0aW9ucy5ydWxlSXRlcmF0b3JzLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIElDQUwuaGVscGVycy5mb3JtYXRDbGFzc1R5cGUoaXRlbSwgSUNBTC5SZWN1ckl0ZXJhdG9yKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ydWxlRGF0ZUluYyA9IG9wdGlvbnMucnVsZURhdGVJbmM7XG4gICAgICAgIHRoaXMuZXhEYXRlSW5jID0gb3B0aW9ucy5leERhdGVJbmM7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucnVsZURhdGVzKSB7XG4gICAgICAgICAgdGhpcy5ydWxlRGF0ZXMgPSBvcHRpb25zLnJ1bGVEYXRlcy5tYXAoZm9ybWF0VGltZSk7XG4gICAgICAgICAgdGhpcy5ydWxlRGF0ZSA9IHRoaXMucnVsZURhdGVzW3RoaXMucnVsZURhdGVJbmNdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZXhEYXRlcykge1xuICAgICAgICAgIHRoaXMuZXhEYXRlcyA9IG9wdGlvbnMuZXhEYXRlcy5tYXAoZm9ybWF0VGltZSk7XG4gICAgICAgICAgdGhpcy5leERhdGUgPSB0aGlzLmV4RGF0ZXNbdGhpcy5leERhdGVJbmNdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihvcHRpb25zLmNvbXBsZXRlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlID0gb3B0aW9ucy5jb21wbGV0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgbmV4dCBvY2N1cnJlbmNlIGluIHRoZSBzZXJpZXMuXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfVxuICAgICAqL1xuICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGl0ZXI7XG4gICAgICB2YXIgcnVsZU9mRGF5O1xuICAgICAgdmFyIG5leHQ7XG4gICAgICB2YXIgY29tcGFyZTtcblxuICAgICAgdmFyIG1heFRyaWVzID0gNTAwO1xuICAgICAgdmFyIGN1cnJlbnRUcnkgPSAwO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoY3VycmVudFRyeSsrID4gbWF4VHJpZXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnbWF4IHRyaWVzIGhhdmUgb2NjdXJlZCwgcnVsZSBtYXkgYmUgaW1wb3NzaWJsZSB0byBmb3JmaWxsLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dCA9IHRoaXMucnVsZURhdGU7XG4gICAgICAgIGl0ZXIgPSB0aGlzLl9uZXh0UmVjdXJyZW5jZUl0ZXIodGhpcy5sYXN0KTtcblxuICAgICAgICAvLyBubyBtb3JlIG1hdGNoZXNcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBpbmNyZW1lbnQgdGhlIHJ1bGUgZGF5IG9yIHJ1bGVcbiAgICAgICAgLy8gX2FmdGVyXyB3ZSBjaG9vc2UgYSB2YWx1ZSB0aGlzIHNob3VsZCBiZVxuICAgICAgICAvLyB0aGUgb25seSBzcG90IHdoZXJlIHdlIG5lZWQgdG8gd29ycnkgYWJvdXQgdGhlXG4gICAgICAgIC8vIGVuZCBvZiBldmVudHMuXG4gICAgICAgIGlmICghbmV4dCAmJiAhaXRlcikge1xuICAgICAgICAgIC8vIHRoZXJlIGFyZSBubyBtb3JlIGl0ZXJhdG9ycyBvciByZGF0ZXNcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIG5leHQgcnVsZSBkYXkgb3IgcmVjdXJyZW5jZSBydWxlIGlzIGZpcnN0LlxuICAgICAgICBpZiAoIW5leHQgfHwgKGl0ZXIgJiYgbmV4dC5jb21wYXJlKGl0ZXIubGFzdCkgPiAwKSkge1xuICAgICAgICAgIC8vIG11c3QgYmUgY2xvbmVkLCByZWN1ciB3aWxsIHJldXNlIHRoZSB0aW1lIGVsZW1lbnQuXG4gICAgICAgICAgbmV4dCA9IGl0ZXIubGFzdC5jbG9uZSgpO1xuICAgICAgICAgIC8vIG1vdmUgdG8gbmV4dCBzbyB3ZSBjYW4gY29udGludWVcbiAgICAgICAgICBpdGVyLm5leHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBydWxlRGF0ZSBpcyBzdGlsbCBuZXh0IGluY3JlbWVudCBpdC5cbiAgICAgICAgaWYgKHRoaXMucnVsZURhdGUgPT09IG5leHQpIHtcbiAgICAgICAgICB0aGlzLl9uZXh0UnVsZURheSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0ID0gbmV4dDtcblxuICAgICAgICAvLyBjaGVjayB0aGUgbmVnYXRpdmUgcnVsZXNcbiAgICAgICAgaWYgKHRoaXMuZXhEYXRlKSB7XG4gICAgICAgICAgY29tcGFyZSA9IHRoaXMuZXhEYXRlLmNvbXBhcmUodGhpcy5sYXN0KTtcblxuICAgICAgICAgIGlmIChjb21wYXJlIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dEV4RGF5KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgcnVsZSBpcyBleGNsdWRlZCBza2lwIGl0LlxuICAgICAgICAgIGlmIChjb21wYXJlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0RXhEYXkoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vWFhYOiBUaGUgc3BlYyBzdGF0ZXMgdGhhdCBhZnRlciB3ZSByZXNvbHZlIHRoZSBmaW5hbFxuICAgICAgICAvLyAgICAgbGlzdCBvZiBkYXRlcyB3ZSBleGVjdXRlIGV4ZGF0ZSB0aGlzIHNlZW1zIHNvbWV3aGF0IGNvdW50ZXJcbiAgICAgICAgLy8gICAgIGludHVpdGl2ZSB0byB3aGF0IEkgaGF2ZSBzZWVuIG1vc3Qgc2VydmVycyBkbyBzbyBmb3Igbm93XG4gICAgICAgIC8vICAgICBJIGV4Y2x1ZGUgYmFzZWQgb24gdGhlIG9yaWdpbmFsIGRhdGUgbm90IHRoZSBvbmUgdGhhdCBtYXlcbiAgICAgICAgLy8gICAgIGhhdmUgYmVlbiBtb2RpZmllZCBieSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICByZXR1cm4gdGhpcy5sYXN0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBvYmplY3QgaW50byBhIHNlcmlhbGl6ZS1hYmxlIGZvcm1hdC4gVGhpcyBmb3JtYXQgY2FuIGJlIHBhc3NlZFxuICAgICAqIGJhY2sgaW50byB0aGUgZXhwYW5zaW9uIHRvIHJlc3VtZSBpdGVyYXRpb24uXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiB0b0pTT04oaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS50b0pTT04oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXN1bHQucnVsZUl0ZXJhdG9ycyA9IHRoaXMucnVsZUl0ZXJhdG9ycy5tYXAodG9KU09OKTtcblxuICAgICAgaWYgKHRoaXMucnVsZURhdGVzKSB7XG4gICAgICAgIHJlc3VsdC5ydWxlRGF0ZXMgPSB0aGlzLnJ1bGVEYXRlcy5tYXAodG9KU09OKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZXhEYXRlcykge1xuICAgICAgICByZXN1bHQuZXhEYXRlcyA9IHRoaXMuZXhEYXRlcy5tYXAodG9KU09OKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0LnJ1bGVEYXRlSW5jID0gdGhpcy5ydWxlRGF0ZUluYztcbiAgICAgIHJlc3VsdC5leERhdGVJbmMgPSB0aGlzLmV4RGF0ZUluYztcbiAgICAgIHJlc3VsdC5sYXN0ID0gdGhpcy5sYXN0LnRvSlNPTigpO1xuICAgICAgcmVzdWx0LmR0c3RhcnQgPSB0aGlzLmR0c3RhcnQudG9KU09OKCk7XG4gICAgICByZXN1bHQuY29tcGxldGUgPSB0aGlzLmNvbXBsZXRlO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IGFsbCBkYXRlcyBmcm9tIHRoZSBwcm9wZXJ0aWVzIGluIHRoZSBnaXZlbiBjb21wb25lbnQuIFRoZVxuICAgICAqIHByb3BlcnRpZXMgd2lsbCBiZSBmaWx0ZXJlZCBieSB0aGUgcHJvcGVydHkgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudH0gY29tcG9uZW50ICAgICAgICBUaGUgY29tcG9uZW50IHRvIHNlYXJjaCBpblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eU5hbWUgICAgICAgICAgICAgVGhlIHByb3BlcnR5IG5hbWUgdG8gc2VhcmNoIGZvclxuICAgICAqIEByZXR1cm4ge0lDQUwuVGltZVtdfSAgICAgICAgICAgICAgICAgICAgVGhlIGV4dHJhY3RlZCBkYXRlcy5cbiAgICAgKi9cbiAgICBfZXh0cmFjdERhdGVzOiBmdW5jdGlvbihjb21wb25lbnQsIHByb3BlcnR5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gaGFuZGxlUHJvcChwcm9wKSB7XG4gICAgICAgIGlkeCA9IElDQUwuaGVscGVycy5iaW5zZWFyY2hJbnNlcnQoXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHByb3AsXG4gICAgICAgICAgY29tcGFyZVRpbWVcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBvcmRlcmVkIGluc2VydFxuICAgICAgICByZXN1bHQuc3BsaWNlKGlkeCwgMCwgcHJvcCk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciBwcm9wcyA9IGNvbXBvbmVudC5nZXRBbGxQcm9wZXJ0aWVzKHByb3BlcnR5TmFtZSk7XG4gICAgICB2YXIgbGVuID0gcHJvcHMubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIHByb3A7XG5cbiAgICAgIHZhciBpZHg7XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcHJvcHNbaV0uZ2V0VmFsdWVzKCkuZm9yRWFjaChoYW5kbGVQcm9wKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgcmVjdXJyZW5jZSBleHBhbnNpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnR9IGNvbXBvbmVudCAgICBUaGUgY29tcG9uZW50IHRvIGluaXRpYWxpemUgZnJvbS5cbiAgICAgKi9cbiAgICBfaW5pdDogZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICB0aGlzLnJ1bGVJdGVyYXRvcnMgPSBbXTtcblxuICAgICAgdGhpcy5sYXN0ID0gdGhpcy5kdHN0YXJ0LmNsb25lKCk7XG5cbiAgICAgIC8vIHRvIHByb3ZpZGUgYXBpIGNvbnNpc3RlbmN5IG5vbi1yZWN1cnJpbmdcbiAgICAgIC8vIGV2ZW50cyBjYW4gYWxzbyB1c2UgdGhlIGl0ZXJhdG9yIHRob3VnaCBpdCB3aWxsXG4gICAgICAvLyBvbmx5IHJldHVybiBhIHNpbmdsZSB0aW1lLlxuICAgICAgaWYgKCFpc1JlY3VycmluZ0NvbXBvbmVudChjb21wb25lbnQpKSB7XG4gICAgICAgIHRoaXMucnVsZURhdGUgPSB0aGlzLmxhc3QuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvbmVudC5oYXNQcm9wZXJ0eSgncmRhdGUnKSkge1xuICAgICAgICB0aGlzLnJ1bGVEYXRlcyA9IHRoaXMuX2V4dHJhY3REYXRlcyhjb21wb25lbnQsICdyZGF0ZScpO1xuXG4gICAgICAgIC8vIHNwZWNpYWwgaGFjayBmb3IgY2FzZXMgd2hlcmUgZmlyc3QgcmRhdGUgaXMgcHJpb3JcbiAgICAgICAgLy8gdG8gdGhlIHN0YXJ0IGRhdGUuIFdlIG9ubHkgY2hlY2sgZm9yIHRoZSBmaXJzdCByZGF0ZS5cbiAgICAgICAgLy8gVGhpcyBpcyBtb3N0bHkgZm9yIGdvb2dsZSdzIGNyYXp5IHJlY3VycmluZyBkYXRlIGxvZ2ljXG4gICAgICAgIC8vIChjb250YWN0cyBiaXJ0aGRheXMpLlxuICAgICAgICBpZiAoKHRoaXMucnVsZURhdGVzWzBdKSAmJlxuICAgICAgICAgICAgKHRoaXMucnVsZURhdGVzWzBdLmNvbXBhcmUodGhpcy5kdHN0YXJ0KSA8IDApKSB7XG5cbiAgICAgICAgICB0aGlzLnJ1bGVEYXRlSW5jID0gMDtcbiAgICAgICAgICB0aGlzLmxhc3QgPSB0aGlzLnJ1bGVEYXRlc1swXS5jbG9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucnVsZURhdGVJbmMgPSBJQ0FMLmhlbHBlcnMuYmluc2VhcmNoSW5zZXJ0KFxuICAgICAgICAgICAgdGhpcy5ydWxlRGF0ZXMsXG4gICAgICAgICAgICB0aGlzLmxhc3QsXG4gICAgICAgICAgICBjb21wYXJlVGltZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJ1bGVEYXRlID0gdGhpcy5ydWxlRGF0ZXNbdGhpcy5ydWxlRGF0ZUluY107XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb25lbnQuaGFzUHJvcGVydHkoJ3JydWxlJykpIHtcbiAgICAgICAgdmFyIHJ1bGVzID0gY29tcG9uZW50LmdldEFsbFByb3BlcnRpZXMoJ3JydWxlJyk7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IHJ1bGVzLmxlbmd0aDtcblxuICAgICAgICB2YXIgcnVsZTtcbiAgICAgICAgdmFyIGl0ZXI7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHJ1bGUgPSBydWxlc1tpXS5nZXRGaXJzdFZhbHVlKCk7XG4gICAgICAgICAgaXRlciA9IHJ1bGUuaXRlcmF0b3IodGhpcy5kdHN0YXJ0KTtcbiAgICAgICAgICB0aGlzLnJ1bGVJdGVyYXRvcnMucHVzaChpdGVyKTtcblxuICAgICAgICAgIC8vIGluY3JlbWVudCB0byB0aGUgbmV4dCBvY2N1cnJlbmNlIHNvIGZ1dHVyZVxuICAgICAgICAgIC8vIGNhbGxzIHRvIG5leHQgcmV0dXJuIHRpbWVzIGJleW9uZCB0aGUgaW5pdGlhbCBpdGVyYXRpb24uXG4gICAgICAgICAgLy8gWFhYOiBJIGZpbmQgdGhpcyBzdXNwaWNpb3VzIG1pZ2h0IGJlIGEgYnVnP1xuICAgICAgICAgIGl0ZXIubmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb25lbnQuaGFzUHJvcGVydHkoJ2V4ZGF0ZScpKSB7XG4gICAgICAgIHRoaXMuZXhEYXRlcyA9IHRoaXMuX2V4dHJhY3REYXRlcyhjb21wb25lbnQsICdleGRhdGUnKTtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIC5sYXN0IGRheSB3ZSBpbmNyZW1lbnQgdGhlIGluZGV4IHRvIGJleW9uZCBpdC5cbiAgICAgICAgdGhpcy5leERhdGVJbmMgPSBJQ0FMLmhlbHBlcnMuYmluc2VhcmNoSW5zZXJ0KFxuICAgICAgICAgIHRoaXMuZXhEYXRlcyxcbiAgICAgICAgICB0aGlzLmxhc3QsXG4gICAgICAgICAgY29tcGFyZVRpbWVcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLmV4RGF0ZSA9IHRoaXMuZXhEYXRlc1t0aGlzLmV4RGF0ZUluY107XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkdmFuY2UgdG8gdGhlIG5leHQgZXhkYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbmV4dEV4RGF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZXhEYXRlID0gdGhpcy5leERhdGVzWysrdGhpcy5leERhdGVJbmNdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZHZhbmNlIHRvIHRoZSBuZXh0IHJ1bGUgZGF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX25leHRSdWxlRGF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucnVsZURhdGUgPSB0aGlzLnJ1bGVEYXRlc1srK3RoaXMucnVsZURhdGVJbmNdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuZCByZXR1cm4gdGhlIHJlY3VycmVuY2UgcnVsZSB3aXRoIHRoZSBtb3N0IHJlY2VudCBldmVudCBhbmRcbiAgICAgKiByZXR1cm4gaXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4gez9JQ0FMLlJlY3VySXRlcmF0b3J9ICAgIEZvdW5kIGl0ZXJhdG9yLlxuICAgICAqL1xuICAgIF9uZXh0UmVjdXJyZW5jZUl0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGl0ZXJzID0gdGhpcy5ydWxlSXRlcmF0b3JzO1xuXG4gICAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuID0gaXRlcnMubGVuZ3RoO1xuICAgICAgdmFyIGl0ZXI7XG4gICAgICB2YXIgaXRlclRpbWU7XG4gICAgICB2YXIgaXRlcklkeCA9IDA7XG4gICAgICB2YXIgY2hvc2VuSXRlcjtcblxuICAgICAgLy8gbG9vcCB0aHJvdWdoIGVhY2ggaXRlcmF0b3JcbiAgICAgIGZvciAoOyBpdGVySWR4IDwgbGVuOyBpdGVySWR4KyspIHtcbiAgICAgICAgaXRlciA9IGl0ZXJzW2l0ZXJJZHhdO1xuICAgICAgICBpdGVyVGltZSA9IGl0ZXIubGFzdDtcblxuICAgICAgICAvLyBpZiBpdGVyYXRpb24gaXMgY29tcGxldGVcbiAgICAgICAgLy8gdGhlbiB3ZSBtdXN0IGV4Y2x1ZGUgaXQgZnJvbVxuICAgICAgICAvLyB0aGUgc2VhcmNoIGFuZCByZW1vdmUgaXQuXG4gICAgICAgIGlmIChpdGVyLmNvbXBsZXRlZCkge1xuICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgIGlmIChpdGVySWR4ICE9PSAwKSB7XG4gICAgICAgICAgICBpdGVySWR4LS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZXJzLnNwbGljZShpdGVySWR4LCAxKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgdGhlIG1vc3QgcmVjZW50IHBvc3NpYmxlIGNob2ljZVxuICAgICAgICBpZiAoIWNob3Nlbkl0ZXIgfHwgY2hvc2VuSXRlci5sYXN0LmNvbXBhcmUoaXRlclRpbWUpID4gMCkge1xuICAgICAgICAgIC8vIHRoYXQgaXRlcmF0b3IgaXMgc2F2ZWRcbiAgICAgICAgICBjaG9zZW5JdGVyID0gaXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0aGUgY2hvc2VuIGl0ZXJhdG9yIGlzIHJldHVybmVkIGJ1dCBub3QgbXV0YXRlZFxuICAgICAgLy8gdGhpcyBpdGVyYXRvciBjb250YWlucyB0aGUgbW9zdCByZWNlbnQgZXZlbnQuXG4gICAgICByZXR1cm4gY2hvc2VuSXRlcjtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFJlY3VyRXhwYW5zaW9uO1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLkV2ZW50ID0gKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIElDQUwuanMgaXMgb3JnYW5pemVkIGludG8gbXVsdGlwbGUgbGF5ZXJzLiBUaGUgYm90dG9tIGxheWVyIGlzIGEgcmF3IGpDYWxcbiAgICogb2JqZWN0LCBmb2xsb3dlZCBieSB0aGUgY29tcG9uZW50L3Byb3BlcnR5IGxheWVyLiBUaGUgaGlnaGVzdCBsZXZlbCBpcyB0aGVcbiAgICogZXZlbnQgcmVwcmVzZW50YXRpb24sIHdoaWNoIHRoaXMgY2xhc3MgaXMgcGFydCBvZi4gU2VlIHRoZVxuICAgKiB7QHR1dG9yaWFsIGxheWVyc30gZ3VpZGUgZm9yIG1vcmUgZGV0YWlscy5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBhbGlhcyBJQ0FMLkV2ZW50XG4gICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnQ9fSBjb21wb25lbnQgICAgICAgICBUaGUgSUNBTC5Db21wb25lbnQgdG8gYmFzZSB0aGlzIGV2ZW50IG9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgICAgICAgICBPcHRpb25zIGZvciB0aGlzIGV2ZW50XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5zdHJpY3RFeGNlcHRpb25zXG4gICAqICAgICAgICAgIFdoZW4gdHJ1ZSwgd2lsbCB2ZXJpZnkgZXhjZXB0aW9ucyBhcmUgcmVsYXRlZCBieSB0aGVpciBVVUlEXG4gICAqIEBwYXJhbSB7QXJyYXk8SUNBTC5Db21wb25lbnR8SUNBTC5FdmVudD59IG9wdGlvbnMuZXhjZXB0aW9uc1xuICAgKiAgICAgICAgICBFeGNlcHRpb25zIHRvIHRoaXMgZXZlbnQsIGVpdGhlciBhcyBjb21wb25lbnRzIG9yIGV2ZW50cy4gSWYgbm90XG4gICAqICAgICAgICAgICAgc3BlY2lmaWVkIGV4Y2VwdGlvbnMgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHNldCBpbiByZWxhdGlvbiBvZlxuICAgKiAgICAgICAgICAgIGNvbXBvbmVudCdzIHBhcmVudFxuICAgKi9cbiAgZnVuY3Rpb24gRXZlbnQoY29tcG9uZW50LCBvcHRpb25zKSB7XG4gICAgaWYgKCEoY29tcG9uZW50IGluc3RhbmNlb2YgSUNBTC5Db21wb25lbnQpKSB7XG4gICAgICBvcHRpb25zID0gY29tcG9uZW50O1xuICAgICAgY29tcG9uZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb21wb25lbnQgPSBuZXcgSUNBTC5Db21wb25lbnQoJ3ZldmVudCcpO1xuICAgIH1cblxuICAgIHRoaXMuX3JhbmdlRXhjZXB0aW9uQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuZXhjZXB0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5yYW5nZUV4Y2VwdGlvbnMgPSBbXTtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc3RyaWN0RXhjZXB0aW9ucykge1xuICAgICAgdGhpcy5zdHJpY3RFeGNlcHRpb25zID0gb3B0aW9ucy5zdHJpY3RFeGNlcHRpb25zO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZXhjZXB0aW9ucykge1xuICAgICAgb3B0aW9ucy5leGNlcHRpb25zLmZvckVhY2godGhpcy5yZWxhdGVFeGNlcHRpb24sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jb21wb25lbnQucGFyZW50ICYmICF0aGlzLmlzUmVjdXJyZW5jZUV4Y2VwdGlvbigpKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudC5wYXJlbnQuZ2V0QWxsU3ViY29tcG9uZW50cygndmV2ZW50JykuZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuaGFzUHJvcGVydHkoJ3JlY3VycmVuY2UtaWQnKSkge1xuICAgICAgICAgIHRoaXMucmVsYXRlRXhjZXB0aW9uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgRXZlbnQucHJvdG90eXBlID0ge1xuXG4gICAgVEhJU0FOREZVVFVSRTogJ1RISVNBTkRGVVRVUkUnLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiByZWxhdGVkIGV2ZW50IGV4Y2VwdGlvbnMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5FdmVudFtdfVxuICAgICAqL1xuICAgIGV4Y2VwdGlvbnM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHdpbGwgdmVyaWZ5IGV4Y2VwdGlvbnMgYXJlIHJlbGF0ZWQgYnkgdGhlaXIgVVVJRC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0cmljdEV4Y2VwdGlvbnM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogUmVsYXRlcyBhIGdpdmVuIGV2ZW50IGV4Y2VwdGlvbiB0byB0aGlzIG9iamVjdC4gIElmIHRoZSBnaXZlbiBjb21wb25lbnRcbiAgICAgKiBkb2VzIG5vdCBzaGFyZSB0aGUgVUlEIG9mIHRoaXMgZXZlbnQgaXQgY2Fubm90IGJlIHJlbGF0ZWQgYW5kIHdpbGwgdGhyb3dcbiAgICAgKiBhbiBleGNlcHRpb24uXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIGNvbXBvbmVudCBpcyBhbiBleGNlcHRpb24gaXQgY2Fubm90IGhhdmUgb3RoZXIgZXhjZXB0aW9uc1xuICAgICAqIHJlbGF0ZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fElDQUwuRXZlbnR9IG9iaiAgICAgICBDb21wb25lbnQgb3IgZXZlbnRcbiAgICAgKi9cbiAgICByZWxhdGVFeGNlcHRpb246IGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKHRoaXMuaXNSZWN1cnJlbmNlRXhjZXB0aW9uKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgcmVsYXRlIGV4Y2VwdGlvbiB0byBleGNlcHRpb25zJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBJQ0FMLkNvbXBvbmVudCkge1xuICAgICAgICBvYmogPSBuZXcgSUNBTC5FdmVudChvYmopO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdHJpY3RFeGNlcHRpb25zICYmIG9iai51aWQgIT09IHRoaXMudWlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXR0ZW1wdGVkIHRvIHJlbGF0ZSB1bnJlbGF0ZWQgZXhjZXB0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpZCA9IG9iai5yZWN1cnJlbmNlSWQudG9TdHJpbmcoKTtcblxuICAgICAgLy8gd2UgZG9uJ3Qgc29ydCBvciBtYW5hZ2UgZXhjZXB0aW9ucyBkaXJlY3RseVxuICAgICAgLy8gaGVyZSB0aGUgcmVjdXJyZW5jZSBleHBhbmRlciBoYW5kbGVzIHRoYXQuXG4gICAgICB0aGlzLmV4Y2VwdGlvbnNbaWRdID0gb2JqO1xuXG4gICAgICAvLyBpbmRleCBSQU5HRT1USElTQU5ERlVUVVJFIGV4Y2VwdGlvbnMgc28gd2UgY2FuXG4gICAgICAvLyBsb29rIHRoZW0gdXAgbGF0ZXIgaW4gZ2V0T2NjdXJyZW5jZURldGFpbHMuXG4gICAgICBpZiAob2JqLm1vZGlmaWVzRnV0dXJlKCkpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBbXG4gICAgICAgICAgb2JqLnJlY3VycmVuY2VJZC50b1VuaXhUaW1lKCksIGlkXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gd2Uga2VlcCB0aGVtIHNvcnRlZCBzbyB3ZSBjYW4gZmluZCB0aGUgbmVhcmVzdFxuICAgICAgICAvLyB2YWx1ZSBsYXRlciBvbi4uLlxuICAgICAgICB2YXIgaWR4ID0gSUNBTC5oZWxwZXJzLmJpbnNlYXJjaEluc2VydChcbiAgICAgICAgICB0aGlzLnJhbmdlRXhjZXB0aW9ucyxcbiAgICAgICAgICBpdGVtLFxuICAgICAgICAgIGNvbXBhcmVSYW5nZUV4Y2VwdGlvblxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucmFuZ2VFeGNlcHRpb25zLnNwbGljZShpZHgsIDAsIGl0ZW0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhpcyByZWNvcmQgaXMgYW4gZXhjZXB0aW9uIGFuZCBoYXMgdGhlIFJBTkdFPVRISVNBTkRGVVRVUkVcbiAgICAgKiB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBUcnVlLCB3aGVuIGV4Y2VwdGlvbiBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgKi9cbiAgICBtb2RpZmllc0Z1dHVyZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY29tcG9uZW50Lmhhc1Byb3BlcnR5KCdyZWN1cnJlbmNlLWlkJykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLmNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5KCdyZWN1cnJlbmNlLWlkJykuZ2V0UGFyYW1ldGVyKCdyYW5nZScpO1xuICAgICAgcmV0dXJuIHJhbmdlID09PSB0aGlzLlRISVNBTkRGVVRVUkU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSByYW5nZSBleGNlcHRpb24gbmVhcmVzdCB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lfSB0aW1lIHVzdWFsbHkgYW4gb2NjdXJyZW5jZSB0aW1lIG9mIGFuIGV2ZW50XG4gICAgICogQHJldHVybiB7P0lDQUwuRXZlbnR9IHRoZSByZWxhdGVkIGV2ZW50L2V4Y2VwdGlvbiBvciBudWxsXG4gICAgICovXG4gICAgZmluZFJhbmdlRXhjZXB0aW9uOiBmdW5jdGlvbih0aW1lKSB7XG4gICAgICBpZiAoIXRoaXMucmFuZ2VFeGNlcHRpb25zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHV0YyA9IHRpbWUudG9Vbml4VGltZSgpO1xuICAgICAgdmFyIGlkeCA9IElDQUwuaGVscGVycy5iaW5zZWFyY2hJbnNlcnQoXG4gICAgICAgIHRoaXMucmFuZ2VFeGNlcHRpb25zLFxuICAgICAgICBbdXRjXSxcbiAgICAgICAgY29tcGFyZVJhbmdlRXhjZXB0aW9uXG4gICAgICApO1xuXG4gICAgICBpZHggLT0gMTtcblxuICAgICAgLy8gb2NjdXJzIGJlZm9yZVxuICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByYW5nZUl0ZW0gPSB0aGlzLnJhbmdlRXhjZXB0aW9uc1tpZHhdO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrIG9ubHkgKi9cbiAgICAgIGlmICh1dGMgPCByYW5nZUl0ZW1bMF0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByYW5nZUl0ZW1bMV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgb2JqZWN0IGlzIHJldHVybmVkIGJ5IHtAbGluayBJQ0FMLkV2ZW50I2dldE9jY3VycmVuY2VEZXRhaWxzIGdldE9jY3VycmVuY2VEZXRhaWxzfVxuICAgICAqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gb2NjdXJyZW5jZURldGFpbHNcbiAgICAgKiBAbWVtYmVyb2YgSUNBTC5FdmVudFxuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5UaW1lfSByZWN1cnJlbmNlSWQgICAgICAgVGhlIHBhc3NlZCBpbiByZWN1cnJlbmNlIGlkXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLkV2ZW50fSBpdGVtICAgICAgICAgICAgICBUaGUgb2NjdXJyZW5jZVxuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5UaW1lfSBzdGFydERhdGUgICAgICAgICAgVGhlIHN0YXJ0IG9mIHRoZSBvY2N1cnJlbmNlXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLlRpbWV9IGVuZERhdGUgICAgICAgICAgICBUaGUgZW5kIG9mIHRoZSBvY2N1cnJlbmNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvY2N1cnJlbmNlIGRldGFpbHMgYmFzZWQgb24gaXRzIHN0YXJ0IHRpbWUuICBJZiB0aGVcbiAgICAgKiBvY2N1cnJlbmNlIGhhcyBhbiBleGNlcHRpb24gd2lsbCByZXR1cm4gdGhlIGRldGFpbHMgZm9yIHRoYXQgZXhjZXB0aW9uLlxuICAgICAqXG4gICAgICogTk9URTogdGhpcyBtZXRob2QgaXMgaW50ZW5kIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb25cbiAgICAgKiAgICAgICB3aXRoIHRoZSB7QGxpbmsgSUNBTC5FdmVudCNpdGVyYXRvciBpdGVyYXRvcn0gbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IG9jY3VycmVuY2UgdGltZSBvY2N1cnJlbmNlXG4gICAgICogQHJldHVybiB7SUNBTC5FdmVudC5vY2N1cnJlbmNlRGV0YWlsc30gSW5mb3JtYXRpb24gYWJvdXQgdGhlIG9jY3VycmVuY2VcbiAgICAgKi9cbiAgICBnZXRPY2N1cnJlbmNlRGV0YWlsczogZnVuY3Rpb24ob2NjdXJyZW5jZSkge1xuICAgICAgdmFyIGlkID0gb2NjdXJyZW5jZS50b1N0cmluZygpO1xuICAgICAgdmFyIHV0Y0lkID0gb2NjdXJyZW5jZS5jb252ZXJ0VG9ab25lKElDQUwuVGltZXpvbmUudXRjVGltZXpvbmUpLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgaXRlbTtcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIC8vWFhYOiBDbG9uZT9cbiAgICAgICAgcmVjdXJyZW5jZUlkOiBvY2N1cnJlbmNlXG4gICAgICB9O1xuXG4gICAgICBpZiAoaWQgaW4gdGhpcy5leGNlcHRpb25zKSB7XG4gICAgICAgIGl0ZW0gPSByZXN1bHQuaXRlbSA9IHRoaXMuZXhjZXB0aW9uc1tpZF07XG4gICAgICAgIHJlc3VsdC5zdGFydERhdGUgPSBpdGVtLnN0YXJ0RGF0ZTtcbiAgICAgICAgcmVzdWx0LmVuZERhdGUgPSBpdGVtLmVuZERhdGU7XG4gICAgICAgIHJlc3VsdC5pdGVtID0gaXRlbTtcbiAgICAgIH0gZWxzZSBpZiAodXRjSWQgaW4gdGhpcy5leGNlcHRpb25zKSB7XG4gICAgICAgIGl0ZW0gPSB0aGlzLmV4Y2VwdGlvbnNbdXRjSWRdO1xuICAgICAgICByZXN1bHQuc3RhcnREYXRlID0gaXRlbS5zdGFydERhdGU7XG4gICAgICAgIHJlc3VsdC5lbmREYXRlID0gaXRlbS5lbmREYXRlO1xuICAgICAgICByZXN1bHQuaXRlbSA9IGl0ZW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByYW5nZSBleGNlcHRpb25zIChSQU5HRT1USElTQU5ERlVUVVJFKSBoYXZlIGFcbiAgICAgICAgLy8gbG93ZXIgcHJpb3JpdHkgdGhlbiBkaXJlY3QgZXhjZXB0aW9ucyBidXRcbiAgICAgICAgLy8gbXVzdCBiZSBhY2NvdW50ZWQgZm9yIGZpcnN0LiBUaGVpciBpdGVtIGlzXG4gICAgICAgIC8vIGFsd2F5cyB0aGUgZmlyc3QgZXhjZXB0aW9uIHdpdGggdGhlIHJhbmdlIHByb3AuXG4gICAgICAgIHZhciByYW5nZUV4Y2VwdGlvbklkID0gdGhpcy5maW5kUmFuZ2VFeGNlcHRpb24oXG4gICAgICAgICAgb2NjdXJyZW5jZVxuICAgICAgICApO1xuICAgICAgICB2YXIgZW5kO1xuXG4gICAgICAgIGlmIChyYW5nZUV4Y2VwdGlvbklkKSB7XG4gICAgICAgICAgdmFyIGV4Y2VwdGlvbiA9IHRoaXMuZXhjZXB0aW9uc1tyYW5nZUV4Y2VwdGlvbklkXTtcblxuICAgICAgICAgIC8vIHJhbmdlIGV4Y2VwdGlvbiBtdXN0IG1vZGlmeSBzdGFuZGFyZCB0aW1lXG4gICAgICAgICAgLy8gYnkgdGhlIGRpZmZlcmVuY2UgKGlmIGFueSkgaW4gc3RhcnQvZW5kIHRpbWVzLlxuICAgICAgICAgIHJlc3VsdC5pdGVtID0gZXhjZXB0aW9uO1xuXG4gICAgICAgICAgdmFyIHN0YXJ0RGlmZiA9IHRoaXMuX3JhbmdlRXhjZXB0aW9uQ2FjaGVbcmFuZ2VFeGNlcHRpb25JZF07XG5cbiAgICAgICAgICBpZiAoIXN0YXJ0RGlmZikge1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gZXhjZXB0aW9uLnJlY3VycmVuY2VJZC5jbG9uZSgpO1xuICAgICAgICAgICAgdmFyIG5ld1N0YXJ0ID0gZXhjZXB0aW9uLnN0YXJ0RGF0ZS5jbG9uZSgpO1xuXG4gICAgICAgICAgICAvLyB6b25lcyBtdXN0IGJlIHNhbWUgb3RoZXJ3aXNlIHN1YnRyYWN0IG1heSBiZSBpbmNvcnJlY3QuXG4gICAgICAgICAgICBvcmlnaW5hbC56b25lID0gbmV3U3RhcnQuem9uZTtcbiAgICAgICAgICAgIHN0YXJ0RGlmZiA9IG5ld1N0YXJ0LnN1YnRyYWN0RGF0ZShvcmlnaW5hbCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3JhbmdlRXhjZXB0aW9uQ2FjaGVbcmFuZ2VFeGNlcHRpb25JZF0gPSBzdGFydERpZmY7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHN0YXJ0ID0gb2NjdXJyZW5jZS5jbG9uZSgpO1xuICAgICAgICAgIHN0YXJ0LnpvbmUgPSBleGNlcHRpb24uc3RhcnREYXRlLnpvbmU7XG4gICAgICAgICAgc3RhcnQuYWRkRHVyYXRpb24oc3RhcnREaWZmKTtcblxuICAgICAgICAgIGVuZCA9IHN0YXJ0LmNsb25lKCk7XG4gICAgICAgICAgZW5kLmFkZER1cmF0aW9uKGV4Y2VwdGlvbi5kdXJhdGlvbik7XG5cbiAgICAgICAgICByZXN1bHQuc3RhcnREYXRlID0gc3RhcnQ7XG4gICAgICAgICAgcmVzdWx0LmVuZERhdGUgPSBlbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm8gcmFuZ2UgZXhjZXB0aW9uIHN0YW5kYXJkIGV4cGFuc2lvblxuICAgICAgICAgIGVuZCA9IG9jY3VycmVuY2UuY2xvbmUoKTtcbiAgICAgICAgICBlbmQuYWRkRHVyYXRpb24odGhpcy5kdXJhdGlvbik7XG5cbiAgICAgICAgICByZXN1bHQuZW5kRGF0ZSA9IGVuZDtcbiAgICAgICAgICByZXN1bHQuc3RhcnREYXRlID0gb2NjdXJyZW5jZTtcbiAgICAgICAgICByZXN1bHQuaXRlbSA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQnVpbGRzIGEgcmVjdXIgZXhwYW5zaW9uIGluc3RhbmNlIGZvciBhIHNwZWNpZmljIHBvaW50IGluIHRpbWUgKGRlZmF1bHRzXG4gICAgICogdG8gc3RhcnREYXRlKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lfSBzdGFydFRpbWUgICAgIFN0YXJ0aW5nIHBvaW50IGZvciBleHBhbnNpb25cbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlJlY3VyRXhwYW5zaW9ufSAgICBFeHBhbnNpb24gb2JqZWN0XG4gICAgICovXG4gICAgaXRlcmF0b3I6IGZ1bmN0aW9uKHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIG5ldyBJQ0FMLlJlY3VyRXhwYW5zaW9uKHtcbiAgICAgICAgY29tcG9uZW50OiB0aGlzLmNvbXBvbmVudCxcbiAgICAgICAgZHRzdGFydDogc3RhcnRUaW1lIHx8IHRoaXMuc3RhcnREYXRlXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBldmVudCBpcyByZWN1cnJpbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBUcnVlLCBpZiBldmVudCBpcyByZWN1cnJpbmdcbiAgICAgKi9cbiAgICBpc1JlY3VycmluZzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29tcCA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgcmV0dXJuIGNvbXAuaGFzUHJvcGVydHkoJ3JydWxlJykgfHwgY29tcC5oYXNQcm9wZXJ0eSgncmRhdGUnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBldmVudCBkZXNjcmliZXMgYSByZWN1cnJlbmNlIGV4Y2VwdGlvbi4gU2VlXG4gICAgICoge0B0dXRvcmlhbCB0ZXJtaW5vbG9neX0gZm9yIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICBUcnVlLCBpZiB0aGUgZXZlbnQgZGVzY3JpYmVzIGEgcmVjdXJyZW5jZSBleGNlcHRpb25cbiAgICAgKi9cbiAgICBpc1JlY3VycmVuY2VFeGNlcHRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50Lmhhc1Byb3BlcnR5KCdyZWN1cnJlbmNlLWlkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHR5cGVzIG9mIHJlY3VycmVuY2VzIHRoaXMgZXZlbnQgbWF5IGhhdmUuXG4gICAgICpcbiAgICAgKiBSZXR1cm5lZCBhcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHBvc3NpYmxlIGtleXM6XG4gICAgICpcbiAgICAgKiAgICAtIFlFQVJMWVxuICAgICAqICAgIC0gTU9OVEhMWVxuICAgICAqICAgIC0gV0VFS0xZXG4gICAgICogICAgLSBEQUlMWVxuICAgICAqICAgIC0gTUlOVVRFTFlcbiAgICAgKiAgICAtIFNFQ09ORExZXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3QuPElDQUwuUmVjdXIuZnJlcXVlbmN5VmFsdWVzLCBCb29sZWFuPn1cbiAgICAgKiAgICAgICAgICBPYmplY3Qgb2YgcmVjdXJyZW5jZSBmbGFnc1xuICAgICAqL1xuICAgIGdldFJlY3VycmVuY2VUeXBlczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcnVsZXMgPSB0aGlzLmNvbXBvbmVudC5nZXRBbGxQcm9wZXJ0aWVzKCdycnVsZScpO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IHJ1bGVzLmxlbmd0aDtcbiAgICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJ1bGVzW2ldLmdldEZpcnN0VmFsdWUoKTtcbiAgICAgICAgcmVzdWx0W3ZhbHVlLmZyZXFdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHVpZCBvZiB0aGlzIGV2ZW50XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgdWlkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgndWlkJyk7XG4gICAgfSxcblxuICAgIHNldCB1aWQodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldFByb3AoJ3VpZCcsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0YXJ0IGRhdGVcbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lfVxuICAgICAqL1xuICAgIGdldCBzdGFydERhdGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlyc3RQcm9wKCdkdHN0YXJ0Jyk7XG4gICAgfSxcblxuICAgIHNldCBzdGFydERhdGUodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldFRpbWUoJ2R0c3RhcnQnLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbmQgZGF0ZS4gVGhpcyBjYW4gYmUgdGhlIHJlc3VsdCBkaXJlY3RseSBmcm9tIHRoZSBwcm9wZXJ0eSwgb3IgdGhlXG4gICAgICogZW5kIGRhdGUgY2FsY3VsYXRlZCBmcm9tIHN0YXJ0IGRhdGUgYW5kIGR1cmF0aW9uLiBTZXR0aW5nIHRoZSBwcm9wZXJ0eVxuICAgICAqIHdpbGwgcmVtb3ZlIGFueSBkdXJhdGlvbiBwcm9wZXJ0aWVzLlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgZ2V0IGVuZERhdGUoKSB7XG4gICAgICB2YXIgZW5kRGF0ZSA9IHRoaXMuX2ZpcnN0UHJvcCgnZHRlbmQnKTtcbiAgICAgIGlmICghZW5kRGF0ZSkge1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuX2ZpcnN0UHJvcCgnZHVyYXRpb24nKTtcbiAgICAgICAgICBlbmREYXRlID0gdGhpcy5zdGFydERhdGUuY2xvbmUoKTtcbiAgICAgICAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgZW5kRGF0ZS5hZGREdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIGlmIChlbmREYXRlLmlzRGF0ZSkge1xuICAgICAgICAgICAgICBlbmREYXRlLmRheSArPSAxO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmREYXRlO1xuICAgIH0sXG5cbiAgICBzZXQgZW5kRGF0ZSh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuY29tcG9uZW50Lmhhc1Byb3BlcnR5KCdkdXJhdGlvbicpKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LnJlbW92ZVByb3BlcnR5KCdkdXJhdGlvbicpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0VGltZSgnZHRlbmQnLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkdXJhdGlvbi4gVGhpcyBjYW4gYmUgdGhlIHJlc3VsdCBkaXJlY3RseSBmcm9tIHRoZSBwcm9wZXJ0eSwgb3IgdGhlXG4gICAgICogZHVyYXRpb24gY2FsY3VsYXRlZCBmcm9tIHN0YXJ0IGRhdGUgYW5kIGVuZCBkYXRlLiBTZXR0aW5nIHRoZSBwcm9wZXJ0eVxuICAgICAqIHdpbGwgcmVtb3ZlIGFueSBgZHRlbmRgIHByb3BlcnRpZXMuXG4gICAgICogQHR5cGUge0lDQUwuRHVyYXRpb259XG4gICAgICovXG4gICAgZ2V0IGR1cmF0aW9uKCkge1xuICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5fZmlyc3RQcm9wKCdkdXJhdGlvbicpO1xuICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmREYXRlLnN1YnRyYWN0RGF0ZVR6KHRoaXMuc3RhcnREYXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkdXJhdGlvbjtcbiAgICB9LFxuXG4gICAgc2V0IGR1cmF0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5jb21wb25lbnQuaGFzUHJvcGVydHkoJ2R0ZW5kJykpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQucmVtb3ZlUHJvcGVydHkoJ2R0ZW5kJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NldFByb3AoJ2R1cmF0aW9uJywgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG9jYXRpb24gb2YgdGhlIGV2ZW50LlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgnbG9jYXRpb24nKTtcbiAgICB9LFxuXG4gICAgc2V0IGxvY2F0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0UHJvcCgnbG9jYXRpb24nLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBhdHRlbmRlZXMgaW4gdGhlIGV2ZW50XG4gICAgICogQHR5cGUge0lDQUwuUHJvcGVydHlbXX1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgYXR0ZW5kZWVzKCkge1xuICAgICAgLy9YWFg6IFRoaXMgaXMgd2F5IGxhbWUgd2Ugc2hvdWxkIGhhdmUgYSBiZXR0ZXJcbiAgICAgIC8vICAgICBkYXRhIHN0cnVjdHVyZSBmb3IgdGhpcyBsYXRlci5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5nZXRBbGxQcm9wZXJ0aWVzKCdhdHRlbmRlZScpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBzdW1tYXJ5XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgc3VtbWFyeSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ3N1bW1hcnknKTtcbiAgICB9LFxuXG4gICAgc2V0IHN1bW1hcnkodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldFByb3AoJ3N1bW1hcnknLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBkZXNjcmlwdGlvbi5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ2Rlc2NyaXB0aW9uJyk7XG4gICAgfSxcblxuICAgIHNldCBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0UHJvcCgnZGVzY3JpcHRpb24nLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBjb2xvciBmcm9tIFtyZmM3OTg2XShodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzc5ODYpXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlyc3RQcm9wKCdjb2xvcicpO1xuICAgIH0sXG5cbiAgICBzZXQgY29sb3IodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldFByb3AoJ2NvbG9yJywgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3JnYW5pemVyIHZhbHVlIGFzIGFuIHVyaS4gSW4gbW9zdCBjYXNlcyB0aGlzIGlzIGEgbWFpbHRvOiB1cmksIGJ1dFxuICAgICAqIGl0IGNhbiBhbHNvIGJlIHNvbWV0aGluZyBlbHNlLCBsaWtlIHVybjp1dWlkOi4uLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IG9yZ2FuaXplcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ29yZ2FuaXplcicpO1xuICAgIH0sXG5cbiAgICBzZXQgb3JnYW5pemVyKHZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXRQcm9wKCdvcmdhbml6ZXInLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZXF1ZW5jZSB2YWx1ZSBmb3IgdGhpcyBldmVudC4gVXNlZCBmb3Igc2NoZWR1bGluZ1xuICAgICAqIHNlZSB7QHR1dG9yaWFsIHRlcm1pbm9sb2d5fS5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBzZXF1ZW5jZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ3NlcXVlbmNlJyk7XG4gICAgfSxcblxuICAgIHNldCBzZXF1ZW5jZSh2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0UHJvcCgnc2VxdWVuY2UnLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSByZWN1cnJlbmNlIGlkIGZvciB0aGlzIGV2ZW50LiBTZWUge0B0dXRvcmlhbCB0ZXJtaW5vbG9neX0gZm9yIGRldGFpbHMuXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICBnZXQgcmVjdXJyZW5jZUlkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgncmVjdXJyZW5jZS1pZCcpO1xuICAgIH0sXG5cbiAgICBzZXQgcmVjdXJyZW5jZUlkKHZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXRUaW1lKCdyZWN1cnJlbmNlLWlkJywgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQvdXBkYXRlIGEgdGltZSBwcm9wZXJ0eSdzIHZhbHVlLlxuICAgICAqIFRoaXMgd2lsbCBhbHNvIHVwZGF0ZSB0aGUgVFpJRCBvZiB0aGUgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBUT0RPOiB0aGlzIG1ldGhvZCBoYW5kbGVzIHRoZSBjYXNlIHdoZXJlIHdlIGFyZSBzd2l0Y2hpbmdcbiAgICAgKiBmcm9tIGEga25vd24gdGltZXpvbmUgdG8gYW4gaW1wbGllZCB0aW1lem9uZSAob25lIHdpdGhvdXQgVFpJRCkuXG4gICAgICogVGhpcyBkb2VzIF9ub3RfIGhhbmRsZSB0aGUgY2FzZSBvZiBtb3ZpbmcgYmV0d2VlbiBhIGtub3duXG4gICAgICogIChieSBUaW1lem9uZVNlcnZpY2UpIHRpbWV6b25lIHRvIGFuIHVua25vd24gdGltZXpvbmUuLi5cbiAgICAgKlxuICAgICAqIFdlIHdpbGwgbm90IGFkZC9yZW1vdmUvdXBkYXRlIHRoZSBWVElNRVpPTkUgc3ViY29tcG9uZW50c1xuICAgICAqICBsZWFkaW5nIHRvIGludmFsaWQgSUNBTCBkYXRhLi4uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWUgICAgIFRoZSBwcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IHRpbWUgICAgICBUaGUgdGltZSB0byBzZXRcbiAgICAgKi9cbiAgICBfc2V0VGltZTogZnVuY3Rpb24ocHJvcE5hbWUsIHRpbWUpIHtcbiAgICAgIHZhciBwcm9wID0gdGhpcy5jb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eShwcm9wTmFtZSk7XG5cbiAgICAgIGlmICghcHJvcCkge1xuICAgICAgICBwcm9wID0gbmV3IElDQUwuUHJvcGVydHkocHJvcE5hbWUpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudC5hZGRQcm9wZXJ0eShwcm9wKTtcbiAgICAgIH1cblxuICAgICAgLy8gdXRjIGFuZCBsb2NhbCBkb24ndCBnZXQgYSB0emlkXG4gICAgICBpZiAoXG4gICAgICAgIHRpbWUuem9uZSA9PT0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lIHx8XG4gICAgICAgIHRpbWUuem9uZSA9PT0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZVxuICAgICAgKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgdHppZFxuICAgICAgICBwcm9wLnJlbW92ZVBhcmFtZXRlcigndHppZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC5zZXRQYXJhbWV0ZXIoJ3R6aWQnLCB0aW1lLnpvbmUudHppZCk7XG4gICAgICB9XG5cbiAgICAgIHByb3Auc2V0VmFsdWUodGltZSk7XG4gICAgfSxcblxuICAgIF9zZXRQcm9wOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5jb21wb25lbnQudXBkYXRlUHJvcGVydHlXaXRoVmFsdWUobmFtZSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICBfZmlyc3RQcm9wOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eVZhbHVlKG5hbWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC50b1N0cmluZygpO1xuICAgIH1cblxuICB9O1xuXG4gIGZ1bmN0aW9uIGNvbXBhcmVSYW5nZUV4Y2VwdGlvbihhLCBiKSB7XG4gICAgaWYgKGFbMF0gPiBiWzBdKSByZXR1cm4gMTtcbiAgICBpZiAoYlswXSA+IGFbMF0pIHJldHVybiAtMTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBFdmVudDtcbn0oKSk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG5cbi8qKlxuICogVGhpcyBzeW1ib2wgaXMgZnVydGhlciBkZXNjcmliZWQgbGF0ZXIgb25cbiAqIEBpZ25vcmVcbiAqL1xuSUNBTC5Db21wb25lbnRQYXJzZXIgPSAoZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFRoZSBDb21wb25lbnRQYXJzZXIgaXMgdXNlZCB0byBwcm9jZXNzIGEgU3RyaW5nIG9yIGpDYWwgT2JqZWN0LFxuICAgKiBmaXJpbmcgY2FsbGJhY2tzIGZvciB2YXJpb3VzIGZvdW5kIGNvbXBvbmVudHMsIGFzIHdlbGwgYXMgY29tcGxldGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIG9wdGlvbnMgPSB7XG4gICAqICAgLy8gd2hlbiBmYWxzZSBubyBldmVudHMgd2lsbCBiZSBlbWl0dGVkIGZvciB0eXBlXG4gICAqICAgcGFyc2VFdmVudDogdHJ1ZSxcbiAgICogICBwYXJzZVRpbWV6b25lOiB0cnVlXG4gICAqIH07XG4gICAqXG4gICAqIHZhciBwYXJzZXIgPSBuZXcgSUNBTC5Db21wb25lbnRQYXJzZXIob3B0aW9ucyk7XG4gICAqXG4gICAqIHBhcnNlci5vbmV2ZW50KGV2ZW50Q29tcG9uZW50KSB7XG4gICAqICAgLy8uLi5cbiAgICogfVxuICAgKlxuICAgKiAvLyBvbnRpbWV6b25lLCBldGMuLi5cbiAgICpcbiAgICogcGFyc2VyLm9uY29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICpcbiAgICogfTtcbiAgICpcbiAgICogcGFyc2VyLnByb2Nlc3Moc3RyaW5nT3JDb21wb25lbnQpO1xuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFsaWFzIElDQUwuQ29tcG9uZW50UGFyc2VyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAgICAgICAgQ29tcG9uZW50IHBhcnNlciBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5wYXJzZUV2ZW50ICAgICAgICBXaGV0aGVyIGV2ZW50cyBzaG91bGQgYmUgcGFyc2VkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5wYXJzZVRpbWV6ZW9uZSAgICBXaGV0aGVyIHRpbWV6b25lcyBzaG91bGQgYmUgcGFyc2VkXG4gICAqL1xuICBmdW5jdGlvbiBDb21wb25lbnRQYXJzZXIob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Yob3B0aW9ucykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIGtleTtcbiAgICBmb3IgKGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgQ29tcG9uZW50UGFyc2VyLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgcGFyc2UgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBwYXJzZUV2ZW50OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBwYXJzZSB0aW1lem9uZXNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHBhcnNlVGltZXpvbmU6IHRydWUsXG5cblxuICAgIC8qIFNBWCBsaWtlIGV2ZW50cyBoZXJlIGZvciByZWZlcmVuY2UgKi9cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gcGFyc2luZyBpcyBjb21wbGV0ZVxuICAgICAqIEBjYWxsYmFja1xuICAgICAqL1xuICAgIG9uY29tcGxldGU6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCBpZiBhbiBlcnJvciBvY2N1cnMgZHVyaW5nIHBhcnNpbmcuXG4gICAgICpcbiAgICAgKiBAY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnIgZGV0YWlscyBvZiBlcnJvclxuICAgICAqL1xuICAgIG9uZXJyb3I6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uKGVycikge30sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGEgdG9wIGxldmVsIGNvbXBvbmVudCAoVlRJTUVaT05FKSBpcyBmb3VuZFxuICAgICAqXG4gICAgICogQGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV6b25lfSBjb21wb25lbnQgICAgIFRpbWV6b25lIG9iamVjdFxuICAgICAqL1xuICAgIG9udGltZXpvbmU6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uKGNvbXBvbmVudCkge30sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGEgdG9wIGxldmVsIGNvbXBvbmVudCAoVkVWRU5UKSBpcyBmb3VuZC5cbiAgICAgKlxuICAgICAqIEBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7SUNBTC5FdmVudH0gY29tcG9uZW50ICAgIFRvcCBsZXZlbCBjb21wb25lbnRcbiAgICAgKi9cbiAgICBvbmV2ZW50OiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbihjb21wb25lbnQpIHt9LFxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIHN0cmluZyBvciBwYXJzZSBpY2FsIG9iamVjdC4gIFRoaXMgZnVuY3Rpb24gaXRzZWxmIHdpbGwgcmV0dXJuXG4gICAgICogbm90aGluZyBidXQgd2lsbCBzdGFydCB0aGUgcGFyc2luZyBwcm9jZXNzLlxuICAgICAqXG4gICAgICogRXZlbnRzIG11c3QgYmUgcmVnaXN0ZXJlZCBwcmlvciB0byBjYWxsaW5nIHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudHxTdHJpbmd8T2JqZWN0fSBpY2FsICAgICAgVGhlIGNvbXBvbmVudCB0byBwcm9jZXNzLFxuICAgICAqICAgICAgICBlaXRoZXIgaW4gaXRzIGZpbmFsIGZvcm0sIGFzIGEgakNhbCBPYmplY3QsIG9yIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAqL1xuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGljYWwpIHtcbiAgICAgIC8vVE9ETzogdGhpcyBpcyBzeW5jIG5vdyBpbiB0aGUgZnV0dXJlIHdlIHdpbGwgaGF2ZSBhIGluY3JlbWVudGFsIHBhcnNlci5cbiAgICAgIGlmICh0eXBlb2YoaWNhbCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGljYWwgPSBJQ0FMLnBhcnNlKGljYWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIShpY2FsIGluc3RhbmNlb2YgSUNBTC5Db21wb25lbnQpKSB7XG4gICAgICAgIGljYWwgPSBuZXcgSUNBTC5Db21wb25lbnQoaWNhbCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wb25lbnRzID0gaWNhbC5nZXRBbGxTdWJjb21wb25lbnRzKCk7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuID0gY29tcG9uZW50cy5sZW5ndGg7XG4gICAgICB2YXIgY29tcG9uZW50O1xuXG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG5cbiAgICAgICAgc3dpdGNoIChjb21wb25lbnQubmFtZSkge1xuICAgICAgICAgIGNhc2UgJ3Z0aW1lem9uZSc6XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZVRpbWV6b25lKSB7XG4gICAgICAgICAgICAgIHZhciB0emlkID0gY29tcG9uZW50LmdldEZpcnN0UHJvcGVydHlWYWx1ZSgndHppZCcpO1xuICAgICAgICAgICAgICBpZiAodHppZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub250aW1lem9uZShuZXcgSUNBTC5UaW1lem9uZSh7XG4gICAgICAgICAgICAgICAgICB0emlkOiB0emlkLFxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnRcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3ZldmVudCc6XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZUV2ZW50KSB7XG4gICAgICAgICAgICAgIHRoaXMub25ldmVudChuZXcgSUNBTC5FdmVudChjb21wb25lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvL1hYWDogaWRlYWxseSB3ZSBzaG91bGQgZG8gYSBcIm5leHRUaWNrXCIgaGVyZVxuICAgICAgLy8gICAgIHNvIGluIGFsbCBjYXNlcyB0aGlzIGlzIGFjdHVhbGx5IGFzeW5jLlxuICAgICAgdGhpcy5vbmNvbXBsZXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDb21wb25lbnRQYXJzZXI7XG59KCkpO1xuIl0sIm5hbWVzIjpbIklDQUwiLCJtb2R1bGUiLCJleHBvcnRzIiwiSFRNTFNjcmlwdEVsZW1lbnQiLCJwcm90b3R5cGUiLCJ3aW5kb3ciLCJmb2xkTGVuZ3RoIiwibmV3TGluZUNoYXIiLCJoZWxwZXJzIiwidXBkYXRlVGltZXpvbmVzIiwidmNhbCIsImFsbHN1YnMiLCJwcm9wZXJ0aWVzIiwidnRpbWV6b25lcyIsInJlcVR6aWQiLCJpIiwidHppZCIsIm5hbWUiLCJnZXRBbGxTdWJjb21wb25lbnRzIiwibGVuZ3RoIiwiZ2V0Rmlyc3RQcm9wZXJ0eSIsImdldEZpcnN0VmFsdWUiLCJjb25jYXQiLCJnZXRBbGxQcm9wZXJ0aWVzIiwiZ2V0UGFyYW1ldGVyIiwiaGFzT3duUHJvcGVydHkiLCJyZW1vdmVTdWJjb21wb25lbnQiLCJUaW1lem9uZVNlcnZpY2UiLCJoYXMiLCJhZGRTdWJjb21wb25lbnQiLCJnZXQiLCJjb21wb25lbnQiLCJpc1N0cmljdGx5TmFOIiwibnVtYmVyIiwiaXNOYU4iLCJzdHJpY3RQYXJzZUludCIsInN0cmluZyIsInJlc3VsdCIsInBhcnNlSW50IiwiRXJyb3IiLCJmb3JtYXRDbGFzc1R5cGUiLCJkYXRhIiwidHlwZSIsInVuZGVmaW5lZCIsInVuZXNjYXBlZEluZGV4T2YiLCJidWZmZXIiLCJzZWFyY2giLCJwb3MiLCJpbmRleE9mIiwiYmluc2VhcmNoSW5zZXJ0IiwibGlzdCIsInNlZWtWYWwiLCJjbXBmdW5jIiwibG93IiwiaGlnaCIsIm1pZCIsImNtcHZhbCIsIk1hdGgiLCJmbG9vciIsImR1bXBuIiwiZGVidWciLCJjb25zb2xlIiwiY29uc29sZUR1bXBuIiwiaW5wdXQiLCJsb2ciLCJnZWNrb0R1bXBuIiwiZHVtcCIsImFyZ3VtZW50cyIsImNsb25lIiwiYVNyYyIsImFEZWVwIiwiRGF0ZSIsImdldFRpbWUiLCJBcnJheSIsImlzQXJyYXkiLCJhcnIiLCJwdXNoIiwib2JqIiwiT2JqZWN0IiwiY2FsbCIsImZvbGRsaW5lIiwiYUxpbmUiLCJsaW5lIiwibGluZV9sZW5ndGgiLCJjcCIsImNvZGVQb2ludEF0Iiwic3Vic3RyaW5nIiwic3Vic3RyIiwicGFkMiIsInBhZCIsIlN0cmluZyIsImxlbiIsInRydW5jIiwiY2VpbCIsImluaGVyaXRzIiwiYmFzZSIsImNoaWxkIiwiZXh0cmEiLCJGIiwiZXh0ZW5kIiwic291cmNlIiwidGFyZ2V0Iiwia2V5IiwiZGVzY3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJkZWZpbmVQcm9wZXJ0eSIsImRlc2lnbiIsIkZST01fSUNBTF9ORVdMSU5FIiwiVE9fSUNBTF9ORVdMSU5FIiwiRlJPTV9WQ0FSRF9ORVdMSU5FIiwiVE9fVkNBUkRfTkVXTElORSIsImNyZWF0ZVRleHRUeXBlIiwiZnJvbU5ld2xpbmUiLCJ0b05ld2xpbmUiLCJtYXRjaGVzIiwiZnJvbUlDQUwiLCJhVmFsdWUiLCJzdHJ1Y3R1cmVkRXNjYXBlIiwicmVwbGFjZU5ld2xpbmUiLCJ0b0lDQUwiLCJyZWdFeCIsIlJlZ0V4cCIsInJlcGxhY2UiLCJzdHIiLCJERUZBVUxUX1RZUEVfVEVYVCIsImRlZmF1bHRUeXBlIiwiREVGQVVMVF9UWVBFX1RFWFRfTVVMVEkiLCJtdWx0aVZhbHVlIiwiREVGQVVMVF9UWVBFX1RFWFRfU1RSVUNUVVJFRCIsInN0cnVjdHVyZWRWYWx1ZSIsIkRFRkFVTFRfVFlQRV9JTlRFR0VSIiwiREVGQVVMVF9UWVBFX0RBVEVUSU1FX0RBVEUiLCJhbGxvd2VkVHlwZXMiLCJERUZBVUxUX1RZUEVfREFURVRJTUUiLCJERUZBVUxUX1RZUEVfVVJJIiwiREVGQVVMVF9UWVBFX1VUQ09GRlNFVCIsIkRFRkFVTFRfVFlQRV9SRUNVUiIsIkRFRkFVTFRfVFlQRV9EQVRFX0FORE9SX1RJTUUiLCJyZXBsYWNlTmV3bGluZVJlcGxhY2UiLCJ2YWx1ZSIsIm5ld2xpbmUiLCJjb21tb25Qcm9wZXJ0aWVzIiwiY29tbW9uVmFsdWVzIiwidmFsdWVzIiwiZmxvYXQiLCJwYXJzZWQiLCJwYXJzZUZsb2F0IiwiaW50ZWdlciIsImRlY29yYXRlIiwiVXRjT2Zmc2V0IiwiZnJvbVN0cmluZyIsInVuZGVjb3JhdGUiLCJ0b1N0cmluZyIsImljYWxQYXJhbXMiLCJhbGxvd1hOYW1lIiwiYWxsb3dJYW5hVG9rZW4iLCJ2YWx1ZVR5cGUiLCJtdWx0aVZhbHVlU2VwYXJhdGVEUXVvdGUiLCJpY2FsVmFsdWVzIiwidGV4dCIsInVyaSIsImFTdHJpbmciLCJCaW5hcnkiLCJhQmluYXJ5IiwiYVByb3AiLCJzdHJpY3QiLCJUaW1lIiwiZnJvbURhdGVTdHJpbmciLCJkYXRlIiwiZnJvbURhdGVUaW1lU3RyaW5nIiwiZHVyYXRpb24iLCJEdXJhdGlvbiIsInBlcmlvZCIsInBhcnRzIiwic3BsaXQiLCJpc1ZhbHVlU3RyaW5nIiwiam9pbiIsIlBlcmlvZCIsImZyb21KU09OIiwidG9KU09OIiwicmVjdXIiLCJSZWN1ciIsIl9zdHJpbmdUb0RhdGEiLCJrIiwidmFsIiwibnVtZXJpY0RheVRvSWNhbERheSIsInRvVXBwZXJDYXNlIiwiZnJvbURhdGEiLCJhUmVjdXIiLCJ0aW1lIiwiaWNhbFByb3BlcnRpZXMiLCJkZXRlY3RUeXBlIiwidmNhcmRWYWx1ZXMiLCJWQ2FyZFRpbWUiLCJmcm9tRGF0ZUFuZE9yVGltZVN0cmluZyIsInNwbGl0em9uZSIsIl9zcGxpdFpvbmUiLCJ6b25lIiwiaXNGcm9tSWNhbCIsImxhc3RDaGFyIiwic2lnbkNoYXIiLCJzaWduIiwidGltZXN0YW1wIiwidmNhcmRQYXJhbXMiLCJ2Y2FyZFByb3BlcnRpZXMiLCJ2Y2FyZDNWYWx1ZXMiLCJiaW5hcnkiLCJ2Y2FyZCIsInZjYXJkM1BhcmFtcyIsInZjYXJkM1Byb3BlcnRpZXMiLCJmbiIsIm4iLCJuaWNrbmFtZSIsInBob3RvIiwiYmRheSIsImFkciIsImxhYmVsIiwidGVsIiwiZW1haWwiLCJtYWlsZXIiLCJ0eiIsImdlbyIsInRpdGxlIiwicm9sZSIsImxvZ28iLCJhZ2VudCIsIm9yZyIsIm5vdGUiLCJwcm9kaWQiLCJyZXYiLCJzb3VuZCIsImNsYXNzIiwiaWNhbFNldCIsInBhcmFtIiwicHJvcGVydHkiLCJ2Y2FyZFNldCIsInZjYXJkM1NldCIsImRlZmF1bHRTZXQiLCJjb21wb25lbnRzIiwidmNhcmQzIiwidmV2ZW50IiwidnRvZG8iLCJ2am91cm5hbCIsInZhbGFybSIsInZ0aW1lem9uZSIsImRheWxpZ2h0Iiwic3RhbmRhcmQiLCJpY2FsZW5kYXIiLCJnZXREZXNpZ25TZXQiLCJjb21wb25lbnROYW1lIiwiaXNJbkRlc2lnbiIsInN0cmluZ2lmeSIsIkxJTkVfRU5ESU5HIiwiREVGQVVMVF9WQUxVRV9UWVBFIiwiakNhbCIsImRlc2lnblNldCIsInByb3BzIiwicHJvcElkeCIsInByb3BMZW4iLCJkZXNpZ25TZXROYW1lIiwiY29tcHMiLCJjb21wSWR4IiwiY29tcExlbiIsIm5vRm9sZCIsImpzTmFtZSIsInBhcmFtcyIsInBhcmFtTmFtZSIsIm1hcCIsIl9yZmM2ODY4VW5lc2NhcGUiLCJwcm9wZXJ0eVZhbHVlIiwicHJvcERldGFpbHMiLCJpc0RlZmF1bHQiLCJzbGljZSIsImRlbGltIiwiaW5uZXJNdWx0aSIsIngiLCJSRkM2ODY4X1JFUExBQ0VfTUFQIiwicGFyc2UiLCJDSEFSIiwiTVVMVElWQUxVRV9ERUxJTUlURVIiLCJWQUxVRV9ERUxJTUlURVIiLCJQQVJBTV9ERUxJTUlURVIiLCJQQVJBTV9OQU1FX0RFTElNSVRFUiIsIkRFRkFVTFRfUEFSQU1fVFlQRSIsIlBhcnNlckVycm9yIiwibWVzc2FnZSIsImUiLCJzdGFjayIsInNoaWZ0IiwicGFyc2VyIiwic3RhdGUiLCJyb290IiwiX2VhY2hMaW5lIiwiZXJyIiwiX2hhbmRsZUNvbnRlbnRMaW5lIiwidmFsdWVQb3MiLCJwYXJhbVBvcyIsImxhc3RQYXJhbUluZGV4IiwibGFzdFZhbHVlUG9zIiwicGFyc2VkUGFyYW1zIiwidG9Mb3dlckNhc2UiLCJfcGFyc2VQYXJhbWV0ZXJzIiwibmV3Q29tcG9uZW50IiwicG9wIiwicHJvcGVydHlEZXRhaWxzIiwiX3BhcnNlTXVsdGlWYWx1ZSIsIl9wYXJzZVZhbHVlIiwic3RhcnQiLCJsYXN0UGFyYW0iLCJsY25hbWUiLCJtdmRlbGltIiwiX3JmYzY4NjhFc2NhcGUiLCJuZXh0Q2hhciIsImV4dGVuZGVkVmFsdWUiLCJuZXh0UG9zIiwicHJvcFZhbHVlUG9zIiwiZGVsaW1pdGVyIiwibGFzdFBvcyIsImNhbGxiYWNrIiwiZmlyc3RDaGFyIiwibmV3bGluZU9mZnNldCIsInRyaW0iLCJDb21wb25lbnQiLCJQUk9QRVJUWV9JTkRFWCIsIkNPTVBPTkVOVF9JTkRFWCIsIk5BTUVfSU5ERVgiLCJwYXJlbnQiLCJfaHlkcmF0ZWRQcm9wZXJ0eUNvdW50IiwiX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQiLCJfZGVzaWduU2V0IiwicGFyZW50RGVzaWduIiwiX2h5ZHJhdGVDb21wb25lbnQiLCJpbmRleCIsIl9jb21wb25lbnRzIiwiY29tcCIsIl9oeWRyYXRlUHJvcGVydHkiLCJfcHJvcGVydGllcyIsInByb3AiLCJQcm9wZXJ0eSIsImdldEZpcnN0U3ViY29tcG9uZW50IiwiakNhbExlbiIsImhhc1Byb3BlcnR5IiwiZ2V0Rmlyc3RQcm9wZXJ0eVZhbHVlIiwiX3JlbW92ZU9iamVjdEJ5SW5kZXgiLCJqQ2FsSW5kZXgiLCJjYWNoZSIsInNwbGljZSIsIl9yZW1vdmVPYmplY3QiLCJuYW1lT3JPYmplY3QiLCJvYmplY3RzIiwiY2FjaGVkIiwiX3JlbW92ZUFsbE9iamVjdHMiLCJpZHgiLCJuYW1lT3JDb21wIiwicmVtb3ZlZCIsInJlbW92ZUFsbFN1YmNvbXBvbmVudHMiLCJhZGRQcm9wZXJ0eSIsIlR5cGVFcnJvciIsInJlbW92ZVByb3BlcnR5IiwiYWRkUHJvcGVydHlXaXRoVmFsdWUiLCJzZXRWYWx1ZSIsInVwZGF0ZVByb3BlcnR5V2l0aFZhbHVlIiwibmFtZU9yUHJvcCIsInJlbW92ZUFsbFByb3BlcnRpZXMiLCJQUk9QX0lOREVYIiwiVFlQRV9JTkRFWCIsIlZBTFVFX0lOREVYIiwiX3BhcmVudCIsImdldERlZmF1bHRUeXBlIiwiX3VwZGF0ZVR5cGUiLCJwIiwiZGVzaWduU2V0Q2hhbmdlZCIsImRlc2lnblR5cGUiLCJpc0RlY29yYXRlZCIsImlzTXVsdGlWYWx1ZSIsImlzU3RydWN0dXJlZFZhbHVlIiwiX2h5ZHJhdGVWYWx1ZSIsIl92YWx1ZXMiLCJfZGVjb3JhdGUiLCJfdW5kZWNvcmF0ZSIsIl9zZXREZWNvcmF0ZWRWYWx1ZSIsImdldEZpcnN0UGFyYW1ldGVyIiwicGFyYW1ldGVycyIsInNldFBhcmFtZXRlciIsInJlbW92ZVBhcmFtZXRlciIsImRldGFpbHMiLCJyZXNldFR5cGUiLCJyZW1vdmVBbGxWYWx1ZXMiLCJnZXRWYWx1ZXMiLCJzZXRWYWx1ZXMiLCJpY2FsdHlwZSIsInRvSUNBTFN0cmluZyIsImFEYXRhIiwiaG91cnMiLCJtaW51dGVzIiwiZmFjdG9yIiwiZnJvbVNlY29uZHMiLCJ0b1NlY29uZHMiLCJfbm9ybWFsaXplIiwiYVNlY29uZHMiLCJzZWNzIiwiYWJzIiwiY29tcGFyZSIsImljYWx0aW1lX2NvbXBhcmUiLCJvdGhlciIsImEiLCJiIiwib3B0aW9ucyIsImluc3RhbmNlIiwiZGVjb2RlVmFsdWUiLCJfYjY0X2RlY29kZSIsInNldEVuY29kZWRWYWx1ZSIsIl9iNjRfZW5jb2RlIiwiYmFzZTY0X2VuY29kZSIsImI2NCIsIm8xIiwibzIiLCJvMyIsImgxIiwiaDIiLCJoMyIsImg0IiwiYml0cyIsImFjIiwiZW5jIiwidG1wX2FyciIsImNoYXJDb2RlQXQiLCJjaGFyQXQiLCJyIiwiYmFzZTY0X2RlY29kZSIsImRlYyIsImZyb21DaGFyQ29kZSIsImljYWxwZXJpb2QiLCJ3cmFwcGVkSlNPYmplY3QiLCJlbmQiLCJpY2FsY2xhc3MiLCJnZXREdXJhdGlvbiIsInN1YnRyYWN0RGF0ZSIsImdldEVuZCIsImFkZER1cmF0aW9uIiwiYUxlbmllbnQiLCJmcm9tRGF0ZU9yRGF0ZVRpbWVTdHJpbmciLCJEVVJBVElPTl9MRVRURVJTIiwiaWNhbGR1cmF0aW9uIiwid2Vla3MiLCJkYXlzIiwic2Vjb25kcyIsImlzTmVnYXRpdmUiLCJwcm9wc1RvQ29weSIsInJlc2V0IiwiYU90aGVyIiwidGhpc1NlY29uZHMiLCJvdGhlclNlY29uZHMiLCJub3JtYWxpemUiLCJpY2FsZHVyYXRpb25fZnJvbV9zZWNvbmRzIiwicGFyc2VEdXJhdGlvbkNodW5rIiwibGV0dGVyIiwib2JqZWN0IiwibnVtIiwiaWNhbGR1cmF0aW9uX2Zyb21fc3RyaW5nIiwiYVN0ciIsImRpY3QiLCJjcmVhdGUiLCJjaHVua3MiLCJudW1lcmljIiwiaWNhbGR1cmF0aW9uX2Zyb21fZGF0YSIsIk9QVElPTlMiLCJUaW1lem9uZSIsImljYWx0aW1lem9uZSIsImxvY2F0aW9uIiwidHpuYW1lcyIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiZXhwYW5kZWRVbnRpbFllYXIiLCJjaGFuZ2VzIiwidXRjT2Zmc2V0IiwidHQiLCJ1dGNUaW1lem9uZSIsImxvY2FsVGltZXpvbmUiLCJfZW5zdXJlQ292ZXJhZ2UiLCJ5ZWFyIiwidHRfY2hhbmdlIiwibW9udGgiLCJkYXkiLCJob3VyIiwibWludXRlIiwic2Vjb25kIiwiY2hhbmdlX251bSIsIl9maW5kTmVhcmJ5Q2hhbmdlIiwiY2hhbmdlX251bV90b191c2UiLCJzdGVwIiwiY2hhbmdlIiwicHJldlV0Y09mZnNldCIsImFkanVzdF9jaGFuZ2UiLCJjbXAiLCJfY29tcGFyZV9jaGFuZ2VfZm4iLCJ6b25lX2NoYW5nZSIsInV0Y09mZnNldF9jaGFuZ2UiLCJ0bXBfY2hhbmdlIiwicHJldl96b25lX2NoYW5nZSIsIndhbnRfZGF5bGlnaHQiLCJpc19kYXlsaWdodCIsImljYWx0aW1lem9uZV9maW5kX25lYXJieV9jaGFuZ2UiLCJhWWVhciIsIl9taW5pbXVtRXhwYW5zaW9uWWVhciIsInRvZGF5Iiwibm93IiwiY2hhbmdlc0VuZFllYXIiLCJFWFRSQV9DT1ZFUkFHRSIsIk1BWF9ZRUFSIiwic3ViY29tcHMiLCJfZXhwYW5kQ29tcG9uZW50Iiwic29ydCIsImFDb21wb25lbnQiLCJkdHN0YXJ0IiwiY29udmVydF90em9mZnNldCIsIm9mZnNldCIsImluaXRfY2hhbmdlcyIsImNoYW5nZWJhc2UiLCJyZGF0ZWtleSIsInJkYXRlIiwiaXNEYXRlIiwicnJ1bGUiLCJ1bnRpbCIsImFkanVzdCIsIml0ZXJhdG9yIiwib2NjIiwibmV4dCIsImljYWx0aW1lem9uZV9jb21wYXJlX2NoYW5nZV9mbiIsImNvbnZlcnRfdGltZSIsImljYWx0aW1lem9uZV9jb252ZXJ0X3RpbWUiLCJmcm9tX3pvbmUiLCJ0b196b25lIiwiaWNhbHRpbWV6b25lX2Zyb21EYXRhIiwiaWNhbHRpbWV6b25lX2FkanVzdF9jaGFuZ2UiLCJ6b25lcyIsImNvdW50Iiwia2V5cyIsInV0YyIsIloiLCJVVEMiLCJHTVQiLCJyZWdpc3RlciIsInRpbWV6b25lIiwicmVtb3ZlIiwiaWNhbHRpbWUiLCJfdGltZSIsIl9kb3dDYWNoZSIsIl93bkNhY2hlIiwiX2NhY2hlZFVuaXhUaW1lIiwiX3BlbmRpbmdOb3JtYWxpemF0aW9uIiwiaWNhbHRpbWVfcmVzZXQiLCJlcG9jaFRpbWUiLCJyZXNldFRvIiwiaWNhbHRpbWVfcmVzZXRUbyIsImZyb21KU0RhdGUiLCJpY2FsdGltZV9mcm9tSlNEYXRlIiwiYURhdGUiLCJ1c2VVVEMiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ1NlY29uZHMiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJhWm9uZSIsImRheU9mV2VlayIsImljYWx0aW1lX2RheU9mV2VlayIsImFXZWVrU3RhcnQiLCJmaXJzdERvdyIsIlNVTkRBWSIsImRvd0NhY2hlS2V5IiwicSIsIm0iLCJZIiwiaCIsImRheU9mWWVhciIsImlzX2xlYXAiLCJpc0xlYXBZZWFyIiwiZGl5cG0iLCJkYXlzSW5ZZWFyUGFzc2VkTW9udGgiLCJzdGFydE9mV2VlayIsImVuZE9mV2VlayIsInN0YXJ0T2ZNb250aCIsImVuZE9mTW9udGgiLCJkYXlzSW5Nb250aCIsInN0YXJ0T2ZZZWFyIiwiZW5kT2ZZZWFyIiwic3RhcnREb3lXZWVrIiwiYUZpcnN0RGF5T2ZXZWVrIiwiZGVsdGEiLCJnZXREb21pbmljYWxMZXR0ZXIiLCJudGhXZWVrRGF5IiwiaWNhbHRpbWVfbnRoV2Vla0RheSIsImFEYXlPZldlZWsiLCJhUG9zIiwid2Vla2RheSIsIm90aGVyRGF5Iiwic3RhcnREb3ciLCJlbmREb3ciLCJpc050aFdlZWtEYXkiLCJkb3ciLCJ3ZWVrTnVtYmVyIiwid25DYWNoZUtleSIsIndlZWsxIiwiZHQiLCJpc295ZWFyIiwid2Vla09uZVN0YXJ0cyIsImRheXNCZXR3ZWVuIiwiYW5zd2VyIiwiaWNhbHRpbWVfYWRkIiwiYUR1cmF0aW9uIiwibXVsdCIsImljYWx0aW1lX3N1YnRyYWN0IiwidW5peFRpbWUiLCJ0b1VuaXhUaW1lIiwic3VidHJhY3REYXRlVHoiLCJpY2FsdGltZV9zdWJ0cmFjdF9hYnMiLCJjb21wYXJlRGF0ZU9ubHlUeiIsImljYWx0aW1lX2NvbXBhcmVEYXRlT25seVR6IiwiYXR0ciIsIl9jbXBfYXR0ciIsImNvbnZlcnRUb1pvbmUiLCJyYyIsImNvcHkiLCJ6b25lX2VxdWFscyIsInV0Y19vZmZzZXQiLCJ0b0pTRGF0ZSIsImljYWx0aW1lX25vcm1hbGl6ZSIsImljYWx0aW1lX2FkanVzdCIsImFFeHRyYURheXMiLCJhRXh0cmFIb3VycyIsImFFeHRyYU1pbnV0ZXMiLCJhRXh0cmFTZWNvbmRzIiwiYVRpbWUiLCJtaW51dGVzT3ZlcmZsb3ciLCJob3Vyc092ZXJmbG93IiwiZGF5c092ZXJmbG93IiwieWVhcnNPdmVyZmxvdyIsImZyb21Vbml4VGltZSIsImVwb2NoIiwibXMiLCJzZXR1cE5vcm1hbGl6ZUF0dHJpYnV0ZXMiLCJkZWZpbmVBdHRyIiwiZ2V0VGltZUF0dHIiLCJzZXQiLCJzZXRUaW1lQXR0ciIsImljYWx0aW1lX2RheXNJbk1vbnRoIiwiX2RheXNJbk1vbnRoIiwiZnJvbURheU9mWWVhciIsImljYWx0aW1lX2Zyb21EYXlPZlllYXIiLCJhRGF5T2ZZZWFyIiwiZG95IiwiYXV0b19ub3JtYWxpemUiLCJmcm9tU3RyaW5ndjIiLCJhUHJvcGVydHkiLCJ0IiwiaWNhbHRpbWVfbm93Iiwid2tzdCIsIkRFRkFVTFRfV0VFS19TVEFSVCIsIlRIVVJTREFZIiwieXIiLCJMVFJTIiwiZG9tIiwiaXNMZWFwIiwiTU9OREFZIiwiVFVFU0RBWSIsIldFRE5FU0RBWSIsIkZSSURBWSIsIlNBVFVSREFZIiwiYXBwbHkiLCJwMiIsInkiLCJkIiwibW0iLCJzIiwiaGFzWWVhciIsImhhc01vbnRoIiwiaGFzRGF5IiwiaGFzSG91ciIsImhhc01pbnV0ZSIsImhhc1NlY29uZCIsImRhdGVwYXJ0IiwidGltZXBhcnQiLCJhSWNhbFR5cGUiLCJwYXJ0IiwidiIsInRteiIsInRtIiwic3RvaSIsImR0bGVuIiwidG1sZW4iLCJoYXNEYXNoRGF0ZSIsImhhc0Rhc2hUaW1lIiwibyIsIkRPV19NQVAiLCJTVSIsIk1PIiwiVFUiLCJXRSIsIlRIIiwiRlIiLCJTQSIsIlJFVkVSU0VfRE9XX01BUCIsIkNPUFlfUEFSVFMiLCJpY2FscmVjdXIiLCJpbnRlcnZhbCIsImZyZXEiLCJhU3RhcnQiLCJSZWN1ckl0ZXJhdG9yIiwicnVsZSIsImlzRmluaXRlIiwiaXNmaW5pdGUiLCJpc0J5Q291bnQiLCJpc2J5Y291bnQiLCJhZGRDb21wb25lbnQiLCJhZGRQYXJ0IiwiYVR5cGUiLCJ1Y25hbWUiLCJzZXRDb21wb25lbnQiLCJhVmFsdWVzIiwiZ2V0Q29tcG9uZW50IiwiZ2V0TmV4dE9jY3VycmVuY2UiLCJhU3RhcnRUaW1lIiwiYVJlY3VycmVuY2VJZCIsIml0ZXIiLCJjZHQiLCJ1Y2tleSIsInBhcnREZXNpZ24iLCJvcHRpb25EZXNpZ24iLCJJTlRFUlZBTCIsImljYWxEYXlUb051bWVyaWNEYXkiLCJyZXMiLCJrcGFydHMiLCJpY2FscmVjdXJfdG9TdHJpbmciLCJwYXJzZU51bWVyaWNWYWx1ZSIsIm1pbiIsIm1heCIsInRvTnVtZXJpY0RheSIsInRvSWNhbERheSIsIlZBTElEX0RBWV9OQU1FUyIsIlZBTElEX0JZREFZX1BBUlQiLCJBTExPV0VEX0ZSRVEiLCJGUkVRIiwiZm10SWNhbCIsIkNPVU5UIiwiVU5USUwiLCJXS1NUIiwidGVzdCIsIkJZU0VDT05EIiwiYmluZCIsIkJZTUlOVVRFIiwiQllIT1VSIiwiQllEQVkiLCJCWU1PTlRIREFZIiwiQllZRUFSREFZIiwiQllXRUVLTk8iLCJCWU1PTlRIIiwiQllTRVRQT1MiLCJwYXJ0QXJyIiwicGFydEFycklkeCIsInBhcnRBcnJMZW4iLCJpY2FscmVjdXJfaXRlcmF0b3IiLCJjb21wbGV0ZWQiLCJsYXN0Iiwib2NjdXJyZW5jZV9udW1iZXIiLCJieV9pbmRpY2VzIiwiaW5pdGlhbGl6ZWQiLCJieV9kYXRhIiwiZGF5c19pbmRleCIsImluaXQiLCJpY2FscmVjdXJfaXRlcmF0b3JfaW5pdCIsInNvcnRfYnlkYXlfcnVsZXMiLCJzZXR1cF9kZWZhdWx0cyIsImJ5ZGF5UGFydHMiLCJydWxlRGF5T2ZXZWVrIiwid2tkeSIsImRheU5hbWUiLCJleHBhbmRfeWVhcl9kYXlzIiwiaW5jcmVtZW50X3llYXIiLCJfbmV4dEJ5WWVhckRheSIsImhhc19ieV9kYXRhIiwidGVtcExhc3QiLCJpbml0TGFzdCIsImRheU9mTW9udGgiLCJpbmNyZW1lbnRfbW9udGgiLCJfYnlEYXlBbmRNb250aERheSIsImljYWxyZWN1cl9pdGVyYXRvcl9uZXh0IiwiYmVmb3JlIiwidmFsaWQiLCJuZXh0X3NlY29uZCIsIm5leHRfbWludXRlIiwibmV4dF9ob3VyIiwibmV4dF9kYXkiLCJuZXh0X3dlZWsiLCJuZXh0X21vbnRoIiwibmV4dF95ZWFyIiwiY2hlY2tfY29udHJhY3RpbmdfcnVsZXMiLCJuZXh0X2dlbmVyaWMiLCJpbmNyZW1lbnRfc2Vjb25kIiwiaW5jIiwiaW5jcmVtZW50X2dlbmVyaWMiLCJpbmNyZW1lbnRfbWludXRlIiwiaW5jcmVtZW50X2hvdXIiLCJoYXNfYnlfZGF5IiwidGhpc19mcmVxIiwiaW5jcmVtZW50X21vbnRoZGF5IiwiZW5kX29mX2RhdGEiLCJuZXh0X3dlZWtkYXlfYnlfd2VlayIsIndlZWtfbm8iLCJub3JtYWxpemVCeU1vbnRoRGF5UnVsZXMiLCJydWxlcyIsIm5ld1J1bGVzIiwicnVsZUlkeCIsImlzSW5pdCIsImJ5TW9udGhEYXkiLCJieURheSIsImRhdGVJZHgiLCJkYXRlTGVuIiwiZGF5TGVuIiwiZGF0YUlzVmFsaWQiLCJzZWxmIiwibGFzdERheSIsImluaXRNb250aCIsIm5leHRNb250aCIsIm1vbnRoc0NvdW50ZXIiLCJkYXlJZHgiLCJkYXRhX3ZhbGlkIiwic2V0cG9zIiwic2V0cG9zX3RvdGFsIiwibGFzdF9kYXkiLCJpc19kYXlfaW5fYnlkYXkiLCJjaGVja19zZXRfcG9zaXRpb24iLCJjb2RlZF9kYXkiLCJtYXRjaCIsImFSdWxlVHlwZSIsImFJbnRlcnZhbCIsImFEYXRlQXR0ciIsImFGb2xsb3dpbmdBdHRyIiwiYVByZXZpb3VzSW5jciIsImhhc19ieV9ydWxlIiwiZHRhIiwieWVhcnMiLCJhRmFjdG9yIiwiYU5leHRJbmNyZW1lbnQiLCJuZXh0dW5pdCIsInZhbGlkV2Vla3MiLCJtb250aElkeCIsImZpcnN0X3dlZWsiLCJsYXN0X3dlZWsiLCJ3ZWVrSWR4Iiwid2Vla25vIiwicGFydENvdW50IiwidDEiLCJtb250aGtleSIsInQyIiwibW9udGhkYXlrZXkiLCJ0MyIsImRheV8iLCJtb250aF8iLCJleHBhbmRfYnlfZGF5IiwiZmlyc3RfZG93IiwiZG95X29mZnNldCIsImxhc3RfZG93Iiwic2V0X3Bvc19jb3VudGVyIiwiYnlfbW9udGhfZGF5Iiwic3BJbmRleCIsImRheWNvZGVka2V5IiwibW9udGhfZGF5IiwiZmlyc3RfbWF0Y2hpbmdfZGF5IiwibGFzdF9tYXRjaGluZ19kYXkiLCJleHBhbmRlZERheXMiLCJkYXlrZXkiLCJkYXlzX2xpc3QiLCJ0bXAiLCJzdGFydF9kb3ciLCJlbmRfZG93IiwiZW5kX3llYXJfZGF5IiwidG1wX3N0YXJ0X2RveSIsImZpcnN0IiwidGhpc19kb3ciLCJpY2FscmVjdXJfc29ydF9ieWRheV9ydWxlcyIsImFSdWxlcyIsImoiLCJvbmUiLCJ0d28iLCJjaGVja19jb250cmFjdF9yZXN0cmljdGlvbiIsImluZGV4TWFwVmFsdWUiLCJfaW5kZXhNYXAiLCJydWxlTWFwVmFsdWUiLCJfZXhwYW5kTWFwIiwicGFzcyIsIkNPTlRSQUNUIiwicnVsZVR5cGUiLCJieWRhdGFrZXkiLCJ3ZWVrTm8iLCJyZXEiLCJkZWZ0aW1lIiwiVU5LTk9XTiIsIkVYUEFORCIsIklMTEVHQUwiLCJSZWN1ckV4cGFuc2lvbiIsImZvcm1hdFRpbWUiLCJpdGVtIiwiY29tcGFyZVRpbWUiLCJpc1JlY3VycmluZ0NvbXBvbmVudCIsInJ1bGVEYXRlcyIsImV4RGF0ZXMiLCJjb21wbGV0ZSIsInJ1bGVJdGVyYXRvcnMiLCJydWxlRGF0ZUluYyIsImV4RGF0ZUluYyIsImV4RGF0ZSIsInJ1bGVEYXRlIiwiX2luaXQiLCJydWxlT2ZEYXkiLCJtYXhUcmllcyIsImN1cnJlbnRUcnkiLCJfbmV4dFJlY3VycmVuY2VJdGVyIiwiX25leHRSdWxlRGF5IiwiX25leHRFeERheSIsIl9leHRyYWN0RGF0ZXMiLCJwcm9wZXJ0eU5hbWUiLCJoYW5kbGVQcm9wIiwiZm9yRWFjaCIsIml0ZXJzIiwiaXRlclRpbWUiLCJpdGVySWR4IiwiY2hvc2VuSXRlciIsIkV2ZW50IiwiX3JhbmdlRXhjZXB0aW9uQ2FjaGUiLCJleGNlcHRpb25zIiwicmFuZ2VFeGNlcHRpb25zIiwic3RyaWN0RXhjZXB0aW9ucyIsInJlbGF0ZUV4Y2VwdGlvbiIsImlzUmVjdXJyZW5jZUV4Y2VwdGlvbiIsImV2ZW50IiwiVEhJU0FOREZVVFVSRSIsInVpZCIsImlkIiwicmVjdXJyZW5jZUlkIiwibW9kaWZpZXNGdXR1cmUiLCJjb21wYXJlUmFuZ2VFeGNlcHRpb24iLCJyYW5nZSIsImZpbmRSYW5nZUV4Y2VwdGlvbiIsInJhbmdlSXRlbSIsImdldE9jY3VycmVuY2VEZXRhaWxzIiwib2NjdXJyZW5jZSIsInV0Y0lkIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsInJhbmdlRXhjZXB0aW9uSWQiLCJleGNlcHRpb24iLCJzdGFydERpZmYiLCJvcmlnaW5hbCIsIm5ld1N0YXJ0Iiwic3RhcnRUaW1lIiwiaXNSZWN1cnJpbmciLCJnZXRSZWN1cnJlbmNlVHlwZXMiLCJfZmlyc3RQcm9wIiwiX3NldFByb3AiLCJfc2V0VGltZSIsImF0dGVuZGVlcyIsInN1bW1hcnkiLCJkZXNjcmlwdGlvbiIsImNvbG9yIiwib3JnYW5pemVyIiwic2VxdWVuY2UiLCJwcm9wTmFtZSIsIkNvbXBvbmVudFBhcnNlciIsInBhcnNlRXZlbnQiLCJwYXJzZVRpbWV6b25lIiwib25jb21wbGV0ZSIsIm9uZXJyb3IiLCJvbnRpbWV6b25lIiwib25ldmVudCIsInByb2Nlc3MiLCJpY2FsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ical.js/build/ical.js\n");

/***/ })

};
;