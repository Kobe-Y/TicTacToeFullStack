"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@virtuoso.dev";
exports.ids = ["vendor-chunks/@virtuoso.dev"];
exports.modules = {

/***/ "(ssr)/./node_modules/@virtuoso.dev/react-urx/dist/react-urx.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/@virtuoso.dev/react-urx/dist/react-urx.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   systemToComponent: () => (/* binding */ systemToComponent)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @virtuoso.dev/urx */ \"(ssr)/./node_modules/@virtuoso.dev/urx/dist/urx.esm.js\");\n\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar _excluded = [\n    \"children\"\n];\n/** @internal */ function omit(keys, obj) {\n    var result = {};\n    var index = {};\n    var idx = 0;\n    var len = keys.length;\n    while(idx < len){\n        index[keys[idx]] = 1;\n        idx += 1;\n    }\n    for(var prop in obj){\n        if (!index.hasOwnProperty(prop)) {\n            result[prop] = obj[prop];\n        }\n    }\n    return result;\n}\nvar useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n/**\r\n * Converts a system spec to React component by mapping the system streams to component properties, events and methods. Returns hooks for querying and modifying\r\n * the system streams from the component's child components.\r\n * @param systemSpec The return value from a [[system]] call.\r\n * @param map The streams to props / events / methods mapping Check [[SystemPropsMap]] for more details.\r\n * @param Root The optional React component to render. By default, the resulting component renders nothing, acting as a logical wrapper for its children.\r\n * @returns an object containing the following:\r\n *  - `Component`: the React component.\r\n *  - `useEmitterValue`: a hook that lets child components use values emitted from the specified output stream.\r\n *  - `useEmitter`: a hook that calls the provided callback whenever the specified stream emits a value.\r\n *  - `usePublisher`: a hook which lets child components publish values to the specified stream.\r\n *  <hr />\r\n */ function systemToComponent(systemSpec, map, Root) {\n    var requiredPropNames = Object.keys(map.required || {});\n    var optionalPropNames = Object.keys(map.optional || {});\n    var methodNames = Object.keys(map.methods || {});\n    var eventNames = Object.keys(map.events || {});\n    var Context = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\n    function applyPropsToSystem(system, props) {\n        if (system[\"propsReady\"]) {\n            (0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.publish)(system[\"propsReady\"], false);\n        }\n        for(var _iterator = _createForOfIteratorHelperLoose(requiredPropNames), _step; !(_step = _iterator()).done;){\n            var requiredPropName = _step.value;\n            var stream = system[map.required[requiredPropName]];\n            (0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.publish)(stream, props[requiredPropName]);\n        }\n        for(var _iterator2 = _createForOfIteratorHelperLoose(optionalPropNames), _step2; !(_step2 = _iterator2()).done;){\n            var optionalPropName = _step2.value;\n            if (optionalPropName in props) {\n                var _stream = system[map.optional[optionalPropName]];\n                (0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.publish)(_stream, props[optionalPropName]);\n            }\n        }\n        if (system[\"propsReady\"]) {\n            (0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.publish)(system[\"propsReady\"], true);\n        }\n    }\n    function buildMethods(system) {\n        return methodNames.reduce(function(acc, methodName) {\n            acc[methodName] = function(value) {\n                var stream = system[map.methods[methodName]];\n                (0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.publish)(stream, value);\n            };\n            return acc;\n        }, {});\n    }\n    function buildEventHandlers(system) {\n        return eventNames.reduce(function(handlers, eventName) {\n            handlers[eventName] = (0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.eventHandler)(system[map.events[eventName]]);\n            return handlers;\n        }, {});\n    }\n    /**\r\n   * A React component generated from an urx system\r\n   */ var Component = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function(propsWithChildren, ref) {\n        var children = propsWithChildren.children, props = _objectWithoutPropertiesLoose(propsWithChildren, _excluded);\n        var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function() {\n            return (0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.tap)((0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.init)(systemSpec), function(system) {\n                return applyPropsToSystem(system, props);\n            });\n        }), system = _useState[0];\n        var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.curry1to0)(buildEventHandlers, system)), handlers = _useState2[0];\n        useIsomorphicLayoutEffect(function() {\n            for(var _iterator3 = _createForOfIteratorHelperLoose(eventNames), _step3; !(_step3 = _iterator3()).done;){\n                var eventName = _step3.value;\n                if (eventName in props) {\n                    (0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.subscribe)(handlers[eventName], props[eventName]);\n                }\n            }\n            return function() {\n                Object.values(handlers).map(_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.reset);\n            };\n        }, [\n            props,\n            handlers,\n            system\n        ]);\n        useIsomorphicLayoutEffect(function() {\n            applyPropsToSystem(system, props);\n        });\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, (0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.always)(buildMethods(system)));\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Context.Provider, {\n            value: system\n        }, Root ? /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Root, omit([].concat(requiredPropNames, optionalPropNames, eventNames), props), children) : children);\n    });\n    var usePublisher = function usePublisher(key) {\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.curry2to1)(_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.publish, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context)[key]), [\n            key\n        ]);\n    };\n    /**\r\n   * Returns the value emitted from the stream.\r\n   */ var useEmitterValue = function useEmitterValue(key) {\n        var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n        var source = context[key];\n        var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.curry1to0)(_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.getValue, source)), value = _useState3[0], setValue = _useState3[1];\n        useIsomorphicLayoutEffect(function() {\n            return (0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.subscribe)(source, function(next) {\n                if (next !== value) {\n                    setValue((0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.always)(next));\n                }\n            });\n        }, [\n            source,\n            value\n        ]);\n        return value;\n    };\n    var useEmitter = function useEmitter(key, callback) {\n        var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n        var source = context[key];\n        useIsomorphicLayoutEffect(function() {\n            return (0,_virtuoso_dev_urx__WEBPACK_IMPORTED_MODULE_1__.subscribe)(source, callback);\n        }, [\n            callback,\n            source\n        ]);\n    };\n    return {\n        Component: Component,\n        usePublisher: usePublisher,\n        useEmitterValue: useEmitterValue,\n        useEmitter: useEmitter\n    };\n}\n //# sourceMappingURL=react-urx.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpcnR1b3NvLmRldi9yZWFjdC11cngvZGlzdC9yZWFjdC11cnguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBcUo7QUFDdEI7QUFFL0gsU0FBU21CLDhCQUE4QkMsTUFBTSxFQUFFQyxRQUFRO0lBQ3JELElBQUlELFVBQVUsTUFBTSxPQUFPLENBQUM7SUFDNUIsSUFBSUUsU0FBUyxDQUFDO0lBQ2QsSUFBSUMsYUFBYUMsT0FBT0MsSUFBSSxDQUFDTDtJQUM3QixJQUFJTSxLQUFLQztJQUVULElBQUtBLElBQUksR0FBR0EsSUFBSUosV0FBV0ssTUFBTSxFQUFFRCxJQUFLO1FBQ3RDRCxNQUFNSCxVQUFVLENBQUNJLEVBQUU7UUFDbkIsSUFBSU4sU0FBU1EsT0FBTyxDQUFDSCxRQUFRLEdBQUc7UUFDaENKLE1BQU0sQ0FBQ0ksSUFBSSxHQUFHTixNQUFNLENBQUNNLElBQUk7SUFDM0I7SUFFQSxPQUFPSjtBQUNUO0FBRUEsU0FBU1EsNEJBQTRCQyxDQUFDLEVBQUVDLE1BQU07SUFDNUMsSUFBSSxDQUFDRCxHQUFHO0lBQ1IsSUFBSSxPQUFPQSxNQUFNLFVBQVUsT0FBT0Usa0JBQWtCRixHQUFHQztJQUN2RCxJQUFJRSxJQUFJVixPQUFPVyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDTixHQUFHTyxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQ3BELElBQUlKLE1BQU0sWUFBWUgsRUFBRVEsV0FBVyxFQUFFTCxJQUFJSCxFQUFFUSxXQUFXLENBQUNDLElBQUk7SUFDM0QsSUFBSU4sTUFBTSxTQUFTQSxNQUFNLE9BQU8sT0FBT08sTUFBTUMsSUFBSSxDQUFDWDtJQUNsRCxJQUFJRyxNQUFNLGVBQWUsMkNBQTJDUyxJQUFJLENBQUNULElBQUksT0FBT0Qsa0JBQWtCRixHQUFHQztBQUMzRztBQUVBLFNBQVNDLGtCQUFrQlcsR0FBRyxFQUFFQyxHQUFHO0lBQ2pDLElBQUlBLE9BQU8sUUFBUUEsTUFBTUQsSUFBSWhC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QUFXQSxDQUFDVSw0REFBU0EsQ0FBQ0Ysc0RBQU9BLEVBQUVQLGlEQUFVQSxDQUFDd0UsUUFBUSxDQUFDdEQsSUFBSSxHQUFHO1lBQUNBO1NBQUk7SUFDeEU7SUFDQTs7R0FFQyxHQUdELElBQUlxRixrQkFBa0IsU0FBU0EsZ0JBQWdCckYsR0FBRztRQUNoRCxJQUFJc0YsVUFBVXhHLGlEQUFVQSxDQUFDd0U7UUFDekIsSUFBSTVELFNBQVM0RixPQUFPLENBQUN0RixJQUFJO1FBRXpCLElBQUl1RixhQUFhL0csK0NBQVFBLENBQUNTLDREQUFTQSxDQUFDTyx1REFBUUEsRUFBRUUsVUFDMUNvQyxRQUFReUQsVUFBVSxDQUFDLEVBQUUsRUFDckJDLFdBQVdELFVBQVUsQ0FBQyxFQUFFO1FBRTVCL0MsMEJBQTBCO1lBQ3hCLE9BQU90RCw0REFBU0EsQ0FBQ1EsUUFBUSxTQUFVZ0MsSUFBSTtnQkFDckMsSUFBSUEsU0FBU0ksT0FBTztvQkFDbEIwRCxTQUFTcEcseURBQU1BLENBQUNzQztnQkFDbEI7WUFDRjtRQUNGLEdBQUc7WUFBQ2hDO1lBQVFvQztTQUFNO1FBQ2xCLE9BQU9BO0lBQ1Q7SUFFQSxJQUFJMkQsYUFBYSxTQUFTQSxXQUFXekYsR0FBRyxFQUFFMEYsUUFBUTtRQUNoRCxJQUFJSixVQUFVeEcsaURBQVVBLENBQUN3RTtRQUN6QixJQUFJNUQsU0FBUzRGLE9BQU8sQ0FBQ3RGLElBQUk7UUFDekJ3QywwQkFBMEI7WUFDeEIsT0FBT3RELDREQUFTQSxDQUFDUSxRQUFRZ0c7UUFDM0IsR0FBRztZQUFDQTtZQUFVaEc7U0FBTztJQUN2QjtJQUVBLE9BQU87UUFDTCtFLFdBQVdBO1FBQ1hXLGNBQWNBO1FBQ2RDLGlCQUFpQkE7UUFDakJJLFlBQVlBO0lBQ2Q7QUFDRjtBQUU2QixDQUM3Qix5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aWN0YWN0b2UvLi9ub2RlX21vZHVsZXMvQHZpcnR1b3NvLmRldi9yZWFjdC11cngvZGlzdC9yZWFjdC11cnguZXNtLmpzPzI5MTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgZm9yd2FyZFJlZiwgdXNlU3RhdGUsIHVzZUltcGVyYXRpdmVIYW5kbGUsIGNyZWF0ZUVsZW1lbnQsIHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRhcCwgaW5pdCwgY3VycnkxdG8wLCBzdWJzY3JpYmUsIHJlc2V0LCBhbHdheXMsIHB1Ymxpc2gsIGV2ZW50SGFuZGxlciwgY3VycnkydG8xLCBnZXRWYWx1ZSB9IGZyb20gJ0B2aXJ0dW9zby5kZXYvdXJ4JztcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gIHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAoaXQpIHJldHVybiAoaXQgPSBpdC5jYWxsKG8pKS5uZXh0LmJpbmQoaXQpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxudmFyIF9leGNsdWRlZCA9IFtcImNoaWxkcmVuXCJdO1xuLyoqIEBpbnRlcm5hbCAqL1xuXG5mdW5jdGlvbiBvbWl0KGtleXMsIG9iaikge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBpbmRleCA9IHt9O1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuXG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBpbmRleFtrZXlzW2lkeF1dID0gMTtcbiAgICBpZHggKz0gMTtcbiAgfVxuXG4gIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgaWYgKCFpbmRleC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgcmVzdWx0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIHN5c3RlbSBzcGVjIHRvIFJlYWN0IGNvbXBvbmVudCBieSBtYXBwaW5nIHRoZSBzeXN0ZW0gc3RyZWFtcyB0byBjb21wb25lbnQgcHJvcGVydGllcywgZXZlbnRzIGFuZCBtZXRob2RzLiBSZXR1cm5zIGhvb2tzIGZvciBxdWVyeWluZyBhbmQgbW9kaWZ5aW5nXHJcbiAqIHRoZSBzeXN0ZW0gc3RyZWFtcyBmcm9tIHRoZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzLlxyXG4gKiBAcGFyYW0gc3lzdGVtU3BlYyBUaGUgcmV0dXJuIHZhbHVlIGZyb20gYSBbW3N5c3RlbV1dIGNhbGwuXHJcbiAqIEBwYXJhbSBtYXAgVGhlIHN0cmVhbXMgdG8gcHJvcHMgLyBldmVudHMgLyBtZXRob2RzIG1hcHBpbmcgQ2hlY2sgW1tTeXN0ZW1Qcm9wc01hcF1dIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqIEBwYXJhbSBSb290IFRoZSBvcHRpb25hbCBSZWFjdCBjb21wb25lbnQgdG8gcmVuZGVyLiBCeSBkZWZhdWx0LCB0aGUgcmVzdWx0aW5nIGNvbXBvbmVudCByZW5kZXJzIG5vdGhpbmcsIGFjdGluZyBhcyBhIGxvZ2ljYWwgd3JhcHBlciBmb3IgaXRzIGNoaWxkcmVuLlxyXG4gKiBAcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nOlxyXG4gKiAgLSBgQ29tcG9uZW50YDogdGhlIFJlYWN0IGNvbXBvbmVudC5cclxuICogIC0gYHVzZUVtaXR0ZXJWYWx1ZWA6IGEgaG9vayB0aGF0IGxldHMgY2hpbGQgY29tcG9uZW50cyB1c2UgdmFsdWVzIGVtaXR0ZWQgZnJvbSB0aGUgc3BlY2lmaWVkIG91dHB1dCBzdHJlYW0uXHJcbiAqICAtIGB1c2VFbWl0dGVyYDogYSBob29rIHRoYXQgY2FsbHMgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIHdoZW5ldmVyIHRoZSBzcGVjaWZpZWQgc3RyZWFtIGVtaXRzIGEgdmFsdWUuXHJcbiAqICAtIGB1c2VQdWJsaXNoZXJgOiBhIGhvb2sgd2hpY2ggbGV0cyBjaGlsZCBjb21wb25lbnRzIHB1Ymxpc2ggdmFsdWVzIHRvIHRoZSBzcGVjaWZpZWQgc3RyZWFtLlxyXG4gKiAgPGhyIC8+XHJcbiAqL1xuXG5mdW5jdGlvbiBzeXN0ZW1Ub0NvbXBvbmVudChzeXN0ZW1TcGVjLCBtYXAsIFJvb3QpIHtcbiAgdmFyIHJlcXVpcmVkUHJvcE5hbWVzID0gT2JqZWN0LmtleXMobWFwLnJlcXVpcmVkIHx8IHt9KTtcbiAgdmFyIG9wdGlvbmFsUHJvcE5hbWVzID0gT2JqZWN0LmtleXMobWFwLm9wdGlvbmFsIHx8IHt9KTtcbiAgdmFyIG1ldGhvZE5hbWVzID0gT2JqZWN0LmtleXMobWFwLm1ldGhvZHMgfHwge30pO1xuICB2YXIgZXZlbnROYW1lcyA9IE9iamVjdC5rZXlzKG1hcC5ldmVudHMgfHwge30pO1xuICB2YXIgQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pO1xuXG4gIGZ1bmN0aW9uIGFwcGx5UHJvcHNUb1N5c3RlbShzeXN0ZW0sIHByb3BzKSB7XG4gICAgaWYgKHN5c3RlbVsncHJvcHNSZWFkeSddKSB7XG4gICAgICBwdWJsaXNoKHN5c3RlbVsncHJvcHNSZWFkeSddLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShyZXF1aXJlZFByb3BOYW1lcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgcmVxdWlyZWRQcm9wTmFtZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgdmFyIHN0cmVhbSA9IHN5c3RlbVttYXAucmVxdWlyZWRbcmVxdWlyZWRQcm9wTmFtZV1dO1xuICAgICAgcHVibGlzaChzdHJlYW0sIHByb3BzW3JlcXVpcmVkUHJvcE5hbWVdKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvcHRpb25hbFByb3BOYW1lcyksIF9zdGVwMjsgIShfc3RlcDIgPSBfaXRlcmF0b3IyKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgb3B0aW9uYWxQcm9wTmFtZSA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgaWYgKG9wdGlvbmFsUHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgICAgdmFyIF9zdHJlYW0gPSBzeXN0ZW1bbWFwLm9wdGlvbmFsW29wdGlvbmFsUHJvcE5hbWVdXTtcbiAgICAgICAgcHVibGlzaChfc3RyZWFtLCBwcm9wc1tvcHRpb25hbFByb3BOYW1lXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN5c3RlbVsncHJvcHNSZWFkeSddKSB7XG4gICAgICBwdWJsaXNoKHN5c3RlbVsncHJvcHNSZWFkeSddLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZE1ldGhvZHMoc3lzdGVtKSB7XG4gICAgcmV0dXJuIG1ldGhvZE5hbWVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBtZXRob2ROYW1lKSB7XG5cbiAgICAgIGFjY1ttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgc3RyZWFtID0gc3lzdGVtW21hcC5tZXRob2RzW21ldGhvZE5hbWVdXTtcbiAgICAgICAgcHVibGlzaChzdHJlYW0sIHZhbHVlKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRFdmVudEhhbmRsZXJzKHN5c3RlbSkge1xuICAgIHJldHVybiBldmVudE5hbWVzLnJlZHVjZShmdW5jdGlvbiAoaGFuZGxlcnMsIGV2ZW50TmFtZSkge1xuICAgICAgaGFuZGxlcnNbZXZlbnROYW1lXSA9IGV2ZW50SGFuZGxlcihzeXN0ZW1bbWFwLmV2ZW50c1tldmVudE5hbWVdXSk7XG4gICAgICByZXR1cm4gaGFuZGxlcnM7XG4gICAgfSwge30pO1xuICB9XG4gIC8qKlxyXG4gICAqIEEgUmVhY3QgY29tcG9uZW50IGdlbmVyYXRlZCBmcm9tIGFuIHVyeCBzeXN0ZW1cclxuICAgKi9cblxuXG4gIHZhciBDb21wb25lbnQgPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIChwcm9wc1dpdGhDaGlsZHJlbiwgcmVmKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gcHJvcHNXaXRoQ2hpbGRyZW4uY2hpbGRyZW4sXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHNXaXRoQ2hpbGRyZW4sIF9leGNsdWRlZCk7XG5cbiAgICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRhcChpbml0KHN5c3RlbVNwZWMpLCBmdW5jdGlvbiAoc3lzdGVtKSB7XG4gICAgICAgIHJldHVybiBhcHBseVByb3BzVG9TeXN0ZW0oc3lzdGVtLCBwcm9wcyk7XG4gICAgICB9KTtcbiAgICB9KSxcbiAgICAgICAgc3lzdGVtID0gX3VzZVN0YXRlWzBdO1xuXG4gICAgdmFyIF91c2VTdGF0ZTIgPSB1c2VTdGF0ZShjdXJyeTF0bzAoYnVpbGRFdmVudEhhbmRsZXJzLCBzeXN0ZW0pKSxcbiAgICAgICAgaGFuZGxlcnMgPSBfdXNlU3RhdGUyWzBdO1xuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShldmVudE5hbWVzKSwgX3N0ZXAzOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMoKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICBpZiAoZXZlbnROYW1lIGluIHByb3BzKSB7XG4gICAgICAgICAgc3Vic2NyaWJlKGhhbmRsZXJzW2V2ZW50TmFtZV0sIHByb3BzW2V2ZW50TmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXMoaGFuZGxlcnMpLm1hcChyZXNldCk7XG4gICAgICB9O1xuICAgIH0sIFtwcm9wcywgaGFuZGxlcnMsIHN5c3RlbV0pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgYXBwbHlQcm9wc1RvU3lzdGVtKHN5c3RlbSwgcHJvcHMpO1xuICAgIH0pO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBhbHdheXMoYnVpbGRNZXRob2RzKHN5c3RlbSkpKTtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogc3lzdGVtXG4gICAgfSwgUm9vdCA/IGNyZWF0ZUVsZW1lbnQoUm9vdCwgb21pdChbXS5jb25jYXQocmVxdWlyZWRQcm9wTmFtZXMsIG9wdGlvbmFsUHJvcE5hbWVzLCBldmVudE5hbWVzKSwgcHJvcHMpLCBjaGlsZHJlbikgOiBjaGlsZHJlbik7XG4gIH0pO1xuXG4gIHZhciB1c2VQdWJsaXNoZXIgPSBmdW5jdGlvbiB1c2VQdWJsaXNoZXIoa2V5KSB7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKGN1cnJ5MnRvMShwdWJsaXNoLCB1c2VDb250ZXh0KENvbnRleHQpW2tleV0pLCBba2V5XSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIGVtaXR0ZWQgZnJvbSB0aGUgc3RyZWFtLlxyXG4gICAqL1xuXG5cbiAgdmFyIHVzZUVtaXR0ZXJWYWx1ZSA9IGZ1bmN0aW9uIHVzZUVtaXR0ZXJWYWx1ZShrZXkpIHtcbiAgICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoQ29udGV4dCk7XG4gICAgdmFyIHNvdXJjZSA9IGNvbnRleHRba2V5XTtcblxuICAgIHZhciBfdXNlU3RhdGUzID0gdXNlU3RhdGUoY3VycnkxdG8wKGdldFZhbHVlLCBzb3VyY2UpKSxcbiAgICAgICAgdmFsdWUgPSBfdXNlU3RhdGUzWzBdLFxuICAgICAgICBzZXRWYWx1ZSA9IF91c2VTdGF0ZTNbMV07XG5cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzdWJzY3JpYmUoc291cmNlLCBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICBpZiAobmV4dCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICBzZXRWYWx1ZShhbHdheXMobmV4dCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBbc291cmNlLCB2YWx1ZV0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICB2YXIgdXNlRW1pdHRlciA9IGZ1bmN0aW9uIHVzZUVtaXR0ZXIoa2V5LCBjYWxsYmFjaykge1xuICAgIHZhciBjb250ZXh0ID0gdXNlQ29udGV4dChDb250ZXh0KTtcbiAgICB2YXIgc291cmNlID0gY29udGV4dFtrZXldO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHN1YnNjcmliZShzb3VyY2UsIGNhbGxiYWNrKTtcbiAgICB9LCBbY2FsbGJhY2ssIHNvdXJjZV0pO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgQ29tcG9uZW50OiBDb21wb25lbnQsXG4gICAgdXNlUHVibGlzaGVyOiB1c2VQdWJsaXNoZXIsXG4gICAgdXNlRW1pdHRlclZhbHVlOiB1c2VFbWl0dGVyVmFsdWUsXG4gICAgdXNlRW1pdHRlcjogdXNlRW1pdHRlclxuICB9O1xufVxuXG5leHBvcnQgeyBzeXN0ZW1Ub0NvbXBvbmVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3QtdXJ4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJjcmVhdGVDb250ZXh0IiwiZm9yd2FyZFJlZiIsInVzZVN0YXRlIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsImNyZWF0ZUVsZW1lbnQiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsInVzZUNvbnRleHQiLCJ0YXAiLCJpbml0IiwiY3VycnkxdG8wIiwic3Vic2NyaWJlIiwicmVzZXQiLCJhbHdheXMiLCJwdWJsaXNoIiwiZXZlbnRIYW5kbGVyIiwiY3VycnkydG8xIiwiZ2V0VmFsdWUiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsInNvdXJjZSIsImV4Y2x1ZGVkIiwidGFyZ2V0Iiwic291cmNlS2V5cyIsIk9iamVjdCIsImtleXMiLCJrZXkiLCJpIiwibGVuZ3RoIiwiaW5kZXhPZiIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm8iLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJhcnIiLCJsZW4iLCJhcnIyIiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSIsImFsbG93QXJyYXlMaWtlIiwiaXQiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm5leHQiLCJiaW5kIiwiaXNBcnJheSIsImRvbmUiLCJ2YWx1ZSIsIlR5cGVFcnJvciIsIl9leGNsdWRlZCIsIm9taXQiLCJvYmoiLCJyZXN1bHQiLCJpbmRleCIsImlkeCIsInByb3AiLCJoYXNPd25Qcm9wZXJ0eSIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJkb2N1bWVudCIsInN5c3RlbVRvQ29tcG9uZW50Iiwic3lzdGVtU3BlYyIsIm1hcCIsIlJvb3QiLCJyZXF1aXJlZFByb3BOYW1lcyIsInJlcXVpcmVkIiwib3B0aW9uYWxQcm9wTmFtZXMiLCJvcHRpb25hbCIsIm1ldGhvZE5hbWVzIiwibWV0aG9kcyIsImV2ZW50TmFtZXMiLCJldmVudHMiLCJDb250ZXh0IiwiYXBwbHlQcm9wc1RvU3lzdGVtIiwic3lzdGVtIiwicHJvcHMiLCJfaXRlcmF0b3IiLCJfc3RlcCIsInJlcXVpcmVkUHJvcE5hbWUiLCJzdHJlYW0iLCJfaXRlcmF0b3IyIiwiX3N0ZXAyIiwib3B0aW9uYWxQcm9wTmFtZSIsIl9zdHJlYW0iLCJidWlsZE1ldGhvZHMiLCJyZWR1Y2UiLCJhY2MiLCJtZXRob2ROYW1lIiwiYnVpbGRFdmVudEhhbmRsZXJzIiwiaGFuZGxlcnMiLCJldmVudE5hbWUiLCJDb21wb25lbnQiLCJwcm9wc1dpdGhDaGlsZHJlbiIsInJlZiIsImNoaWxkcmVuIiwiX3VzZVN0YXRlIiwiX3VzZVN0YXRlMiIsIl9pdGVyYXRvcjMiLCJfc3RlcDMiLCJ2YWx1ZXMiLCJQcm92aWRlciIsImNvbmNhdCIsInVzZVB1Ymxpc2hlciIsInVzZUVtaXR0ZXJWYWx1ZSIsImNvbnRleHQiLCJfdXNlU3RhdGUzIiwic2V0VmFsdWUiLCJ1c2VFbWl0dGVyIiwiY2FsbGJhY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@virtuoso.dev/react-urx/dist/react-urx.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@virtuoso.dev/urx/dist/urx.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@virtuoso.dev/urx/dist/urx.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   always: () => (/* binding */ always),\n/* harmony export */   call: () => (/* binding */ call),\n/* harmony export */   combineLatest: () => (/* binding */ combineLatest),\n/* harmony export */   compose: () => (/* binding */ compose),\n/* harmony export */   connect: () => (/* binding */ connect),\n/* harmony export */   curry1to0: () => (/* binding */ curry1to0),\n/* harmony export */   curry2to1: () => (/* binding */ curry2to1),\n/* harmony export */   debounceTime: () => (/* binding */ debounceTime),\n/* harmony export */   defaultComparator: () => (/* binding */ defaultComparator),\n/* harmony export */   distinctUntilChanged: () => (/* binding */ distinctUntilChanged),\n/* harmony export */   duc: () => (/* binding */ duc),\n/* harmony export */   eventHandler: () => (/* binding */ eventHandler),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   getValue: () => (/* binding */ getValue),\n/* harmony export */   handleNext: () => (/* binding */ handleNext),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   joinProc: () => (/* binding */ joinProc),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mapTo: () => (/* binding */ mapTo),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   pipe: () => (/* binding */ pipe),\n/* harmony export */   prop: () => (/* binding */ prop),\n/* harmony export */   publish: () => (/* binding */ publish),\n/* harmony export */   reset: () => (/* binding */ reset),\n/* harmony export */   scan: () => (/* binding */ scan),\n/* harmony export */   skip: () => (/* binding */ skip),\n/* harmony export */   statefulStream: () => (/* binding */ statefulStream),\n/* harmony export */   statefulStreamFromEmitter: () => (/* binding */ statefulStreamFromEmitter),\n/* harmony export */   stream: () => (/* binding */ stream),\n/* harmony export */   streamFromEmitter: () => (/* binding */ streamFromEmitter),\n/* harmony export */   subscribe: () => (/* binding */ subscribe),\n/* harmony export */   system: () => (/* binding */ system),\n/* harmony export */   tap: () => (/* binding */ tap),\n/* harmony export */   throttleTime: () => (/* binding */ throttleTime),\n/* harmony export */   thrush: () => (/* binding */ thrush),\n/* harmony export */   tup: () => (/* binding */ tup),\n/* harmony export */   withLatestFrom: () => (/* binding */ withLatestFrom)\n/* harmony export */ });\nvar PUBLISH = 0;\nvar SUBSCRIBE = 1;\nvar RESET = 2;\nvar VALUE = 4;\n/**\r\n * Utils includes\r\n * - a handful of functional utilities inspired by or taken from the [Ramda library](https://ramdajs.com/);\r\n * - TypeScript crutches - the [[tup]] function.\r\n *\r\n * Use these for your convenience - they are here so that urx is zero-dependency package.\r\n *\r\n * @packageDocumentation\r\n */ /**\r\n * Performs left to right composition of two functions.\r\n */ function compose(a, b) {\n    return function(arg) {\n        return a(b(arg));\n    };\n}\n/**\r\n * Takes a value and applies a function to it.\r\n */ function thrush(arg, proc) {\n    return proc(arg);\n}\n/**\r\n * Takes a 2 argument function and partially applies the first argument.\r\n */ function curry2to1(proc, arg1) {\n    return function(arg2) {\n        return proc(arg1, arg2);\n    };\n}\n/**\r\n * Takes a 1 argument function and returns a function which when called, executes it with the provided argument.\r\n */ function curry1to0(proc, arg) {\n    return function() {\n        return proc(arg);\n    };\n}\n/**\r\n * Returns a function which extracts the property from from the passed object.\r\n */ function prop(property) {\n    return function(object) {\n        return object[property];\n    };\n}\n/**\r\n * Calls callback with the first argument, and returns it.\r\n */ function tap(arg, proc) {\n    proc(arg);\n    return arg;\n}\n/**\r\n *  Utility function to help typescript figure out that what we pass is a tuple and not a generic array.\r\n *  Taken from (this StackOverflow tread)[https://stackoverflow.com/questions/49729550/implicitly-create-a-tuple-in-typescript/52445008#52445008]\r\n */ function tup() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    return args;\n}\n/**\r\n * Calls the passed function.\r\n */ function call(proc) {\n    proc();\n}\n/**\r\n * returns a function which when called always returns the passed value\r\n */ function always(value) {\n    return function() {\n        return value;\n    };\n}\n/**\r\n * returns a function which calls all passed functions in the passed order.\r\n * joinProc does not pass arguments or collect return values.\r\n */ function joinProc() {\n    for(var _len2 = arguments.length, procs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n        procs[_key2] = arguments[_key2];\n    }\n    return function() {\n        procs.map(call);\n    };\n}\nfunction noop() {}\n/**\r\n * urx Actions operate on streams - `publish` publishes data in a stream, and `subscribe` attaches a subscription to a stream.\r\n * @packageDocumentation\r\n */ /**\r\n * Subscribes the specified [[Subscription]] to the updates from the Emitter.\r\n * The emitter calls the subscription with the new data each time new data is published into it.\r\n *\r\n * ```ts\r\n * const foo = stream<number>();\r\n * subscribe(foo, (value) => console.log(value));\r\n * ```\r\n *\r\n * @returns an [[Unsubscribe]] handle  - calling it will unbind the subscription from the emitter.\r\n *```ts\r\n * const foo = stream<number>();\r\n * const unsub = subscribe(foo, (value) => console.log(value));\r\n * unsub();\r\n *```\r\n */ function subscribe(emitter, subscription) {\n    return emitter(SUBSCRIBE, subscription);\n}\n/**\r\n * Publishes the value into the passed [[Publisher]].\r\n *\r\n * ```ts\r\n * const foo = stream<number>();\r\n * publish(foo, 42);\r\n * ```\r\n */ function publish(publisher, value) {\n    publisher(PUBLISH, value);\n}\n/**\r\n * Clears all subscriptions from the [[Emitter]].\r\n * ```ts\r\n * const foo = stream<number>();\r\n * subscribe(foo, (value) => console.log(value));\r\n * reset(foo);\r\n * publish(foo, 42);\r\n * ```\r\n */ function reset(emitter) {\n    emitter(RESET);\n}\n/**\r\n * Extracts the current value from a stateful stream. Use it only as an escape hatch, as it violates the concept of reactive programming.\r\n * ```ts\r\n * const foo = statefulStream(42);\r\n * console.log(getValue(foo));\r\n * ```\r\n */ function getValue(depot) {\n    return depot(VALUE);\n}\n/**\r\n * Connects two streams - any value emitted from the emitter will be published in the publisher.\r\n * ```ts\r\n * const foo = stream<number>();\r\n * const bar = stream<number>();\r\n * subscribe(bar, (value) => console.log(`Bar emitted ${value}`));\r\n *\r\n * connect(foo, bar);\r\n * publish(foo);\r\n * ```\r\n * @returns an [[Unsubscribe]] handle which will disconnect the two streams.\r\n */ function connect(emitter, publisher) {\n    return subscribe(emitter, curry2to1(publisher, PUBLISH));\n}\n/**\r\n * Executes the passed subscription at most once, for the next emit from the emitter.\r\n * ```ts\r\n * const foo = stream<number>()\r\n * handleNext(foo, value => console.log(value)) // called once, with 42\r\n * publish(foo, 42)\r\n * publish(foo, 43)\r\n * ```\r\n * @returns an [[Unsubscribe]] handle to unbind the subscription if necessary.\r\n */ function handleNext(emitter, subscription) {\n    var unsub = emitter(SUBSCRIBE, function(value) {\n        unsub();\n        subscription(value);\n    });\n    return unsub;\n}\n/**\r\n * Streams are the basic building blocks of a reactive system. Think of them as the system permanent \"data tubes\".\r\n *\r\n * A stream acts as both an [[Emitter]] and [[Publisher]]. Each stream can have multiple {@link Subscription | Subscriptions}.\r\n *\r\n * urx streams are either **stateless** or **stateful**.\r\n * Stateless streams emit data to existing subscriptions when published, without keeping track of it.\r\n * Stateful streams remember the last published value and immediately publish it to new subscriptions.\r\n *\r\n * ```ts\r\n * import { stream, statefulStream, publish, subscribe } from \"@virtuoso.dev/urx\";\r\n *\r\n * // foo is a stateless stream\r\n * const foo = stream<number>();\r\n *\r\n * publish(foo, 42);\r\n * // this subsription will not be called...\r\n * subscribe(foo, (value) => console.log(value));\r\n * // it will only catch published values after it\r\n * publish(foo, 43);\r\n *\r\n * // stateful streams always start with an initial value\r\n * const bar = statefulStream(42);\r\n *\r\n * // subscribing to a stateful stream\r\n * // immediately calls the subscription with the current value\r\n * subscribe(bar, (value) => console.log(value));\r\n *\r\n * // subsequent publishing works just like stateless streams\r\n * publish(bar, 43);\r\n * ```\r\n * @packageDocumentation\r\n */ /**\r\n * Constructs a new stateless stream.\r\n * ```ts\r\n * const foo = stream<number>();\r\n * ```\r\n * @typeParam T the type of values to publish in the stream.\r\n * @returns a [[Stream]]\r\n */ function stream() {\n    var subscriptions = [];\n    return function(action, arg) {\n        switch(action){\n            case RESET:\n                subscriptions.splice(0, subscriptions.length);\n                return;\n            case SUBSCRIBE:\n                subscriptions.push(arg);\n                return function() {\n                    var indexOf = subscriptions.indexOf(arg);\n                    if (indexOf > -1) {\n                        subscriptions.splice(indexOf, 1);\n                    }\n                };\n            case PUBLISH:\n                subscriptions.slice().forEach(function(subscription) {\n                    subscription(arg);\n                });\n                return;\n            default:\n                throw new Error(\"unrecognized action \" + action);\n        }\n    };\n}\n/**\r\n * Constructs a new stateful stream.\r\n * ```ts\r\n * const foo = statefulStream(42);\r\n * ```\r\n * @param initial the initial value in the stream.\r\n * @typeParam T the type of values to publish in the stream. If omitted, the function infers it from the initial value.\r\n * @returns a [[StatefulStream]]\r\n */ function statefulStream(initial) {\n    var value = initial;\n    var innerSubject = stream();\n    return function(action, arg) {\n        switch(action){\n            case SUBSCRIBE:\n                var subscription = arg;\n                subscription(value);\n                break;\n            case PUBLISH:\n                value = arg;\n                break;\n            case VALUE:\n                return value;\n        }\n        return innerSubject(action, arg);\n    };\n}\n/**\r\n * Event handlers are special emitters which can have **at most one active subscription**.\r\n * Subscribing to an event handler unsubscribes the previous subscription, if present.\r\n * ```ts\r\n * const foo = stream<number>();\r\n * const fooEvent = eventHandler(foo);\r\n *\r\n * // will be called once with 42\r\n * subscribe(fooEvent, (value) => console.log(`Sub 1 ${value}`));\r\n * publish(foo, 42);\r\n *\r\n * // unsubscribes sub 1\r\n * subscribe(fooEvent, (value) => console.log(`Sub 2 ${value}`));\r\n * publish(foo, 43);\r\n * ```\r\n * @param emitter the source emitter.\r\n * @returns the single-subscription emitter.\r\n */ function eventHandler(emitter) {\n    var unsub;\n    var currentSubscription;\n    var cleanup = function cleanup() {\n        return unsub && unsub();\n    };\n    return function(action, subscription) {\n        switch(action){\n            case SUBSCRIBE:\n                if (subscription) {\n                    if (currentSubscription === subscription) {\n                        return;\n                    }\n                    cleanup();\n                    currentSubscription = subscription;\n                    unsub = subscribe(emitter, subscription);\n                    return unsub;\n                } else {\n                    cleanup();\n                    return noop;\n                }\n            case RESET:\n                cleanup();\n                currentSubscription = null;\n                return;\n            default:\n                throw new Error(\"unrecognized action \" + action);\n        }\n    };\n}\n/**\r\n * Creates and connects a \"junction\" stream to the specified emitter. Often used with [[pipe]], to avoid the multiple evaluation of operator sets.\r\n *\r\n * ```ts\r\n * const foo = stream<number>();\r\n *\r\n * const fooX2 = pipe(\r\n *   foo,\r\n *   map((value) => {\r\n *     console.log(`multiplying ${value}`);\r\n *     return value * 2;\r\n *   })\r\n * );\r\n *\r\n * subscribe(fooX2, (value) => console.log(value));\r\n * subscribe(fooX2, (value) => console.log(value));\r\n *\r\n * publish(foo, 42); // executes the map operator twice for each subscription.\r\n *\r\n * const sharedFooX2 = streamFromEmitter(pipe(\r\n *   foo,\r\n *   map((value) => {\r\n *     console.log(`shared multiplying ${value}`);\r\n *     return value * 2;\r\n *   })\r\n * ));\r\n *\r\n * subscribe(sharedFooX2, (value) => console.log(value));\r\n * subscribe(sharedFooX2, (value) => console.log(value));\r\n *\r\n * publish(foo, 42);\r\n *```\r\n * @returns the resulting stream.\r\n */ function streamFromEmitter(emitter) {\n    return tap(stream(), function(stream) {\n        return connect(emitter, stream);\n    });\n}\n/**\r\n * Creates and connects a \"junction\" stateful stream to the specified emitter. Often used with [[pipe]], to avoid the multiple evaluation of operator sets.\r\n *\r\n * ```ts\r\n * const foo = stream<number>();\r\n *\r\n * const fooX2 = pipe(\r\n *   foo,\r\n *   map((value) => {\r\n *     console.log(`multiplying ${value}`);\r\n *     return value * 2;\r\n *   })\r\n * );\r\n *\r\n * subscribe(fooX2, (value) => console.log(value));\r\n * subscribe(fooX2, (value) => console.log(value));\r\n *\r\n * publish(foo, 42); // executes the map operator twice for each subscription.\r\n *\r\n * const sharedFooX2 = statefulStreamFromEmitter(pipe(\r\n *   foo,\r\n *   map((value) => {\r\n *     console.log(`shared multiplying ${value}`);\r\n *     return value * 2;\r\n *   })\r\n * ), 42);\r\n *\r\n * subscribe(sharedFooX2, (value) => console.log(value));\r\n * subscribe(sharedFooX2, (value) => console.log(value));\r\n *\r\n * publish(foo, 42);\r\n *```\r\n * @param initial the initial value in the stream.\r\n * @returns the resulting stateful stream.\r\n */ function statefulStreamFromEmitter(emitter, initial) {\n    return tap(statefulStream(initial), function(stream) {\n        return connect(emitter, stream);\n    });\n}\n/**\r\n *\r\n * Stream values can be transformed and controlled by {@link pipe | **piping**} through **operators**.\r\n * urx includes several operators like [[map]], [[filter]], [[scan]], and [[throttleTime]].\r\n * The [[withLatestFrom]] operator allows the combination of values from other streams.\r\n *\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * // create an emitter that first adds 2 to the passed value, then multiplies it by * 2\r\n * const bar = pipe(foo, map(value => value + 2), map(value => value * 2))\r\n * subscribe(bar, value => console.log(value))\r\n * publish(foo, 2) // outputs 8\r\n * ```\r\n *\r\n * ### Implementing Custom Operators\r\n * To implement your own operators, implement the [[Operator]] interface.\r\n * @packageDocumentation\r\n */ /** @internal */ function combineOperators() {\n    for(var _len = arguments.length, operators = new Array(_len), _key = 0; _key < _len; _key++){\n        operators[_key] = arguments[_key];\n    }\n    return function(subscriber) {\n        return operators.reduceRight(thrush, subscriber);\n    };\n}\nfunction pipe(source) {\n    for(var _len2 = arguments.length, operators = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n        operators[_key2 - 1] = arguments[_key2];\n    }\n    // prettier-ignore\n    var project = combineOperators.apply(void 0, operators);\n    return function(action, subscription) {\n        switch(action){\n            case SUBSCRIBE:\n                return subscribe(source, project(subscription));\n            case RESET:\n                reset(source);\n                return;\n            default:\n                throw new Error(\"unrecognized action \" + action);\n        }\n    };\n}\n/**\r\n * The default [[Comparator]] for [[distinctUntilChanged]] and [[duc]].\r\n */ function defaultComparator(previous, next) {\n    return previous === next;\n}\n/**\r\n * Filters out identical values. Pass an optional [[Comparator]] if you need to filter non-primitive values.\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * subscribe(\r\n *  pipe(foo, distinctUntilChanged()),\r\n *  console.log\r\n * ) // will be called only once\r\n *\r\n * publish(foo, 42)\r\n * publish(foo, 42)\r\n * ```\r\n */ function distinctUntilChanged(comparator) {\n    if (comparator === void 0) {\n        comparator = defaultComparator;\n    }\n    var current;\n    return function(done) {\n        return function(next) {\n            if (!comparator(current, next)) {\n                current = next;\n                done(next);\n            }\n        };\n    };\n}\n/**\r\n * Filters out values for which the predicator does not return `true`-ish.\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * subscribe(\r\n *  pipe(foo, filter(value => value % 2 === 0)),\r\n *  console.log\r\n * ) // will be called only with even values\r\n *\r\n * publish(foo, 2)\r\n * publish(foo, 3)\r\n * publish(foo, 4)\r\n * publish(foo, 5)\r\n * ```\r\n */ function filter(predicate) {\n    return function(done) {\n        return function(value) {\n            predicate(value) && done(value);\n        };\n    };\n}\n/**\r\n * Maps values using the provided project function.\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * subscribe(\r\n *  pipe(foo, map(value => value * 2)),\r\n *  console.log\r\n * ) // 4, 6\r\n *\r\n * publish(foo, 2)\r\n * publish(foo, 3)\r\n * ```\r\n */ function map(project) {\n    return function(done) {\n        return compose(done, project);\n    };\n}\n/**\r\n * Maps values to the hard-coded value.\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * subscribe(\r\n *  pipe(foo, mapTo(3)),\r\n *  console.log\r\n * ) // 3, 3\r\n *\r\n * publish(foo, 1)\r\n * publish(foo, 2)\r\n * ```\r\n */ function mapTo(value) {\n    return function(done) {\n        return function() {\n            return done(value);\n        };\n    };\n}\n/**\r\n * Works like Array#reduce.\r\n * Applies an accumulator function on the emitter, and outputs intermediate result. Starts with the initial value.\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * subscribe(\r\n *  pipe(foo, scan((acc, value) => acc + value, 2),\r\n *  console.log\r\n * ) // 3, 5\r\n *\r\n * publish(foo, 1)\r\n * publish(foo, 2)\r\n * ```\r\n */ function scan(scanner, initial) {\n    return function(done) {\n        return function(value) {\n            return done(initial = scanner(initial, value));\n        };\n    };\n}\n/**\r\n * Skips the specified amount of values from the emitter.\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * subscribe(\r\n *  pipe(foo, skip(2)),\r\n *  console.log\r\n * ) // 3, 4\r\n *\r\n * publish(foo, 1) // skipped\r\n * publish(foo, 2) // skipped\r\n * publish(foo, 3)\r\n * publish(foo, 4)\r\n * ```\r\n */ function skip(times) {\n    return function(done) {\n        return function(value) {\n            times > 0 ? times-- : done(value);\n        };\n    };\n}\n/**\r\n * Throttles flowing values at the provided interval in milliseconds.\r\n * [Throttle VS Debounce in SO](https://stackoverflow.com/questions/25991367/difference-between-throttling-and-debouncing-a-function).\r\n *\r\n * ```ts\r\n *  const foo = stream<number>()\r\n *  publish(foo, 1)\r\n *\r\n *  setTimeout(() => publish(foo, 2), 20)\r\n *  setTimeout(() => publish(foo, 3), 20)\r\n *\r\n *  subscribe(pipe(foo, throttleTime(50)), val => {\r\n *    console.log(value); // 3\r\n *  })\r\n * ```\r\n */ function throttleTime(interval) {\n    var currentValue;\n    var timeout;\n    return function(done) {\n        return function(value) {\n            currentValue = value;\n            if (timeout) {\n                return;\n            }\n            timeout = setTimeout(function() {\n                timeout = undefined;\n                done(currentValue);\n            }, interval);\n        };\n    };\n}\n/**\r\n * Debounces flowing values at the provided interval in milliseconds.\r\n * [Throttle VS Debounce in SO](https://stackoverflow.com/questions/25991367/difference-between-throttling-and-debouncing-a-function).\r\n *\r\n * ```ts\r\n *  const foo = stream<number>()\r\n *  publish(foo, 1)\r\n *\r\n *  setTimeout(() => publish(foo, 2), 20)\r\n *  setTimeout(() => publish(foo, 3), 20)\r\n *\r\n *  subscribe(pipe(foo, debounceTime(50)), val => {\r\n *    console.log(value); // 3\r\n *  })\r\n * ```\r\n */ function debounceTime(interval) {\n    var currentValue;\n    var timeout;\n    return function(done) {\n        return function(value) {\n            currentValue = value;\n            if (timeout) {\n                clearTimeout(timeout);\n            }\n            timeout = setTimeout(function() {\n                done(currentValue);\n            }, interval);\n        };\n    };\n}\nfunction withLatestFrom() {\n    for(var _len3 = arguments.length, sources = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){\n        sources[_key3] = arguments[_key3];\n    }\n    var values = new Array(sources.length);\n    var called = 0;\n    var pendingCall = null;\n    var allCalled = Math.pow(2, sources.length) - 1;\n    sources.forEach(function(source, index) {\n        var bit = Math.pow(2, index);\n        subscribe(source, function(value) {\n            var prevCalled = called;\n            called = called | bit;\n            values[index] = value;\n            if (prevCalled !== allCalled && called === allCalled && pendingCall) {\n                pendingCall();\n                pendingCall = null;\n            }\n        });\n    });\n    return function(done) {\n        return function(value) {\n            var call = function call() {\n                return done([\n                    value\n                ].concat(values));\n            };\n            if (called === allCalled) {\n                call();\n            } else {\n                pendingCall = call;\n            }\n        };\n    };\n}\n/**\r\n * Transformers change and combine streams, similar to operators.\r\n * urx comes with two combinators - [[combineLatest]] and [[merge]], and one convenience filter - [[duc]].\r\n *\r\n * @packageDocumentation\r\n */ /**\r\n * Merges one or more emitters from the same type into a new Emitter which emits values from any of the source emitters.\r\n * ```ts\r\n * const foo = stream<number>()\r\n * const bar = stream<number>()\r\n *\r\n * subscribe(merge(foo, bar), (value) => console.log(value)) // 42, 43\r\n *\r\n * publish(foo, 42)\r\n * publish(bar, 43)\r\n * ```\r\n */ function merge() {\n    for(var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++){\n        sources[_key] = arguments[_key];\n    }\n    return function(action, subscription) {\n        switch(action){\n            case SUBSCRIBE:\n                return joinProc.apply(void 0, sources.map(function(source) {\n                    return subscribe(source, subscription);\n                }));\n            case RESET:\n                // do nothing, we are stateless\n                return;\n            default:\n                throw new Error(\"unrecognized action \" + action);\n        }\n    };\n}\n/**\r\n * A convenience wrapper that emits only the distinct values from the passed Emitter. Wraps [[pipe]] and [[distinctUntilChanged]].\r\n *\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * // this line...\r\n * const a = duc(foo)\r\n *\r\n * // is equivalent to this\r\n * const b = pipe(distinctUntilChanged(foo))\r\n * ```\r\n *\r\n * @param source The source emitter.\r\n * @param comparator optional custom comparison function for the two values.\r\n *\r\n * @typeParam T the type of the value emitted by the source.\r\n *\r\n * @returns the resulting emitter.\r\n */ function duc(source, comparator) {\n    if (comparator === void 0) {\n        comparator = defaultComparator;\n    }\n    return pipe(source, distinctUntilChanged(comparator));\n}\nfunction combineLatest() {\n    var innerSubject = stream();\n    for(var _len2 = arguments.length, emitters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n        emitters[_key2] = arguments[_key2];\n    }\n    var values = new Array(emitters.length);\n    var called = 0;\n    var allCalled = Math.pow(2, emitters.length) - 1;\n    emitters.forEach(function(source, index) {\n        var bit = Math.pow(2, index);\n        subscribe(source, function(value) {\n            values[index] = value;\n            called = called | bit;\n            if (called === allCalled) {\n                publish(innerSubject, values);\n            }\n        });\n    });\n    return function(action, subscription) {\n        switch(action){\n            case SUBSCRIBE:\n                if (called === allCalled) {\n                    subscription(values);\n                }\n                return subscribe(innerSubject, subscription);\n            case RESET:\n                return reset(innerSubject);\n            default:\n                throw new Error(\"unrecognized action \" + action);\n        }\n    };\n}\n/**\r\n * `system` defines a specification of a system - its constructor, dependencies and if it should act as a singleton in a system dependency tree.\r\n * When called, system returns a [[SystemSpec]], which is then initialized along with its dependencies by passing it to [[init]].\r\n *\r\n * ```ts\r\n * @import { subscribe, publish, system, init, tup, connect, map, pipe } from 'urx'\r\n *\r\n * // a simple system with two streams\r\n * const sys1 = system(() => {\r\n *  const a = stream<number>()\r\n *  const b = stream<number>()\r\n *\r\n *  connect(pipe(a, map(value => value * 2)), b)\r\n *  return { a, b }\r\n * })\r\n *\r\n * // a second system which depends on the streams from the first one\r\n * const sys2 = system(([ {a, b} ]) => {\r\n *  const c = stream<number>()\r\n *  connect(pipe(b, map(value => value * 2)), c)\r\n *  // re-export the `a` stream, keep `b` internal\r\n *  return { a, c }\r\n * }, tup(sys1))\r\n *\r\n * // init will recursively initialize sys2 dependencies, in this case sys1\r\n * const { a, c } = init(sys2)\r\n * subscribe(c, c => console.log(`Value multiplied by 4`, c))\r\n * publish(a, 2)\r\n * ```\r\n *\r\n * #### Singletons in Dependency Tree\r\n *\r\n * By default, systems will be initialized only once if encountered multiple times in the dependency tree.\r\n * In the below dependency system tree, systems `b` and `c` will receive the same stream instances from system `a` when system `d` is initialized.\r\n * ```txt\r\n *   a\r\n *  / \\\r\n * b   c\r\n *  \\ /\r\n *   d\r\n * ```\r\n * If `a` gets `{singleton: false}` as a last argument, `init` creates two separate instances - one for `b` and one for `c`.\r\n *\r\n * @param constructor the system constructor function. Initialize and connect the streams in its body.\r\n *\r\n * @param dependencies the system dependencies, which the constructor will receive as arguments.\r\n * Use the [[tup]] utility **For TypeScript type inference to work correctly**.\r\n * ```ts\r\n * const sys3 = system(() => { ... }, tup(sys2, sys1))\r\n * ```\r\n * @param __namedParameters Options\r\n * @param singleton determines if the system will act as a singleton in a system dependency tree. `true` by default.\r\n */ function system(constructor, dependencies, _temp) {\n    if (dependencies === void 0) {\n        dependencies = [];\n    }\n    var _ref = _temp === void 0 ? {\n        singleton: true\n    } : _temp, singleton = _ref.singleton;\n    return {\n        id: id(),\n        constructor: constructor,\n        dependencies: dependencies,\n        singleton: singleton\n    };\n}\n/** @internal */ var id = function id() {\n    return Symbol();\n};\n/**\r\n * Initializes a [[SystemSpec]] by recursively initializing its dependencies.\r\n *\r\n * ```ts\r\n * // a simple system with two streams\r\n * const sys1 = system(() => {\r\n *  const a = stream<number>()\r\n *  const b = stream<number>()\r\n *\r\n *  connect(pipe(a, map(value => value * 2)), b)\r\n *  return { a, b }\r\n * })\r\n *\r\n * const { a, b } = init(sys1)\r\n * subscribe(b, b => console.log(b))\r\n * publish(a, 2)\r\n * ```\r\n *\r\n * @returns the [[System]] constructed by the spec constructor.\r\n * @param systemSpec the system spec to initialize.\r\n */ function init(systemSpec) {\n    var singletons = new Map();\n    var _init = function _init(_ref2) {\n        var id = _ref2.id, constructor = _ref2.constructor, dependencies = _ref2.dependencies, singleton = _ref2.singleton;\n        if (singleton && singletons.has(id)) {\n            return singletons.get(id);\n        }\n        var system = constructor(dependencies.map(function(e) {\n            return _init(e);\n        }));\n        if (singleton) {\n            singletons.set(id, system);\n        }\n        return system;\n    };\n    return _init(systemSpec);\n}\n //# sourceMappingURL=urx.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpcnR1b3NvLmRldi91cngvZGlzdC91cnguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsVUFBVTtBQUNkLElBQUlDLFlBQVk7QUFDaEIsSUFBSUMsUUFBUTtBQUNaLElBQUlDLFFBQVE7QUFFWjs7Ozs7Ozs7Q0FRQyxHQUVEOztDQUVDLEdBQ0QsU0FBU0MsUUFBUUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ25CLE9BQU8sU0FBVUMsR0FBRztRQUNsQixPQUFPRixFQUFFQyxFQUFFQztJQUNiO0FBQ0Y7QUFDQTs7Q0FFQyxHQUVELFNBQVNDLE9BQU9ELEdBQUcsRUFBRUUsSUFBSTtJQUN2QixPQUFPQSxLQUFLRjtBQUNkO0FBQ0E7O0NBRUMsR0FFRCxTQUFTRyxVQUFVRCxJQUFJLEVBQUVFLElBQUk7SUFDM0IsT0FBTyxTQUFVQyxJQUFJO1FBQ25CLE9BQU9ILEtBQUtFLE1BQU1DO0lBQ3BCO0FBQ0Y7QUFDQTs7Q0FFQyxHQUVELFNBQVNDLFVBQVVKLElBQUksRUFBRUYsR0FBRztJQUMxQixPQUFPO1FBQ0wsT0FBT0UsS0FBS0Y7SUFDZDtBQUNGO0FBQ0E7O0NBRUMsR0FFRCxTQUFTTyxLQUFLQyxRQUFRO0lBQ3BCLE9BQU8sU0FBVUMsTUFBTTtRQUNyQixPQUFPQSxNQUFNLENBQUNELFNBQVM7SUFDekI7QUFDRjtBQUNBOztDQUVDLEdBRUQsU0FBU0UsSUFBSVYsR0FBRyxFQUFFRSxJQUFJO0lBQ3BCQSxLQUFLRjtJQUNMLE9BQU9BO0FBQ1Q7QUFDQTs7O0NBR0MsR0FFRCxTQUFTVztJQUNQLElBQUssSUFBSUMsT0FBT0MsVUFBVUMsTUFBTSxFQUFFQyxPQUFPLElBQUlDLE1BQU1KLE9BQU9LLE9BQU8sR0FBR0EsT0FBT0wsTUFBTUssT0FBUTtRQUN2RkYsSUFBSSxDQUFDRSxLQUFLLEdBQUdKLFNBQVMsQ0FBQ0ksS0FBSztJQUM5QjtJQUVBLE9B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TixTQUFTQyxZQUFZQyxhQUFhaEYsR0FBRyxDQUFDLFNBQVU4RixDQUFDO1lBQ25ELE9BQU9KLE1BQU1JO1FBQ2Y7UUFFQSxJQUFJWCxXQUFXO1lBQ2JLLFdBQVdPLEdBQUcsQ0FBQ1gsSUFBSU47UUFDckI7UUFFQSxPQUFPQTtJQUNUO0lBRUEsT0FBT1ksTUFBTUg7QUFDZjtBQUVpWixDQUNqWixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aWN0YWN0b2UvLi9ub2RlX21vZHVsZXMvQHZpcnR1b3NvLmRldi91cngvZGlzdC91cnguZXNtLmpzPzIwMGMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFBVQkxJU0ggPSAwO1xudmFyIFNVQlNDUklCRSA9IDE7XG52YXIgUkVTRVQgPSAyO1xudmFyIFZBTFVFID0gNDtcblxuLyoqXHJcbiAqIFV0aWxzIGluY2x1ZGVzXHJcbiAqIC0gYSBoYW5kZnVsIG9mIGZ1bmN0aW9uYWwgdXRpbGl0aWVzIGluc3BpcmVkIGJ5IG9yIHRha2VuIGZyb20gdGhlIFtSYW1kYSBsaWJyYXJ5XShodHRwczovL3JhbWRhanMuY29tLyk7XHJcbiAqIC0gVHlwZVNjcmlwdCBjcnV0Y2hlcyAtIHRoZSBbW3R1cF1dIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBVc2UgdGhlc2UgZm9yIHlvdXIgY29udmVuaWVuY2UgLSB0aGV5IGFyZSBoZXJlIHNvIHRoYXQgdXJ4IGlzIHplcm8tZGVwZW5kZW5jeSBwYWNrYWdlLlxyXG4gKlxyXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cclxuICovXG5cbi8qKlxyXG4gKiBQZXJmb3JtcyBsZWZ0IHRvIHJpZ2h0IGNvbXBvc2l0aW9uIG9mIHR3byBmdW5jdGlvbnMuXHJcbiAqL1xuZnVuY3Rpb24gY29tcG9zZShhLCBiKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIGEoYihhcmcpKTtcbiAgfTtcbn1cbi8qKlxyXG4gKiBUYWtlcyBhIHZhbHVlIGFuZCBhcHBsaWVzIGEgZnVuY3Rpb24gdG8gaXQuXHJcbiAqL1xuXG5mdW5jdGlvbiB0aHJ1c2goYXJnLCBwcm9jKSB7XG4gIHJldHVybiBwcm9jKGFyZyk7XG59XG4vKipcclxuICogVGFrZXMgYSAyIGFyZ3VtZW50IGZ1bmN0aW9uIGFuZCBwYXJ0aWFsbHkgYXBwbGllcyB0aGUgZmlyc3QgYXJndW1lbnQuXHJcbiAqL1xuXG5mdW5jdGlvbiBjdXJyeTJ0bzEocHJvYywgYXJnMSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGFyZzIpIHtcbiAgICByZXR1cm4gcHJvYyhhcmcxLCBhcmcyKTtcbiAgfTtcbn1cbi8qKlxyXG4gKiBUYWtlcyBhIDEgYXJndW1lbnQgZnVuY3Rpb24gYW5kIHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCB3aGVuIGNhbGxlZCwgZXhlY3V0ZXMgaXQgd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnQuXHJcbiAqL1xuXG5mdW5jdGlvbiBjdXJyeTF0bzAocHJvYywgYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByb2MoYXJnKTtcbiAgfTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZXh0cmFjdHMgdGhlIHByb3BlcnR5IGZyb20gZnJvbSB0aGUgcGFzc2VkIG9iamVjdC5cclxuICovXG5cbmZ1bmN0aW9uIHByb3AocHJvcGVydHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0W3Byb3BlcnR5XTtcbiAgfTtcbn1cbi8qKlxyXG4gKiBDYWxscyBjYWxsYmFjayB3aXRoIHRoZSBmaXJzdCBhcmd1bWVudCwgYW5kIHJldHVybnMgaXQuXHJcbiAqL1xuXG5mdW5jdGlvbiB0YXAoYXJnLCBwcm9jKSB7XG4gIHByb2MoYXJnKTtcbiAgcmV0dXJuIGFyZztcbn1cbi8qKlxyXG4gKiAgVXRpbGl0eSBmdW5jdGlvbiB0byBoZWxwIHR5cGVzY3JpcHQgZmlndXJlIG91dCB0aGF0IHdoYXQgd2UgcGFzcyBpcyBhIHR1cGxlIGFuZCBub3QgYSBnZW5lcmljIGFycmF5LlxyXG4gKiAgVGFrZW4gZnJvbSAodGhpcyBTdGFja092ZXJmbG93IHRyZWFkKVtodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTcyOTU1MC9pbXBsaWNpdGx5LWNyZWF0ZS1hLXR1cGxlLWluLXR5cGVzY3JpcHQvNTI0NDUwMDgjNTI0NDUwMDhdXHJcbiAqL1xuXG5mdW5jdGlvbiB0dXAoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gYXJncztcbn1cbi8qKlxyXG4gKiBDYWxscyB0aGUgcGFzc2VkIGZ1bmN0aW9uLlxyXG4gKi9cblxuZnVuY3Rpb24gY2FsbChwcm9jKSB7XG4gIHByb2MoKTtcbn1cbi8qKlxyXG4gKiByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggd2hlbiBjYWxsZWQgYWx3YXlzIHJldHVybnMgdGhlIHBhc3NlZCB2YWx1ZVxyXG4gKi9cblxuZnVuY3Rpb24gYWx3YXlzKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuLyoqXHJcbiAqIHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBjYWxscyBhbGwgcGFzc2VkIGZ1bmN0aW9ucyBpbiB0aGUgcGFzc2VkIG9yZGVyLlxyXG4gKiBqb2luUHJvYyBkb2VzIG5vdCBwYXNzIGFyZ3VtZW50cyBvciBjb2xsZWN0IHJldHVybiB2YWx1ZXMuXHJcbiAqL1xuXG5mdW5jdGlvbiBqb2luUHJvYygpIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBwcm9jcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIHByb2NzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHByb2NzLm1hcChjYWxsKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4vKipcclxuICogdXJ4IEFjdGlvbnMgb3BlcmF0ZSBvbiBzdHJlYW1zIC0gYHB1Ymxpc2hgIHB1Ymxpc2hlcyBkYXRhIGluIGEgc3RyZWFtLCBhbmQgYHN1YnNjcmliZWAgYXR0YWNoZXMgYSBzdWJzY3JpcHRpb24gdG8gYSBzdHJlYW0uXHJcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxyXG4gKi9cbi8qKlxyXG4gKiBTdWJzY3JpYmVzIHRoZSBzcGVjaWZpZWQgW1tTdWJzY3JpcHRpb25dXSB0byB0aGUgdXBkYXRlcyBmcm9tIHRoZSBFbWl0dGVyLlxyXG4gKiBUaGUgZW1pdHRlciBjYWxscyB0aGUgc3Vic2NyaXB0aW9uIHdpdGggdGhlIG5ldyBkYXRhIGVhY2ggdGltZSBuZXcgZGF0YSBpcyBwdWJsaXNoZWQgaW50byBpdC5cclxuICpcclxuICogYGBgdHNcclxuICogY29uc3QgZm9vID0gc3RyZWFtPG51bWJlcj4oKTtcclxuICogc3Vic2NyaWJlKGZvbywgKHZhbHVlKSA9PiBjb25zb2xlLmxvZyh2YWx1ZSkpO1xyXG4gKiBgYGBcclxuICpcclxuICogQHJldHVybnMgYW4gW1tVbnN1YnNjcmliZV1dIGhhbmRsZSAgLSBjYWxsaW5nIGl0IHdpbGwgdW5iaW5kIHRoZSBzdWJzY3JpcHRpb24gZnJvbSB0aGUgZW1pdHRlci5cclxuICpgYGB0c1xyXG4gKiBjb25zdCBmb28gPSBzdHJlYW08bnVtYmVyPigpO1xyXG4gKiBjb25zdCB1bnN1YiA9IHN1YnNjcmliZShmb28sICh2YWx1ZSkgPT4gY29uc29sZS5sb2codmFsdWUpKTtcclxuICogdW5zdWIoKTtcclxuICpgYGBcclxuICovXG5cbmZ1bmN0aW9uIHN1YnNjcmliZShlbWl0dGVyLCBzdWJzY3JpcHRpb24pIHtcbiAgcmV0dXJuIGVtaXR0ZXIoU1VCU0NSSUJFLCBzdWJzY3JpcHRpb24pO1xufVxuLyoqXHJcbiAqIFB1Ymxpc2hlcyB0aGUgdmFsdWUgaW50byB0aGUgcGFzc2VkIFtbUHVibGlzaGVyXV0uXHJcbiAqXHJcbiAqIGBgYHRzXHJcbiAqIGNvbnN0IGZvbyA9IHN0cmVhbTxudW1iZXI+KCk7XHJcbiAqIHB1Ymxpc2goZm9vLCA0Mik7XHJcbiAqIGBgYFxyXG4gKi9cblxuZnVuY3Rpb24gcHVibGlzaChwdWJsaXNoZXIsIHZhbHVlKSB7XG4gIHB1Ymxpc2hlcihQVUJMSVNILCB2YWx1ZSk7XG59XG4vKipcclxuICogQ2xlYXJzIGFsbCBzdWJzY3JpcHRpb25zIGZyb20gdGhlIFtbRW1pdHRlcl1dLlxyXG4gKiBgYGB0c1xyXG4gKiBjb25zdCBmb28gPSBzdHJlYW08bnVtYmVyPigpO1xyXG4gKiBzdWJzY3JpYmUoZm9vLCAodmFsdWUpID0+IGNvbnNvbGUubG9nKHZhbHVlKSk7XHJcbiAqIHJlc2V0KGZvbyk7XHJcbiAqIHB1Ymxpc2goZm9vLCA0Mik7XHJcbiAqIGBgYFxyXG4gKi9cblxuZnVuY3Rpb24gcmVzZXQoZW1pdHRlcikge1xuICBlbWl0dGVyKFJFU0VUKTtcbn1cbi8qKlxyXG4gKiBFeHRyYWN0cyB0aGUgY3VycmVudCB2YWx1ZSBmcm9tIGEgc3RhdGVmdWwgc3RyZWFtLiBVc2UgaXQgb25seSBhcyBhbiBlc2NhcGUgaGF0Y2gsIGFzIGl0IHZpb2xhdGVzIHRoZSBjb25jZXB0IG9mIHJlYWN0aXZlIHByb2dyYW1taW5nLlxyXG4gKiBgYGB0c1xyXG4gKiBjb25zdCBmb28gPSBzdGF0ZWZ1bFN0cmVhbSg0Mik7XHJcbiAqIGNvbnNvbGUubG9nKGdldFZhbHVlKGZvbykpO1xyXG4gKiBgYGBcclxuICovXG5cbmZ1bmN0aW9uIGdldFZhbHVlKGRlcG90KSB7XG4gIHJldHVybiBkZXBvdChWQUxVRSk7XG59XG4vKipcclxuICogQ29ubmVjdHMgdHdvIHN0cmVhbXMgLSBhbnkgdmFsdWUgZW1pdHRlZCBmcm9tIHRoZSBlbWl0dGVyIHdpbGwgYmUgcHVibGlzaGVkIGluIHRoZSBwdWJsaXNoZXIuXHJcbiAqIGBgYHRzXHJcbiAqIGNvbnN0IGZvbyA9IHN0cmVhbTxudW1iZXI+KCk7XHJcbiAqIGNvbnN0IGJhciA9IHN0cmVhbTxudW1iZXI+KCk7XHJcbiAqIHN1YnNjcmliZShiYXIsICh2YWx1ZSkgPT4gY29uc29sZS5sb2coYEJhciBlbWl0dGVkICR7dmFsdWV9YCkpO1xyXG4gKlxyXG4gKiBjb25uZWN0KGZvbywgYmFyKTtcclxuICogcHVibGlzaChmb28pO1xyXG4gKiBgYGBcclxuICogQHJldHVybnMgYW4gW1tVbnN1YnNjcmliZV1dIGhhbmRsZSB3aGljaCB3aWxsIGRpc2Nvbm5lY3QgdGhlIHR3byBzdHJlYW1zLlxyXG4gKi9cblxuZnVuY3Rpb24gY29ubmVjdChlbWl0dGVyLCBwdWJsaXNoZXIpIHtcbiAgcmV0dXJuIHN1YnNjcmliZShlbWl0dGVyLCBjdXJyeTJ0bzEocHVibGlzaGVyLCBQVUJMSVNIKSk7XG59XG4vKipcclxuICogRXhlY3V0ZXMgdGhlIHBhc3NlZCBzdWJzY3JpcHRpb24gYXQgbW9zdCBvbmNlLCBmb3IgdGhlIG5leHQgZW1pdCBmcm9tIHRoZSBlbWl0dGVyLlxyXG4gKiBgYGB0c1xyXG4gKiBjb25zdCBmb28gPSBzdHJlYW08bnVtYmVyPigpXHJcbiAqIGhhbmRsZU5leHQoZm9vLCB2YWx1ZSA9PiBjb25zb2xlLmxvZyh2YWx1ZSkpIC8vIGNhbGxlZCBvbmNlLCB3aXRoIDQyXHJcbiAqIHB1Ymxpc2goZm9vLCA0MilcclxuICogcHVibGlzaChmb28sIDQzKVxyXG4gKiBgYGBcclxuICogQHJldHVybnMgYW4gW1tVbnN1YnNjcmliZV1dIGhhbmRsZSB0byB1bmJpbmQgdGhlIHN1YnNjcmlwdGlvbiBpZiBuZWNlc3NhcnkuXHJcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVOZXh0KGVtaXR0ZXIsIHN1YnNjcmlwdGlvbikge1xuICB2YXIgdW5zdWIgPSBlbWl0dGVyKFNVQlNDUklCRSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdW5zdWIoKTtcbiAgICBzdWJzY3JpcHRpb24odmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIHVuc3ViO1xufVxuXG4vKipcclxuICogU3RyZWFtcyBhcmUgdGhlIGJhc2ljIGJ1aWxkaW5nIGJsb2NrcyBvZiBhIHJlYWN0aXZlIHN5c3RlbS4gVGhpbmsgb2YgdGhlbSBhcyB0aGUgc3lzdGVtIHBlcm1hbmVudCBcImRhdGEgdHViZXNcIi5cclxuICpcclxuICogQSBzdHJlYW0gYWN0cyBhcyBib3RoIGFuIFtbRW1pdHRlcl1dIGFuZCBbW1B1Ymxpc2hlcl1dLiBFYWNoIHN0cmVhbSBjYW4gaGF2ZSBtdWx0aXBsZSB7QGxpbmsgU3Vic2NyaXB0aW9uIHwgU3Vic2NyaXB0aW9uc30uXHJcbiAqXHJcbiAqIHVyeCBzdHJlYW1zIGFyZSBlaXRoZXIgKipzdGF0ZWxlc3MqKiBvciAqKnN0YXRlZnVsKiouXHJcbiAqIFN0YXRlbGVzcyBzdHJlYW1zIGVtaXQgZGF0YSB0byBleGlzdGluZyBzdWJzY3JpcHRpb25zIHdoZW4gcHVibGlzaGVkLCB3aXRob3V0IGtlZXBpbmcgdHJhY2sgb2YgaXQuXHJcbiAqIFN0YXRlZnVsIHN0cmVhbXMgcmVtZW1iZXIgdGhlIGxhc3QgcHVibGlzaGVkIHZhbHVlIGFuZCBpbW1lZGlhdGVseSBwdWJsaXNoIGl0IHRvIG5ldyBzdWJzY3JpcHRpb25zLlxyXG4gKlxyXG4gKiBgYGB0c1xyXG4gKiBpbXBvcnQgeyBzdHJlYW0sIHN0YXRlZnVsU3RyZWFtLCBwdWJsaXNoLCBzdWJzY3JpYmUgfSBmcm9tIFwiQHZpcnR1b3NvLmRldi91cnhcIjtcclxuICpcclxuICogLy8gZm9vIGlzIGEgc3RhdGVsZXNzIHN0cmVhbVxyXG4gKiBjb25zdCBmb28gPSBzdHJlYW08bnVtYmVyPigpO1xyXG4gKlxyXG4gKiBwdWJsaXNoKGZvbywgNDIpO1xyXG4gKiAvLyB0aGlzIHN1YnNyaXB0aW9uIHdpbGwgbm90IGJlIGNhbGxlZC4uLlxyXG4gKiBzdWJzY3JpYmUoZm9vLCAodmFsdWUpID0+IGNvbnNvbGUubG9nKHZhbHVlKSk7XHJcbiAqIC8vIGl0IHdpbGwgb25seSBjYXRjaCBwdWJsaXNoZWQgdmFsdWVzIGFmdGVyIGl0XHJcbiAqIHB1Ymxpc2goZm9vLCA0Myk7XHJcbiAqXHJcbiAqIC8vIHN0YXRlZnVsIHN0cmVhbXMgYWx3YXlzIHN0YXJ0IHdpdGggYW4gaW5pdGlhbCB2YWx1ZVxyXG4gKiBjb25zdCBiYXIgPSBzdGF0ZWZ1bFN0cmVhbSg0Mik7XHJcbiAqXHJcbiAqIC8vIHN1YnNjcmliaW5nIHRvIGEgc3RhdGVmdWwgc3RyZWFtXHJcbiAqIC8vIGltbWVkaWF0ZWx5IGNhbGxzIHRoZSBzdWJzY3JpcHRpb24gd2l0aCB0aGUgY3VycmVudCB2YWx1ZVxyXG4gKiBzdWJzY3JpYmUoYmFyLCAodmFsdWUpID0+IGNvbnNvbGUubG9nKHZhbHVlKSk7XHJcbiAqXHJcbiAqIC8vIHN1YnNlcXVlbnQgcHVibGlzaGluZyB3b3JrcyBqdXN0IGxpa2Ugc3RhdGVsZXNzIHN0cmVhbXNcclxuICogcHVibGlzaChiYXIsIDQzKTtcclxuICogYGBgXHJcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxyXG4gKi9cbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHN0YXRlbGVzcyBzdHJlYW0uXHJcbiAqIGBgYHRzXHJcbiAqIGNvbnN0IGZvbyA9IHN0cmVhbTxudW1iZXI+KCk7XHJcbiAqIGBgYFxyXG4gKiBAdHlwZVBhcmFtIFQgdGhlIHR5cGUgb2YgdmFsdWVzIHRvIHB1Ymxpc2ggaW4gdGhlIHN0cmVhbS5cclxuICogQHJldHVybnMgYSBbW1N0cmVhbV1dXHJcbiAqL1xuXG5mdW5jdGlvbiBzdHJlYW0oKSB7XG4gIHZhciBzdWJzY3JpcHRpb25zID0gW107XG4gIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uLCBhcmcpIHtcbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgY2FzZSBSRVNFVDpcbiAgICAgICAgc3Vic2NyaXB0aW9ucy5zcGxpY2UoMCwgc3Vic2NyaXB0aW9ucy5sZW5ndGgpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgU1VCU0NSSUJFOlxuICAgICAgICBzdWJzY3JpcHRpb25zLnB1c2goYXJnKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaW5kZXhPZiA9IHN1YnNjcmlwdGlvbnMuaW5kZXhPZihhcmcpO1xuXG4gICAgICAgICAgaWYgKGluZGV4T2YgPiAtMSkge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5zcGxpY2UoaW5kZXhPZiwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICBjYXNlIFBVQkxJU0g6XG4gICAgICAgIHN1YnNjcmlwdGlvbnMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb24oYXJnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5yZWNvZ25pemVkIGFjdGlvbiBcIiArIGFjdGlvbik7XG4gICAgfVxuICB9O1xufVxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgc3RhdGVmdWwgc3RyZWFtLlxyXG4gKiBgYGB0c1xyXG4gKiBjb25zdCBmb28gPSBzdGF0ZWZ1bFN0cmVhbSg0Mik7XHJcbiAqIGBgYFxyXG4gKiBAcGFyYW0gaW5pdGlhbCB0aGUgaW5pdGlhbCB2YWx1ZSBpbiB0aGUgc3RyZWFtLlxyXG4gKiBAdHlwZVBhcmFtIFQgdGhlIHR5cGUgb2YgdmFsdWVzIHRvIHB1Ymxpc2ggaW4gdGhlIHN0cmVhbS4gSWYgb21pdHRlZCwgdGhlIGZ1bmN0aW9uIGluZmVycyBpdCBmcm9tIHRoZSBpbml0aWFsIHZhbHVlLlxyXG4gKiBAcmV0dXJucyBhIFtbU3RhdGVmdWxTdHJlYW1dXVxyXG4gKi9cblxuZnVuY3Rpb24gc3RhdGVmdWxTdHJlYW0oaW5pdGlhbCkge1xuICB2YXIgdmFsdWUgPSBpbml0aWFsO1xuICB2YXIgaW5uZXJTdWJqZWN0ID0gc3RyZWFtKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uLCBhcmcpIHtcbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgY2FzZSBTVUJTQ1JJQkU6XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBhcmc7XG4gICAgICAgIHN1YnNjcmlwdGlvbih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFBVQkxJU0g6XG4gICAgICAgIHZhbHVlID0gYXJnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBWQUxVRTpcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBpbm5lclN1YmplY3QoYWN0aW9uLCBhcmcpO1xuICB9O1xufVxuLyoqXHJcbiAqIEV2ZW50IGhhbmRsZXJzIGFyZSBzcGVjaWFsIGVtaXR0ZXJzIHdoaWNoIGNhbiBoYXZlICoqYXQgbW9zdCBvbmUgYWN0aXZlIHN1YnNjcmlwdGlvbioqLlxyXG4gKiBTdWJzY3JpYmluZyB0byBhbiBldmVudCBoYW5kbGVyIHVuc3Vic2NyaWJlcyB0aGUgcHJldmlvdXMgc3Vic2NyaXB0aW9uLCBpZiBwcmVzZW50LlxyXG4gKiBgYGB0c1xyXG4gKiBjb25zdCBmb28gPSBzdHJlYW08bnVtYmVyPigpO1xyXG4gKiBjb25zdCBmb29FdmVudCA9IGV2ZW50SGFuZGxlcihmb28pO1xyXG4gKlxyXG4gKiAvLyB3aWxsIGJlIGNhbGxlZCBvbmNlIHdpdGggNDJcclxuICogc3Vic2NyaWJlKGZvb0V2ZW50LCAodmFsdWUpID0+IGNvbnNvbGUubG9nKGBTdWIgMSAke3ZhbHVlfWApKTtcclxuICogcHVibGlzaChmb28sIDQyKTtcclxuICpcclxuICogLy8gdW5zdWJzY3JpYmVzIHN1YiAxXHJcbiAqIHN1YnNjcmliZShmb29FdmVudCwgKHZhbHVlKSA9PiBjb25zb2xlLmxvZyhgU3ViIDIgJHt2YWx1ZX1gKSk7XHJcbiAqIHB1Ymxpc2goZm9vLCA0Myk7XHJcbiAqIGBgYFxyXG4gKiBAcGFyYW0gZW1pdHRlciB0aGUgc291cmNlIGVtaXR0ZXIuXHJcbiAqIEByZXR1cm5zIHRoZSBzaW5nbGUtc3Vic2NyaXB0aW9uIGVtaXR0ZXIuXHJcbiAqL1xuXG5mdW5jdGlvbiBldmVudEhhbmRsZXIoZW1pdHRlcikge1xuICB2YXIgdW5zdWI7XG4gIHZhciBjdXJyZW50U3Vic2NyaXB0aW9uO1xuXG4gIHZhciBjbGVhbnVwID0gZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICByZXR1cm4gdW5zdWIgJiYgdW5zdWIoKTtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbiwgc3Vic2NyaXB0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgIGNhc2UgU1VCU0NSSUJFOlxuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRTdWJzY3JpcHRpb24gPT09IHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICBjdXJyZW50U3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgIHVuc3ViID0gc3Vic2NyaWJlKGVtaXR0ZXIsIHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgcmV0dXJuIHVuc3ViO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFU0VUOlxuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGN1cnJlbnRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVucmVjb2duaXplZCBhY3Rpb24gXCIgKyBhY3Rpb24pO1xuICAgIH1cbiAgfTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGFuZCBjb25uZWN0cyBhIFwianVuY3Rpb25cIiBzdHJlYW0gdG8gdGhlIHNwZWNpZmllZCBlbWl0dGVyLiBPZnRlbiB1c2VkIHdpdGggW1twaXBlXV0sIHRvIGF2b2lkIHRoZSBtdWx0aXBsZSBldmFsdWF0aW9uIG9mIG9wZXJhdG9yIHNldHMuXHJcbiAqXHJcbiAqIGBgYHRzXHJcbiAqIGNvbnN0IGZvbyA9IHN0cmVhbTxudW1iZXI+KCk7XHJcbiAqXHJcbiAqIGNvbnN0IGZvb1gyID0gcGlwZShcclxuICogICBmb28sXHJcbiAqICAgbWFwKCh2YWx1ZSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coYG11bHRpcGx5aW5nICR7dmFsdWV9YCk7XHJcbiAqICAgICByZXR1cm4gdmFsdWUgKiAyO1xyXG4gKiAgIH0pXHJcbiAqICk7XHJcbiAqXHJcbiAqIHN1YnNjcmliZShmb29YMiwgKHZhbHVlKSA9PiBjb25zb2xlLmxvZyh2YWx1ZSkpO1xyXG4gKiBzdWJzY3JpYmUoZm9vWDIsICh2YWx1ZSkgPT4gY29uc29sZS5sb2codmFsdWUpKTtcclxuICpcclxuICogcHVibGlzaChmb28sIDQyKTsgLy8gZXhlY3V0ZXMgdGhlIG1hcCBvcGVyYXRvciB0d2ljZSBmb3IgZWFjaCBzdWJzY3JpcHRpb24uXHJcbiAqXHJcbiAqIGNvbnN0IHNoYXJlZEZvb1gyID0gc3RyZWFtRnJvbUVtaXR0ZXIocGlwZShcclxuICogICBmb28sXHJcbiAqICAgbWFwKCh2YWx1ZSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coYHNoYXJlZCBtdWx0aXBseWluZyAke3ZhbHVlfWApO1xyXG4gKiAgICAgcmV0dXJuIHZhbHVlICogMjtcclxuICogICB9KVxyXG4gKiApKTtcclxuICpcclxuICogc3Vic2NyaWJlKHNoYXJlZEZvb1gyLCAodmFsdWUpID0+IGNvbnNvbGUubG9nKHZhbHVlKSk7XHJcbiAqIHN1YnNjcmliZShzaGFyZWRGb29YMiwgKHZhbHVlKSA9PiBjb25zb2xlLmxvZyh2YWx1ZSkpO1xyXG4gKlxyXG4gKiBwdWJsaXNoKGZvbywgNDIpO1xyXG4gKmBgYFxyXG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0aW5nIHN0cmVhbS5cclxuICovXG5cbmZ1bmN0aW9uIHN0cmVhbUZyb21FbWl0dGVyKGVtaXR0ZXIpIHtcbiAgcmV0dXJuIHRhcChzdHJlYW0oKSwgZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgIHJldHVybiBjb25uZWN0KGVtaXR0ZXIsIHN0cmVhbSk7XG4gIH0pO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYW5kIGNvbm5lY3RzIGEgXCJqdW5jdGlvblwiIHN0YXRlZnVsIHN0cmVhbSB0byB0aGUgc3BlY2lmaWVkIGVtaXR0ZXIuIE9mdGVuIHVzZWQgd2l0aCBbW3BpcGVdXSwgdG8gYXZvaWQgdGhlIG11bHRpcGxlIGV2YWx1YXRpb24gb2Ygb3BlcmF0b3Igc2V0cy5cclxuICpcclxuICogYGBgdHNcclxuICogY29uc3QgZm9vID0gc3RyZWFtPG51bWJlcj4oKTtcclxuICpcclxuICogY29uc3QgZm9vWDIgPSBwaXBlKFxyXG4gKiAgIGZvbyxcclxuICogICBtYXAoKHZhbHVlKSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhgbXVsdGlwbHlpbmcgJHt2YWx1ZX1gKTtcclxuICogICAgIHJldHVybiB2YWx1ZSAqIDI7XHJcbiAqICAgfSlcclxuICogKTtcclxuICpcclxuICogc3Vic2NyaWJlKGZvb1gyLCAodmFsdWUpID0+IGNvbnNvbGUubG9nKHZhbHVlKSk7XHJcbiAqIHN1YnNjcmliZShmb29YMiwgKHZhbHVlKSA9PiBjb25zb2xlLmxvZyh2YWx1ZSkpO1xyXG4gKlxyXG4gKiBwdWJsaXNoKGZvbywgNDIpOyAvLyBleGVjdXRlcyB0aGUgbWFwIG9wZXJhdG9yIHR3aWNlIGZvciBlYWNoIHN1YnNjcmlwdGlvbi5cclxuICpcclxuICogY29uc3Qgc2hhcmVkRm9vWDIgPSBzdGF0ZWZ1bFN0cmVhbUZyb21FbWl0dGVyKHBpcGUoXHJcbiAqICAgZm9vLFxyXG4gKiAgIG1hcCgodmFsdWUpID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGBzaGFyZWQgbXVsdGlwbHlpbmcgJHt2YWx1ZX1gKTtcclxuICogICAgIHJldHVybiB2YWx1ZSAqIDI7XHJcbiAqICAgfSlcclxuICogKSwgNDIpO1xyXG4gKlxyXG4gKiBzdWJzY3JpYmUoc2hhcmVkRm9vWDIsICh2YWx1ZSkgPT4gY29uc29sZS5sb2codmFsdWUpKTtcclxuICogc3Vic2NyaWJlKHNoYXJlZEZvb1gyLCAodmFsdWUpID0+IGNvbnNvbGUubG9nKHZhbHVlKSk7XHJcbiAqXHJcbiAqIHB1Ymxpc2goZm9vLCA0Mik7XHJcbiAqYGBgXHJcbiAqIEBwYXJhbSBpbml0aWFsIHRoZSBpbml0aWFsIHZhbHVlIGluIHRoZSBzdHJlYW0uXHJcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRpbmcgc3RhdGVmdWwgc3RyZWFtLlxyXG4gKi9cblxuZnVuY3Rpb24gc3RhdGVmdWxTdHJlYW1Gcm9tRW1pdHRlcihlbWl0dGVyLCBpbml0aWFsKSB7XG4gIHJldHVybiB0YXAoc3RhdGVmdWxTdHJlYW0oaW5pdGlhbCksIGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICByZXR1cm4gY29ubmVjdChlbWl0dGVyLCBzdHJlYW0pO1xuICB9KTtcbn1cblxuLyoqXHJcbiAqXHJcbiAqIFN0cmVhbSB2YWx1ZXMgY2FuIGJlIHRyYW5zZm9ybWVkIGFuZCBjb250cm9sbGVkIGJ5IHtAbGluayBwaXBlIHwgKipwaXBpbmcqKn0gdGhyb3VnaCAqKm9wZXJhdG9ycyoqLlxyXG4gKiB1cnggaW5jbHVkZXMgc2V2ZXJhbCBvcGVyYXRvcnMgbGlrZSBbW21hcF1dLCBbW2ZpbHRlcl1dLCBbW3NjYW5dXSwgYW5kIFtbdGhyb3R0bGVUaW1lXV0uXHJcbiAqIFRoZSBbW3dpdGhMYXRlc3RGcm9tXV0gb3BlcmF0b3IgYWxsb3dzIHRoZSBjb21iaW5hdGlvbiBvZiB2YWx1ZXMgZnJvbSBvdGhlciBzdHJlYW1zLlxyXG4gKlxyXG4gKiBgYGB0c1xyXG4gKiBjb25zdCBmb28gPSBzdHJlYW08bnVtYmVyPigpXHJcbiAqXHJcbiAqIC8vIGNyZWF0ZSBhbiBlbWl0dGVyIHRoYXQgZmlyc3QgYWRkcyAyIHRvIHRoZSBwYXNzZWQgdmFsdWUsIHRoZW4gbXVsdGlwbGllcyBpdCBieSAqIDJcclxuICogY29uc3QgYmFyID0gcGlwZShmb28sIG1hcCh2YWx1ZSA9PiB2YWx1ZSArIDIpLCBtYXAodmFsdWUgPT4gdmFsdWUgKiAyKSlcclxuICogc3Vic2NyaWJlKGJhciwgdmFsdWUgPT4gY29uc29sZS5sb2codmFsdWUpKVxyXG4gKiBwdWJsaXNoKGZvbywgMikgLy8gb3V0cHV0cyA4XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiAjIyMgSW1wbGVtZW50aW5nIEN1c3RvbSBPcGVyYXRvcnNcclxuICogVG8gaW1wbGVtZW50IHlvdXIgb3duIG9wZXJhdG9ycywgaW1wbGVtZW50IHRoZSBbW09wZXJhdG9yXV0gaW50ZXJmYWNlLlxyXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cclxuICovXG4vKiogQGludGVybmFsICovXG5cbmZ1bmN0aW9uIGNvbWJpbmVPcGVyYXRvcnMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBvcGVyYXRvcnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgb3BlcmF0b3JzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgcmV0dXJuIG9wZXJhdG9ycy5yZWR1Y2VSaWdodCh0aHJ1c2gsIHN1YnNjcmliZXIpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwaXBlKHNvdXJjZSkge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIG9wZXJhdG9ycyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgb3BlcmF0b3JzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG5cbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHZhciBwcm9qZWN0ID0gY29tYmluZU9wZXJhdG9ycy5hcHBseSh2b2lkIDAsIG9wZXJhdG9ycyk7XG4gIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uLCBzdWJzY3JpcHRpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgY2FzZSBTVUJTQ1JJQkU6XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmUoc291cmNlLCBwcm9qZWN0KHN1YnNjcmlwdGlvbikpO1xuXG4gICAgICBjYXNlIFJFU0VUOlxuICAgICAgICByZXNldChzb3VyY2UpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVucmVjb2duaXplZCBhY3Rpb24gXCIgKyBhY3Rpb24pO1xuICAgIH1cbiAgfTtcbn1cbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBbW0NvbXBhcmF0b3JdXSBmb3IgW1tkaXN0aW5jdFVudGlsQ2hhbmdlZF1dIGFuZCBbW2R1Y11dLlxyXG4gKi9cblxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmF0b3IocHJldmlvdXMsIG5leHQpIHtcbiAgcmV0dXJuIHByZXZpb3VzID09PSBuZXh0O1xufVxuLyoqXHJcbiAqIEZpbHRlcnMgb3V0IGlkZW50aWNhbCB2YWx1ZXMuIFBhc3MgYW4gb3B0aW9uYWwgW1tDb21wYXJhdG9yXV0gaWYgeW91IG5lZWQgdG8gZmlsdGVyIG5vbi1wcmltaXRpdmUgdmFsdWVzLlxyXG4gKiBgYGB0c1xyXG4gKiBjb25zdCBmb28gPSBzdHJlYW08bnVtYmVyPigpXHJcbiAqXHJcbiAqIHN1YnNjcmliZShcclxuICogIHBpcGUoZm9vLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKSxcclxuICogIGNvbnNvbGUubG9nXHJcbiAqICkgLy8gd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlXHJcbiAqXHJcbiAqIHB1Ymxpc2goZm9vLCA0MilcclxuICogcHVibGlzaChmb28sIDQyKVxyXG4gKiBgYGBcclxuICovXG5cbmZ1bmN0aW9uIGRpc3RpbmN0VW50aWxDaGFuZ2VkKGNvbXBhcmF0b3IpIHtcbiAgaWYgKGNvbXBhcmF0b3IgPT09IHZvaWQgMCkge1xuICAgIGNvbXBhcmF0b3IgPSBkZWZhdWx0Q29tcGFyYXRvcjtcbiAgfVxuXG4gIHZhciBjdXJyZW50O1xuICByZXR1cm4gZnVuY3Rpb24gKGRvbmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgIGlmICghY29tcGFyYXRvcihjdXJyZW50LCBuZXh0KSkge1xuICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgZG9uZShuZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuLyoqXHJcbiAqIEZpbHRlcnMgb3V0IHZhbHVlcyBmb3Igd2hpY2ggdGhlIHByZWRpY2F0b3IgZG9lcyBub3QgcmV0dXJuIGB0cnVlYC1pc2guXHJcbiAqIGBgYHRzXHJcbiAqIGNvbnN0IGZvbyA9IHN0cmVhbTxudW1iZXI+KClcclxuICpcclxuICogc3Vic2NyaWJlKFxyXG4gKiAgcGlwZShmb28sIGZpbHRlcih2YWx1ZSA9PiB2YWx1ZSAlIDIgPT09IDApKSxcclxuICogIGNvbnNvbGUubG9nXHJcbiAqICkgLy8gd2lsbCBiZSBjYWxsZWQgb25seSB3aXRoIGV2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIHB1Ymxpc2goZm9vLCAyKVxyXG4gKiBwdWJsaXNoKGZvbywgMylcclxuICogcHVibGlzaChmb28sIDQpXHJcbiAqIHB1Ymxpc2goZm9vLCA1KVxyXG4gKiBgYGBcclxuICovXG5cbmZ1bmN0aW9uIGZpbHRlcihwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcHJlZGljYXRlKHZhbHVlKSAmJiBkb25lKHZhbHVlKTtcbiAgICB9O1xuICB9O1xufVxuLyoqXHJcbiAqIE1hcHMgdmFsdWVzIHVzaW5nIHRoZSBwcm92aWRlZCBwcm9qZWN0IGZ1bmN0aW9uLlxyXG4gKiBgYGB0c1xyXG4gKiBjb25zdCBmb28gPSBzdHJlYW08bnVtYmVyPigpXHJcbiAqXHJcbiAqIHN1YnNjcmliZShcclxuICogIHBpcGUoZm9vLCBtYXAodmFsdWUgPT4gdmFsdWUgKiAyKSksXHJcbiAqICBjb25zb2xlLmxvZ1xyXG4gKiApIC8vIDQsIDZcclxuICpcclxuICogcHVibGlzaChmb28sIDIpXHJcbiAqIHB1Ymxpc2goZm9vLCAzKVxyXG4gKiBgYGBcclxuICovXG5cbmZ1bmN0aW9uIG1hcChwcm9qZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHJldHVybiBjb21wb3NlKGRvbmUsIHByb2plY3QpO1xuICB9O1xufVxuLyoqXHJcbiAqIE1hcHMgdmFsdWVzIHRvIHRoZSBoYXJkLWNvZGVkIHZhbHVlLlxyXG4gKiBgYGB0c1xyXG4gKiBjb25zdCBmb28gPSBzdHJlYW08bnVtYmVyPigpXHJcbiAqXHJcbiAqIHN1YnNjcmliZShcclxuICogIHBpcGUoZm9vLCBtYXBUbygzKSksXHJcbiAqICBjb25zb2xlLmxvZ1xyXG4gKiApIC8vIDMsIDNcclxuICpcclxuICogcHVibGlzaChmb28sIDEpXHJcbiAqIHB1Ymxpc2goZm9vLCAyKVxyXG4gKiBgYGBcclxuICovXG5cbmZ1bmN0aW9uIG1hcFRvKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZG9uZSh2YWx1ZSk7XG4gICAgfTtcbiAgfTtcbn1cbi8qKlxyXG4gKiBXb3JrcyBsaWtlIEFycmF5I3JlZHVjZS5cclxuICogQXBwbGllcyBhbiBhY2N1bXVsYXRvciBmdW5jdGlvbiBvbiB0aGUgZW1pdHRlciwgYW5kIG91dHB1dHMgaW50ZXJtZWRpYXRlIHJlc3VsdC4gU3RhcnRzIHdpdGggdGhlIGluaXRpYWwgdmFsdWUuXHJcbiAqIGBgYHRzXHJcbiAqIGNvbnN0IGZvbyA9IHN0cmVhbTxudW1iZXI+KClcclxuICpcclxuICogc3Vic2NyaWJlKFxyXG4gKiAgcGlwZShmb28sIHNjYW4oKGFjYywgdmFsdWUpID0+IGFjYyArIHZhbHVlLCAyKSxcclxuICogIGNvbnNvbGUubG9nXHJcbiAqICkgLy8gMywgNVxyXG4gKlxyXG4gKiBwdWJsaXNoKGZvbywgMSlcclxuICogcHVibGlzaChmb28sIDIpXHJcbiAqIGBgYFxyXG4gKi9cblxuZnVuY3Rpb24gc2NhbihzY2FubmVyLCBpbml0aWFsKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBkb25lKGluaXRpYWwgPSBzY2FubmVyKGluaXRpYWwsIHZhbHVlKSk7XG4gICAgfTtcbiAgfTtcbn1cbi8qKlxyXG4gKiBTa2lwcyB0aGUgc3BlY2lmaWVkIGFtb3VudCBvZiB2YWx1ZXMgZnJvbSB0aGUgZW1pdHRlci5cclxuICogYGBgdHNcclxuICogY29uc3QgZm9vID0gc3RyZWFtPG51bWJlcj4oKVxyXG4gKlxyXG4gKiBzdWJzY3JpYmUoXHJcbiAqICBwaXBlKGZvbywgc2tpcCgyKSksXHJcbiAqICBjb25zb2xlLmxvZ1xyXG4gKiApIC8vIDMsIDRcclxuICpcclxuICogcHVibGlzaChmb28sIDEpIC8vIHNraXBwZWRcclxuICogcHVibGlzaChmb28sIDIpIC8vIHNraXBwZWRcclxuICogcHVibGlzaChmb28sIDMpXHJcbiAqIHB1Ymxpc2goZm9vLCA0KVxyXG4gKiBgYGBcclxuICovXG5cbmZ1bmN0aW9uIHNraXAodGltZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdGltZXMgPiAwID8gdGltZXMtLSA6IGRvbmUodmFsdWUpO1xuICAgIH07XG4gIH07XG59XG4vKipcclxuICogVGhyb3R0bGVzIGZsb3dpbmcgdmFsdWVzIGF0IHRoZSBwcm92aWRlZCBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMuXHJcbiAqIFtUaHJvdHRsZSBWUyBEZWJvdW5jZSBpbiBTT10oaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjU5OTEzNjcvZGlmZmVyZW5jZS1iZXR3ZWVuLXRocm90dGxpbmctYW5kLWRlYm91bmNpbmctYS1mdW5jdGlvbikuXHJcbiAqXHJcbiAqIGBgYHRzXHJcbiAqICBjb25zdCBmb28gPSBzdHJlYW08bnVtYmVyPigpXHJcbiAqICBwdWJsaXNoKGZvbywgMSlcclxuICpcclxuICogIHNldFRpbWVvdXQoKCkgPT4gcHVibGlzaChmb28sIDIpLCAyMClcclxuICogIHNldFRpbWVvdXQoKCkgPT4gcHVibGlzaChmb28sIDMpLCAyMClcclxuICpcclxuICogIHN1YnNjcmliZShwaXBlKGZvbywgdGhyb3R0bGVUaW1lKDUwKSksIHZhbCA9PiB7XHJcbiAqICAgIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gM1xyXG4gKiAgfSlcclxuICogYGBgXHJcbiAqL1xuXG5mdW5jdGlvbiB0aHJvdHRsZVRpbWUoaW50ZXJ2YWwpIHtcbiAgdmFyIGN1cnJlbnRWYWx1ZTtcbiAgdmFyIHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZG9uZShjdXJyZW50VmFsdWUpO1xuICAgICAgfSwgaW50ZXJ2YWwpO1xuICAgIH07XG4gIH07XG59XG4vKipcclxuICogRGVib3VuY2VzIGZsb3dpbmcgdmFsdWVzIGF0IHRoZSBwcm92aWRlZCBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMuXHJcbiAqIFtUaHJvdHRsZSBWUyBEZWJvdW5jZSBpbiBTT10oaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjU5OTEzNjcvZGlmZmVyZW5jZS1iZXR3ZWVuLXRocm90dGxpbmctYW5kLWRlYm91bmNpbmctYS1mdW5jdGlvbikuXHJcbiAqXHJcbiAqIGBgYHRzXHJcbiAqICBjb25zdCBmb28gPSBzdHJlYW08bnVtYmVyPigpXHJcbiAqICBwdWJsaXNoKGZvbywgMSlcclxuICpcclxuICogIHNldFRpbWVvdXQoKCkgPT4gcHVibGlzaChmb28sIDIpLCAyMClcclxuICogIHNldFRpbWVvdXQoKCkgPT4gcHVibGlzaChmb28sIDMpLCAyMClcclxuICpcclxuICogIHN1YnNjcmliZShwaXBlKGZvbywgZGVib3VuY2VUaW1lKDUwKSksIHZhbCA9PiB7XHJcbiAqICAgIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gM1xyXG4gKiAgfSlcclxuICogYGBgXHJcbiAqL1xuXG5mdW5jdGlvbiBkZWJvdW5jZVRpbWUoaW50ZXJ2YWwpIHtcbiAgdmFyIGN1cnJlbnRWYWx1ZTtcbiAgdmFyIHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG5cbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9uZShjdXJyZW50VmFsdWUpO1xuICAgICAgfSwgaW50ZXJ2YWwpO1xuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiB3aXRoTGF0ZXN0RnJvbSgpIHtcbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgc291cmNlc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG5cbiAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheShzb3VyY2VzLmxlbmd0aCk7XG4gIHZhciBjYWxsZWQgPSAwO1xuICB2YXIgcGVuZGluZ0NhbGwgPSBudWxsO1xuICB2YXIgYWxsQ2FsbGVkID0gTWF0aC5wb3coMiwgc291cmNlcy5sZW5ndGgpIC0gMTtcbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UsIGluZGV4KSB7XG4gICAgdmFyIGJpdCA9IE1hdGgucG93KDIsIGluZGV4KTtcbiAgICBzdWJzY3JpYmUoc291cmNlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBwcmV2Q2FsbGVkID0gY2FsbGVkO1xuICAgICAgY2FsbGVkID0gY2FsbGVkIHwgYml0O1xuICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuXG4gICAgICBpZiAocHJldkNhbGxlZCAhPT0gYWxsQ2FsbGVkICYmIGNhbGxlZCA9PT0gYWxsQ2FsbGVkICYmIHBlbmRpbmdDYWxsKSB7XG4gICAgICAgIHBlbmRpbmdDYWxsKCk7XG4gICAgICAgIHBlbmRpbmdDYWxsID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBjYWxsID0gZnVuY3Rpb24gY2FsbCgpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoW3ZhbHVlXS5jb25jYXQodmFsdWVzKSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoY2FsbGVkID09PSBhbGxDYWxsZWQpIHtcbiAgICAgICAgY2FsbCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVuZGluZ0NhbGwgPSBjYWxsO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59XG5cbi8qKlxyXG4gKiBUcmFuc2Zvcm1lcnMgY2hhbmdlIGFuZCBjb21iaW5lIHN0cmVhbXMsIHNpbWlsYXIgdG8gb3BlcmF0b3JzLlxyXG4gKiB1cnggY29tZXMgd2l0aCB0d28gY29tYmluYXRvcnMgLSBbW2NvbWJpbmVMYXRlc3RdXSBhbmQgW1ttZXJnZV1dLCBhbmQgb25lIGNvbnZlbmllbmNlIGZpbHRlciAtIFtbZHVjXV0uXHJcbiAqXHJcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxyXG4gKi9cbi8qKlxyXG4gKiBNZXJnZXMgb25lIG9yIG1vcmUgZW1pdHRlcnMgZnJvbSB0aGUgc2FtZSB0eXBlIGludG8gYSBuZXcgRW1pdHRlciB3aGljaCBlbWl0cyB2YWx1ZXMgZnJvbSBhbnkgb2YgdGhlIHNvdXJjZSBlbWl0dGVycy5cclxuICogYGBgdHNcclxuICogY29uc3QgZm9vID0gc3RyZWFtPG51bWJlcj4oKVxyXG4gKiBjb25zdCBiYXIgPSBzdHJlYW08bnVtYmVyPigpXHJcbiAqXHJcbiAqIHN1YnNjcmliZShtZXJnZShmb28sIGJhciksICh2YWx1ZSkgPT4gY29uc29sZS5sb2codmFsdWUpKSAvLyA0MiwgNDNcclxuICpcclxuICogcHVibGlzaChmb28sIDQyKVxyXG4gKiBwdWJsaXNoKGJhciwgNDMpXHJcbiAqIGBgYFxyXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2UoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHNvdXJjZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbiwgc3Vic2NyaXB0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgIGNhc2UgU1VCU0NSSUJFOlxuICAgICAgICByZXR1cm4gam9pblByb2MuYXBwbHkodm9pZCAwLCBzb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIHN1YnNjcmliZShzb3VyY2UsIHN1YnNjcmlwdGlvbik7XG4gICAgICAgIH0pKTtcblxuICAgICAgY2FzZSBSRVNFVDpcbiAgICAgICAgLy8gZG8gbm90aGluZywgd2UgYXJlIHN0YXRlbGVzc1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVucmVjb2duaXplZCBhY3Rpb24gXCIgKyBhY3Rpb24pO1xuICAgIH1cbiAgfTtcbn1cbi8qKlxyXG4gKiBBIGNvbnZlbmllbmNlIHdyYXBwZXIgdGhhdCBlbWl0cyBvbmx5IHRoZSBkaXN0aW5jdCB2YWx1ZXMgZnJvbSB0aGUgcGFzc2VkIEVtaXR0ZXIuIFdyYXBzIFtbcGlwZV1dIGFuZCBbW2Rpc3RpbmN0VW50aWxDaGFuZ2VkXV0uXHJcbiAqXHJcbiAqIGBgYHRzXHJcbiAqIGNvbnN0IGZvbyA9IHN0cmVhbTxudW1iZXI+KClcclxuICpcclxuICogLy8gdGhpcyBsaW5lLi4uXHJcbiAqIGNvbnN0IGEgPSBkdWMoZm9vKVxyXG4gKlxyXG4gKiAvLyBpcyBlcXVpdmFsZW50IHRvIHRoaXNcclxuICogY29uc3QgYiA9IHBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoZm9vKSlcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSBzb3VyY2UgVGhlIHNvdXJjZSBlbWl0dGVyLlxyXG4gKiBAcGFyYW0gY29tcGFyYXRvciBvcHRpb25hbCBjdXN0b20gY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgdGhlIHR3byB2YWx1ZXMuXHJcbiAqXHJcbiAqIEB0eXBlUGFyYW0gVCB0aGUgdHlwZSBvZiB0aGUgdmFsdWUgZW1pdHRlZCBieSB0aGUgc291cmNlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0aW5nIGVtaXR0ZXIuXHJcbiAqL1xuXG5mdW5jdGlvbiBkdWMoc291cmNlLCBjb21wYXJhdG9yKSB7XG4gIGlmIChjb21wYXJhdG9yID09PSB2b2lkIDApIHtcbiAgICBjb21wYXJhdG9yID0gZGVmYXVsdENvbXBhcmF0b3I7XG4gIH1cblxuICByZXR1cm4gcGlwZShzb3VyY2UsIGRpc3RpbmN0VW50aWxDaGFuZ2VkKGNvbXBhcmF0b3IpKTtcbn1cbmZ1bmN0aW9uIGNvbWJpbmVMYXRlc3QoKSB7XG4gIHZhciBpbm5lclN1YmplY3QgPSBzdHJlYW0oKTtcblxuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGVtaXR0ZXJzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgZW1pdHRlcnNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkoZW1pdHRlcnMubGVuZ3RoKTtcbiAgdmFyIGNhbGxlZCA9IDA7XG4gIHZhciBhbGxDYWxsZWQgPSBNYXRoLnBvdygyLCBlbWl0dGVycy5sZW5ndGgpIC0gMTtcbiAgZW1pdHRlcnMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlLCBpbmRleCkge1xuICAgIHZhciBiaXQgPSBNYXRoLnBvdygyLCBpbmRleCk7XG4gICAgc3Vic2NyaWJlKHNvdXJjZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICBjYWxsZWQgPSBjYWxsZWQgfCBiaXQ7XG5cbiAgICAgIGlmIChjYWxsZWQgPT09IGFsbENhbGxlZCkge1xuICAgICAgICBwdWJsaXNoKGlubmVyU3ViamVjdCwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uLCBzdWJzY3JpcHRpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgY2FzZSBTVUJTQ1JJQkU6XG4gICAgICAgIGlmIChjYWxsZWQgPT09IGFsbENhbGxlZCkge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbih2YWx1ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZShpbm5lclN1YmplY3QsIHN1YnNjcmlwdGlvbik7XG5cbiAgICAgIGNhc2UgUkVTRVQ6XG4gICAgICAgIHJldHVybiByZXNldChpbm5lclN1YmplY3QpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnJlY29nbml6ZWQgYWN0aW9uIFwiICsgYWN0aW9uKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxyXG4gKiBgc3lzdGVtYCBkZWZpbmVzIGEgc3BlY2lmaWNhdGlvbiBvZiBhIHN5c3RlbSAtIGl0cyBjb25zdHJ1Y3RvciwgZGVwZW5kZW5jaWVzIGFuZCBpZiBpdCBzaG91bGQgYWN0IGFzIGEgc2luZ2xldG9uIGluIGEgc3lzdGVtIGRlcGVuZGVuY3kgdHJlZS5cclxuICogV2hlbiBjYWxsZWQsIHN5c3RlbSByZXR1cm5zIGEgW1tTeXN0ZW1TcGVjXV0sIHdoaWNoIGlzIHRoZW4gaW5pdGlhbGl6ZWQgYWxvbmcgd2l0aCBpdHMgZGVwZW5kZW5jaWVzIGJ5IHBhc3NpbmcgaXQgdG8gW1tpbml0XV0uXHJcbiAqXHJcbiAqIGBgYHRzXHJcbiAqIEBpbXBvcnQgeyBzdWJzY3JpYmUsIHB1Ymxpc2gsIHN5c3RlbSwgaW5pdCwgdHVwLCBjb25uZWN0LCBtYXAsIHBpcGUgfSBmcm9tICd1cngnXHJcbiAqXHJcbiAqIC8vIGEgc2ltcGxlIHN5c3RlbSB3aXRoIHR3byBzdHJlYW1zXHJcbiAqIGNvbnN0IHN5czEgPSBzeXN0ZW0oKCkgPT4ge1xyXG4gKiAgY29uc3QgYSA9IHN0cmVhbTxudW1iZXI+KClcclxuICogIGNvbnN0IGIgPSBzdHJlYW08bnVtYmVyPigpXHJcbiAqXHJcbiAqICBjb25uZWN0KHBpcGUoYSwgbWFwKHZhbHVlID0+IHZhbHVlICogMikpLCBiKVxyXG4gKiAgcmV0dXJuIHsgYSwgYiB9XHJcbiAqIH0pXHJcbiAqXHJcbiAqIC8vIGEgc2Vjb25kIHN5c3RlbSB3aGljaCBkZXBlbmRzIG9uIHRoZSBzdHJlYW1zIGZyb20gdGhlIGZpcnN0IG9uZVxyXG4gKiBjb25zdCBzeXMyID0gc3lzdGVtKChbIHthLCBifSBdKSA9PiB7XHJcbiAqICBjb25zdCBjID0gc3RyZWFtPG51bWJlcj4oKVxyXG4gKiAgY29ubmVjdChwaXBlKGIsIG1hcCh2YWx1ZSA9PiB2YWx1ZSAqIDIpKSwgYylcclxuICogIC8vIHJlLWV4cG9ydCB0aGUgYGFgIHN0cmVhbSwga2VlcCBgYmAgaW50ZXJuYWxcclxuICogIHJldHVybiB7IGEsIGMgfVxyXG4gKiB9LCB0dXAoc3lzMSkpXHJcbiAqXHJcbiAqIC8vIGluaXQgd2lsbCByZWN1cnNpdmVseSBpbml0aWFsaXplIHN5czIgZGVwZW5kZW5jaWVzLCBpbiB0aGlzIGNhc2Ugc3lzMVxyXG4gKiBjb25zdCB7IGEsIGMgfSA9IGluaXQoc3lzMilcclxuICogc3Vic2NyaWJlKGMsIGMgPT4gY29uc29sZS5sb2coYFZhbHVlIG11bHRpcGxpZWQgYnkgNGAsIGMpKVxyXG4gKiBwdWJsaXNoKGEsIDIpXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiAjIyMjIFNpbmdsZXRvbnMgaW4gRGVwZW5kZW5jeSBUcmVlXHJcbiAqXHJcbiAqIEJ5IGRlZmF1bHQsIHN5c3RlbXMgd2lsbCBiZSBpbml0aWFsaXplZCBvbmx5IG9uY2UgaWYgZW5jb3VudGVyZWQgbXVsdGlwbGUgdGltZXMgaW4gdGhlIGRlcGVuZGVuY3kgdHJlZS5cclxuICogSW4gdGhlIGJlbG93IGRlcGVuZGVuY3kgc3lzdGVtIHRyZWUsIHN5c3RlbXMgYGJgIGFuZCBgY2Agd2lsbCByZWNlaXZlIHRoZSBzYW1lIHN0cmVhbSBpbnN0YW5jZXMgZnJvbSBzeXN0ZW0gYGFgIHdoZW4gc3lzdGVtIGBkYCBpcyBpbml0aWFsaXplZC5cclxuICogYGBgdHh0XHJcbiAqICAgYVxyXG4gKiAgLyBcXFxyXG4gKiBiICAgY1xyXG4gKiAgXFwgL1xyXG4gKiAgIGRcclxuICogYGBgXHJcbiAqIElmIGBhYCBnZXRzIGB7c2luZ2xldG9uOiBmYWxzZX1gIGFzIGEgbGFzdCBhcmd1bWVudCwgYGluaXRgIGNyZWF0ZXMgdHdvIHNlcGFyYXRlIGluc3RhbmNlcyAtIG9uZSBmb3IgYGJgIGFuZCBvbmUgZm9yIGBjYC5cclxuICpcclxuICogQHBhcmFtIGNvbnN0cnVjdG9yIHRoZSBzeXN0ZW0gY29uc3RydWN0b3IgZnVuY3Rpb24uIEluaXRpYWxpemUgYW5kIGNvbm5lY3QgdGhlIHN0cmVhbXMgaW4gaXRzIGJvZHkuXHJcbiAqXHJcbiAqIEBwYXJhbSBkZXBlbmRlbmNpZXMgdGhlIHN5c3RlbSBkZXBlbmRlbmNpZXMsIHdoaWNoIHRoZSBjb25zdHJ1Y3RvciB3aWxsIHJlY2VpdmUgYXMgYXJndW1lbnRzLlxyXG4gKiBVc2UgdGhlIFtbdHVwXV0gdXRpbGl0eSAqKkZvciBUeXBlU2NyaXB0IHR5cGUgaW5mZXJlbmNlIHRvIHdvcmsgY29ycmVjdGx5KiouXHJcbiAqIGBgYHRzXHJcbiAqIGNvbnN0IHN5czMgPSBzeXN0ZW0oKCkgPT4geyAuLi4gfSwgdHVwKHN5czIsIHN5czEpKVxyXG4gKiBgYGBcclxuICogQHBhcmFtIF9fbmFtZWRQYXJhbWV0ZXJzIE9wdGlvbnNcclxuICogQHBhcmFtIHNpbmdsZXRvbiBkZXRlcm1pbmVzIGlmIHRoZSBzeXN0ZW0gd2lsbCBhY3QgYXMgYSBzaW5nbGV0b24gaW4gYSBzeXN0ZW0gZGVwZW5kZW5jeSB0cmVlLiBgdHJ1ZWAgYnkgZGVmYXVsdC5cclxuICovXG5mdW5jdGlvbiBzeXN0ZW0oY29uc3RydWN0b3IsIGRlcGVuZGVuY2llcywgX3RlbXApIHtcbiAgaWYgKGRlcGVuZGVuY2llcyA9PT0gdm9pZCAwKSB7XG4gICAgZGVwZW5kZW5jaWVzID0gW107XG4gIH1cblxuICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7XG4gICAgc2luZ2xldG9uOiB0cnVlXG4gIH0gOiBfdGVtcCxcbiAgICAgIHNpbmdsZXRvbiA9IF9yZWYuc2luZ2xldG9uO1xuXG4gIHJldHVybiB7XG4gICAgaWQ6IGlkKCksXG4gICAgY29uc3RydWN0b3I6IGNvbnN0cnVjdG9yLFxuICAgIGRlcGVuZGVuY2llczogZGVwZW5kZW5jaWVzLFxuICAgIHNpbmdsZXRvbjogc2luZ2xldG9uXG4gIH07XG59XG4vKiogQGludGVybmFsICovXG5cbnZhciBpZCA9IGZ1bmN0aW9uIGlkKCkge1xuICByZXR1cm4gU3ltYm9sKCk7XG59O1xuLyoqXHJcbiAqIEluaXRpYWxpemVzIGEgW1tTeXN0ZW1TcGVjXV0gYnkgcmVjdXJzaXZlbHkgaW5pdGlhbGl6aW5nIGl0cyBkZXBlbmRlbmNpZXMuXHJcbiAqXHJcbiAqIGBgYHRzXHJcbiAqIC8vIGEgc2ltcGxlIHN5c3RlbSB3aXRoIHR3byBzdHJlYW1zXHJcbiAqIGNvbnN0IHN5czEgPSBzeXN0ZW0oKCkgPT4ge1xyXG4gKiAgY29uc3QgYSA9IHN0cmVhbTxudW1iZXI+KClcclxuICogIGNvbnN0IGIgPSBzdHJlYW08bnVtYmVyPigpXHJcbiAqXHJcbiAqICBjb25uZWN0KHBpcGUoYSwgbWFwKHZhbHVlID0+IHZhbHVlICogMikpLCBiKVxyXG4gKiAgcmV0dXJuIHsgYSwgYiB9XHJcbiAqIH0pXHJcbiAqXHJcbiAqIGNvbnN0IHsgYSwgYiB9ID0gaW5pdChzeXMxKVxyXG4gKiBzdWJzY3JpYmUoYiwgYiA9PiBjb25zb2xlLmxvZyhiKSlcclxuICogcHVibGlzaChhLCAyKVxyXG4gKiBgYGBcclxuICpcclxuICogQHJldHVybnMgdGhlIFtbU3lzdGVtXV0gY29uc3RydWN0ZWQgYnkgdGhlIHNwZWMgY29uc3RydWN0b3IuXHJcbiAqIEBwYXJhbSBzeXN0ZW1TcGVjIHRoZSBzeXN0ZW0gc3BlYyB0byBpbml0aWFsaXplLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBpbml0KHN5c3RlbVNwZWMpIHtcbiAgdmFyIHNpbmdsZXRvbnMgPSBuZXcgTWFwKCk7XG5cbiAgdmFyIF9pbml0ID0gZnVuY3Rpb24gX2luaXQoX3JlZjIpIHtcbiAgICB2YXIgaWQgPSBfcmVmMi5pZCxcbiAgICAgICAgY29uc3RydWN0b3IgPSBfcmVmMi5jb25zdHJ1Y3RvcixcbiAgICAgICAgZGVwZW5kZW5jaWVzID0gX3JlZjIuZGVwZW5kZW5jaWVzLFxuICAgICAgICBzaW5nbGV0b24gPSBfcmVmMi5zaW5nbGV0b247XG5cbiAgICBpZiAoc2luZ2xldG9uICYmIHNpbmdsZXRvbnMuaGFzKGlkKSkge1xuICAgICAgcmV0dXJuIHNpbmdsZXRvbnMuZ2V0KGlkKTtcbiAgICB9XG5cbiAgICB2YXIgc3lzdGVtID0gY29uc3RydWN0b3IoZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIF9pbml0KGUpO1xuICAgIH0pKTtcblxuICAgIGlmIChzaW5nbGV0b24pIHtcbiAgICAgIHNpbmdsZXRvbnMuc2V0KGlkLCBzeXN0ZW0pO1xuICAgIH1cblxuICAgIHJldHVybiBzeXN0ZW07XG4gIH07XG5cbiAgcmV0dXJuIF9pbml0KHN5c3RlbVNwZWMpO1xufVxuXG5leHBvcnQgeyBhbHdheXMsIGNhbGwsIGNvbWJpbmVMYXRlc3QsIGNvbXBvc2UsIGNvbm5lY3QsIGN1cnJ5MXRvMCwgY3VycnkydG8xLCBkZWJvdW5jZVRpbWUsIGRlZmF1bHRDb21wYXJhdG9yLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgZHVjLCBldmVudEhhbmRsZXIsIGZpbHRlciwgZ2V0VmFsdWUsIGhhbmRsZU5leHQsIGluaXQsIGpvaW5Qcm9jLCBtYXAsIG1hcFRvLCBtZXJnZSwgbm9vcCwgcGlwZSwgcHJvcCwgcHVibGlzaCwgcmVzZXQsIHNjYW4sIHNraXAsIHN0YXRlZnVsU3RyZWFtLCBzdGF0ZWZ1bFN0cmVhbUZyb21FbWl0dGVyLCBzdHJlYW0sIHN0cmVhbUZyb21FbWl0dGVyLCBzdWJzY3JpYmUsIHN5c3RlbSwgdGFwLCB0aHJvdHRsZVRpbWUsIHRocnVzaCwgdHVwLCB3aXRoTGF0ZXN0RnJvbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJ4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJQVUJMSVNIIiwiU1VCU0NSSUJFIiwiUkVTRVQiLCJWQUxVRSIsImNvbXBvc2UiLCJhIiwiYiIsImFyZyIsInRocnVzaCIsInByb2MiLCJjdXJyeTJ0bzEiLCJhcmcxIiwiYXJnMiIsImN1cnJ5MXRvMCIsInByb3AiLCJwcm9wZXJ0eSIsIm9iamVjdCIsInRhcCIsInR1cCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiY2FsbCIsImFsd2F5cyIsInZhbHVlIiwiam9pblByb2MiLCJfbGVuMiIsInByb2NzIiwiX2tleTIiLCJtYXAiLCJub29wIiwic3Vic2NyaWJlIiwiZW1pdHRlciIsInN1YnNjcmlwdGlvbiIsInB1Ymxpc2giLCJwdWJsaXNoZXIiLCJyZXNldCIsImdldFZhbHVlIiwiZGVwb3QiLCJjb25uZWN0IiwiaGFuZGxlTmV4dCIsInVuc3ViIiwic3RyZWFtIiwic3Vic2NyaXB0aW9ucyIsImFjdGlvbiIsInNwbGljZSIsInB1c2giLCJpbmRleE9mIiwic2xpY2UiLCJmb3JFYWNoIiwiRXJyb3IiLCJzdGF0ZWZ1bFN0cmVhbSIsImluaXRpYWwiLCJpbm5lclN1YmplY3QiLCJldmVudEhhbmRsZXIiLCJjdXJyZW50U3Vic2NyaXB0aW9uIiwiY2xlYW51cCIsInN0cmVhbUZyb21FbWl0dGVyIiwic3RhdGVmdWxTdHJlYW1Gcm9tRW1pdHRlciIsImNvbWJpbmVPcGVyYXRvcnMiLCJvcGVyYXRvcnMiLCJzdWJzY3JpYmVyIiwicmVkdWNlUmlnaHQiLCJwaXBlIiwic291cmNlIiwicHJvamVjdCIsImFwcGx5IiwiZGVmYXVsdENvbXBhcmF0b3IiLCJwcmV2aW91cyIsIm5leHQiLCJkaXN0aW5jdFVudGlsQ2hhbmdlZCIsImNvbXBhcmF0b3IiLCJjdXJyZW50IiwiZG9uZSIsImZpbHRlciIsInByZWRpY2F0ZSIsIm1hcFRvIiwic2NhbiIsInNjYW5uZXIiLCJza2lwIiwidGltZXMiLCJ0aHJvdHRsZVRpbWUiLCJpbnRlcnZhbCIsImN1cnJlbnRWYWx1ZSIsInRpbWVvdXQiLCJzZXRUaW1lb3V0IiwidW5kZWZpbmVkIiwiZGVib3VuY2VUaW1lIiwiY2xlYXJUaW1lb3V0Iiwid2l0aExhdGVzdEZyb20iLCJfbGVuMyIsInNvdXJjZXMiLCJfa2V5MyIsInZhbHVlcyIsImNhbGxlZCIsInBlbmRpbmdDYWxsIiwiYWxsQ2FsbGVkIiwiTWF0aCIsInBvdyIsImluZGV4IiwiYml0IiwicHJldkNhbGxlZCIsImNvbmNhdCIsIm1lcmdlIiwiZHVjIiwiY29tYmluZUxhdGVzdCIsImVtaXR0ZXJzIiwic3lzdGVtIiwiY29uc3RydWN0b3IiLCJkZXBlbmRlbmNpZXMiLCJfdGVtcCIsIl9yZWYiLCJzaW5nbGV0b24iLCJpZCIsIlN5bWJvbCIsImluaXQiLCJzeXN0ZW1TcGVjIiwic2luZ2xldG9ucyIsIk1hcCIsIl9pbml0IiwiX3JlZjIiLCJoYXMiLCJnZXQiLCJlIiwic2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@virtuoso.dev/urx/dist/urx.esm.js\n");

/***/ })

};
;