"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/hast-util-find-and-replace";
exports.ids = ["vendor-chunks/hast-util-find-and-replace"];
exports.modules = {

/***/ "(ssr)/./node_modules/hast-util-find-and-replace/lib/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/hast-util-find-and-replace/lib/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultIgnore: () => (/* binding */ defaultIgnore),\n/* harmony export */   findAndReplace: () => (/* binding */ findAndReplace)\n/* harmony export */ });\n/* harmony import */ var unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! unist-util-visit-parents */ \"(ssr)/./node_modules/unist-util-visit-parents/lib/index.js\");\n/* harmony import */ var hast_util_is_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hast-util-is-element */ \"(ssr)/./node_modules/hast-util-is-element/lib/index.js\");\n/* harmony import */ var escape_string_regexp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! escape-string-regexp */ \"(ssr)/./node_modules/hast-util-find-and-replace/node_modules/escape-string-regexp/index.js\");\n/**\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Parents} Parents\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast-util-is-element').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */ /**\n * @typedef {RegExp | string} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n *\n * @typedef {[Find, Replace?]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n *\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[...Array<Parents>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @typedef {ReplaceFunction | string | null | undefined} Replace\n *   Thing to replace with.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`) — whole match\n *   * `...capture` (`Array<string>`) — matches from regex capture groups\n *   * `match` (`RegExpMatchObject`) — info on the match\n * @returns {Array<RootContent> | RootContent | string | false | null | undefined}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * …or when `false`, do not replace at all\n *   * …or when `string`, replace with a text node of that value\n *   * …or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which elements to ignore (optional).\n */ \n\n\n/** @type {Options} */ const emptyOptions = {};\n/**\n * Default tag names to ignore.\n *\n * The defaults are `math`, `script`, `style`, `svg`, and `title`.\n *\n * @type {Array<string>}\n */ const defaultIgnore = [\n    \"math\",\n    \"script\",\n    \"style\",\n    \"svg\",\n    \"title\"\n];\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param {Nodes} tree\n *   Tree to change.\n * @param {FindAndReplaceList | FindAndReplaceTuple} list\n *   One or more find-and-replace pairs.\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (when `find` is not `Find`).\n * @returns {undefined}\n *   Nothing.\n */ function findAndReplace(tree, list, options) {\n    const settings = options || emptyOptions;\n    const ignored = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_1__.convertElement)(settings.ignore || defaultIgnore);\n    const pairs = toPairs(list);\n    let pairIndex = -1;\n    while(++pairIndex < pairs.length){\n        (0,unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_2__.visitParents)(tree, \"text\", visitor);\n    }\n    /** @type {import('unist-util-visit-parents').BuildVisitor<Root, 'text'>} */ function visitor(node, parents) {\n        let index = -1;\n        /** @type {Parents | undefined} */ let grandparent;\n        while(++index < parents.length){\n            const parent = parents[index];\n            /** @type {Array<Nodes> | undefined} */ const siblings = grandparent ? grandparent.children : undefined;\n            if (ignored(parent, siblings ? siblings.indexOf(parent) : undefined, grandparent)) {\n                return;\n            }\n            grandparent = parent;\n        }\n        if (grandparent) {\n            return handler(node, parents);\n        }\n    }\n    /**\n   * Handle a text node which is not in an ignored parent.\n   *\n   * @param {Text} node\n   *   Text node.\n   * @param {Array<Parents>} parents\n   *   Parents.\n   * @returns {VisitorResult}\n   *   Result.\n   */ function handler(node, parents) {\n        const parent = parents[parents.length - 1];\n        const find = pairs[pairIndex][0];\n        const replace = pairs[pairIndex][1];\n        let start = 0;\n        /** @type {Array<Nodes>} */ const siblings = parent.children;\n        const index = siblings.indexOf(node);\n        let change = false;\n        /** @type {Array<RootContent>} */ let nodes = [];\n        find.lastIndex = 0;\n        let match = find.exec(node.value);\n        while(match){\n            const position = match.index;\n            /** @type {RegExpMatchObject} */ const matchObject = {\n                index: match.index,\n                input: match.input,\n                stack: [\n                    ...parents,\n                    node\n                ]\n            };\n            let value = replace(...match, matchObject);\n            if (typeof value === \"string\") {\n                value = value.length > 0 ? {\n                    type: \"text\",\n                    value\n                } : undefined;\n            }\n            // It wasn’t a match after all.\n            if (value === false) {\n                // False acts as if there was no match.\n                // So we need to reset `lastIndex`, which currently being at the end of\n                // the current match, to the beginning.\n                find.lastIndex = position + 1;\n            } else {\n                if (start !== position) {\n                    nodes.push({\n                        type: \"text\",\n                        value: node.value.slice(start, position)\n                    });\n                }\n                if (Array.isArray(value)) {\n                    nodes.push(...value);\n                } else if (value) {\n                    nodes.push(value);\n                }\n                start = position + match[0].length;\n                change = true;\n            }\n            if (!find.global) {\n                break;\n            }\n            match = find.exec(node.value);\n        }\n        if (change) {\n            if (start < node.value.length) {\n                nodes.push({\n                    type: \"text\",\n                    value: node.value.slice(start)\n                });\n            }\n            parent.children.splice(index, 1, ...nodes);\n        } else {\n            nodes = [\n                node\n            ];\n        }\n        return index + nodes.length;\n    }\n}\n/**\n * Turn a tuple or a list of tuples into pairs.\n *\n * @param {FindAndReplaceList | FindAndReplaceTuple} tupleOrList\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */ function toPairs(tupleOrList) {\n    /** @type {Pairs} */ const result = [];\n    if (!Array.isArray(tupleOrList)) {\n        throw new TypeError(\"Expected find and replace tuple or list of tuples\");\n    }\n    /** @type {FindAndReplaceList} */ // @ts-expect-error: correct.\n    const list = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [\n        tupleOrList\n    ];\n    let index = -1;\n    while(++index < list.length){\n        const tuple = list[index];\n        result.push([\n            toExpression(tuple[0]),\n            toFunction(tuple[1])\n        ]);\n    }\n    return result;\n}\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */ function toExpression(find) {\n    return typeof find === \"string\" ? new RegExp((0,escape_string_regexp__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(find), \"g\") : find;\n}\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */ function toFunction(replace) {\n    return typeof replace === \"function\" ? replace : function() {\n        return replace;\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGFzdC11dGlsLWZpbmQtYW5kLXJlcGxhY2UvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0NBUUMsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWlEQyxHQUVvRDtBQUNGO0FBQ1Y7QUFFekMsb0JBQW9CLEdBQ3BCLE1BQU1HLGVBQWUsQ0FBQztBQUV0Qjs7Ozs7O0NBTUMsR0FDTSxNQUFNQyxnQkFBZ0I7SUFBQztJQUFRO0lBQVU7SUFBUztJQUFPO0NBQVE7QUFFeEU7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ00sU0FBU0MsZUFBZUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLE9BQU87SUFDaEQsTUFBTUMsV0FBV0QsV0FBV0w7SUFDNUIsTUFBTU8sVUFBVVQsb0VBQWNBLENBQUNRLFNBQVNFLE1BQU0sSUFBSVA7SUFDbEQsTUFBTVEsUUFBUUMsUUFBUU47SUFDdEIsSUFBSU8sWUFBWSxDQUFDO0lBRWpCLE1BQU8sRUFBRUEsWUFBWUYsTUFBTUcsTUFBTSxDQUFFO1FBQ2pDZixzRUFBWUEsQ0FBQ00sTUFBTSxRQUFRVTtJQUM3QjtJQUVBLDBFQUEwRSxHQUMxRSxTQUFTQSxRQUFRQyxJQUFJLEVBQUVDLE9BQU87UUFDNUIsSUFBSUMsUUFBUSxDQUFDO1FBQ2IsZ0NBQWdDLEdBQ2hDLElBQUlDO1FBRUosTUFBTyxFQUFFRCxRQUFRRCxRQUFRSCxNQUFNLENBQUU7WUFDL0IsTUFBTU0sU0FBU0gsT0FBTyxDQUFDQyxNQUFNO1lBQzdCLHFDQUFxQyxHQUNyQyxNQUFNRyxXQUFXRixjQUFjQSxZQUFZRyxRQUFRLEdBQUdDO1lBRXRELElBQ0VkLFFBQ0VXLFFBQ0FDLFdBQVdBLFNBQVNHLE9BQU8sQ0FBQ0osVUFBVUcsV0FDdENKLGNBRUY7Z0JBQ0E7WUFDRjtZQUVBQSxjQUFjQztRQUNoQjtRQUVBLElBQUlELGFBQWE7WUFDZixPQUFPTSxRQUFR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O0lBRWIsTUFBTyxFQUFFQSxRQUFRWixLQUFLUSxNQUFNLENBQUU7UUFDNUIsTUFBTW1DLFFBQVEzQyxJQUFJLENBQUNZLE1BQU07UUFDekI2QixPQUFPUCxJQUFJLENBQUM7WUFBQ1UsYUFBYUQsS0FBSyxDQUFDLEVBQUU7WUFBR0UsV0FBV0YsS0FBSyxDQUFDLEVBQUU7U0FBRTtJQUM1RDtJQUVBLE9BQU9GO0FBQ1Q7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU0csYUFBYXhCLElBQUk7SUFDeEIsT0FBTyxPQUFPQSxTQUFTLFdBQVcsSUFBSTBCLE9BQU9uRCxnRUFBTUEsQ0FBQ3lCLE9BQU8sT0FBT0E7QUFDcEU7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU3lCLFdBQVd4QixPQUFPO0lBQ3pCLE9BQU8sT0FBT0EsWUFBWSxhQUN0QkEsVUFDQTtRQUNFLE9BQU9BO0lBQ1Q7QUFDTiIsInNvdXJjZXMiOlsid2VicGFjazovL3RpY3RhY3RvZS8uL25vZGVfbW9kdWxlcy9oYXN0LXV0aWwtZmluZC1hbmQtcmVwbGFjZS9saWIvaW5kZXguanM/ZTM3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QnKS5Ob2Rlc30gTm9kZXNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QnKS5QYXJlbnRzfSBQYXJlbnRzXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdoYXN0JykuUm9vdH0gUm9vdFxuICogQHR5cGVkZWYge2ltcG9ydCgnaGFzdCcpLlJvb3RDb250ZW50fSBSb290Q29udGVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnaGFzdCcpLlRleHR9IFRleHRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QtdXRpbC1pcy1lbGVtZW50JykuVGVzdH0gVGVzdFxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QtdXRpbC12aXNpdC1wYXJlbnRzJykuVmlzaXRvclJlc3VsdH0gVmlzaXRvclJlc3VsdFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1JlZ0V4cCB8IHN0cmluZ30gRmluZFxuICogICBQYXR0ZXJuIHRvIGZpbmQuXG4gKlxuICogICBTdHJpbmdzIGFyZSBlc2NhcGVkIGFuZCB0aGVuIHR1cm5lZCBpbnRvIGdsb2JhbCBleHByZXNzaW9ucy5cbiAqXG4gKiBAdHlwZWRlZiB7QXJyYXk8RmluZEFuZFJlcGxhY2VUdXBsZT59IEZpbmRBbmRSZXBsYWNlTGlzdFxuICogICBTZXZlcmFsIGZpbmQgYW5kIHJlcGxhY2VzLCBpbiBhcnJheSBmb3JtLlxuICpcbiAqIEB0eXBlZGVmIHtbRmluZCwgUmVwbGFjZT9dfSBGaW5kQW5kUmVwbGFjZVR1cGxlXG4gKiAgIEZpbmQgYW5kIHJlcGxhY2UgaW4gdHVwbGUgZm9ybS5cbiAqXG4gKiBAdHlwZWRlZiBSZWdFeHBNYXRjaE9iamVjdFxuICogICBJbmZvIG9uIHRoZSBtYXRjaC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbmRleFxuICogICBUaGUgaW5kZXggb2YgdGhlIHNlYXJjaCBhdCB3aGljaCB0aGUgcmVzdWx0IHdhcyBmb3VuZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpbnB1dFxuICogICBBIGNvcHkgb2YgdGhlIHNlYXJjaCBzdHJpbmcgaW4gdGhlIHRleHQgbm9kZS5cbiAqIEBwcm9wZXJ0eSB7Wy4uLkFycmF5PFBhcmVudHM+LCBUZXh0XX0gc3RhY2tcbiAqICAgQWxsIGFuY2VzdG9ycyBvZiB0aGUgdGV4dCBub2RlLCB3aGVyZSB0aGUgbGFzdCBub2RlIGlzIHRoZSB0ZXh0IGl0c2VsZi5cbiAqXG4gKiBAdHlwZWRlZiB7UmVwbGFjZUZ1bmN0aW9uIHwgc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gUmVwbGFjZVxuICogICBUaGluZyB0byByZXBsYWNlIHdpdGguXG4gKlxuICogQGNhbGxiYWNrIFJlcGxhY2VGdW5jdGlvblxuICogICBDYWxsYmFjayBjYWxsZWQgd2hlbiBhIHNlYXJjaCBtYXRjaGVzLlxuICogQHBhcmFtIHsuLi5hbnl9IHBhcmFtZXRlcnNcbiAqICAgVGhlIHBhcmFtZXRlcnMgYXJlIHRoZSByZXN1bHQgb2YgY29ycmVzcG9uZGluZyBzZWFyY2ggZXhwcmVzc2lvbjpcbiAqXG4gKiAgICogYHZhbHVlYCAoYHN0cmluZ2ApIOKAlCB3aG9sZSBtYXRjaFxuICogICAqIGAuLi5jYXB0dXJlYCAoYEFycmF5PHN0cmluZz5gKSDigJQgbWF0Y2hlcyBmcm9tIHJlZ2V4IGNhcHR1cmUgZ3JvdXBzXG4gKiAgICogYG1hdGNoYCAoYFJlZ0V4cE1hdGNoT2JqZWN0YCkg4oCUIGluZm8gb24gdGhlIG1hdGNoXG4gKiBAcmV0dXJucyB7QXJyYXk8Um9vdENvbnRlbnQ+IHwgUm9vdENvbnRlbnQgfCBzdHJpbmcgfCBmYWxzZSB8IG51bGwgfCB1bmRlZmluZWR9XG4gKiAgIFRoaW5nIHRvIHJlcGxhY2Ugd2l0aC5cbiAqXG4gKiAgICogd2hlbiBgbnVsbGAsIGB1bmRlZmluZWRgLCBgJydgLCByZW1vdmUgdGhlIG1hdGNoXG4gKiAgICog4oCmb3Igd2hlbiBgZmFsc2VgLCBkbyBub3QgcmVwbGFjZSBhdCBhbGxcbiAqICAgKiDigKZvciB3aGVuIGBzdHJpbmdgLCByZXBsYWNlIHdpdGggYSB0ZXh0IG5vZGUgb2YgdGhhdCB2YWx1ZVxuICogICAqIOKApm9yIHdoZW4gYE5vZGVgIG9yIGBBcnJheTxOb2RlPmAsIHJlcGxhY2Ugd2l0aCB0aG9zZSBub2Rlc1xuICpcbiAqIEB0eXBlZGVmIHtbUmVnRXhwLCBSZXBsYWNlRnVuY3Rpb25dfSBQYWlyXG4gKiAgIE5vcm1hbGl6ZWQgZmluZCBhbmQgcmVwbGFjZS5cbiAqIEB0eXBlZGVmIHtBcnJheTxQYWlyPn0gUGFpcnNcbiAqICAgQWxsIGZpbmQgYW5kIHJlcGxhY2VkLlxuICpcbiAqIEB0eXBlZGVmIE9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7VGVzdCB8IG51bGwgfCB1bmRlZmluZWR9IFtpZ25vcmVdXG4gKiAgIFRlc3QgZm9yIHdoaWNoIGVsZW1lbnRzIHRvIGlnbm9yZSAob3B0aW9uYWwpLlxuICovXG5cbmltcG9ydCB7dmlzaXRQYXJlbnRzfSBmcm9tICd1bmlzdC11dGlsLXZpc2l0LXBhcmVudHMnXG5pbXBvcnQge2NvbnZlcnRFbGVtZW50fSBmcm9tICdoYXN0LXV0aWwtaXMtZWxlbWVudCdcbmltcG9ydCBlc2NhcGUgZnJvbSAnZXNjYXBlLXN0cmluZy1yZWdleHAnXG5cbi8qKiBAdHlwZSB7T3B0aW9uc30gKi9cbmNvbnN0IGVtcHR5T3B0aW9ucyA9IHt9XG5cbi8qKlxuICogRGVmYXVsdCB0YWcgbmFtZXMgdG8gaWdub3JlLlxuICpcbiAqIFRoZSBkZWZhdWx0cyBhcmUgYG1hdGhgLCBgc2NyaXB0YCwgYHN0eWxlYCwgYHN2Z2AsIGFuZCBgdGl0bGVgLlxuICpcbiAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdElnbm9yZSA9IFsnbWF0aCcsICdzY3JpcHQnLCAnc3R5bGUnLCAnc3ZnJywgJ3RpdGxlJ11cblxuLyoqXG4gKiBGaW5kIHBhdHRlcm5zIGluIGEgdHJlZSBhbmQgcmVwbGFjZSB0aGVtLlxuICpcbiAqIFRoZSBhbGdvcml0aG0gc2VhcmNoZXMgdGhlIHRyZWUgaW4gKnByZW9yZGVyKiBmb3IgY29tcGxldGUgdmFsdWVzIGluIGBUZXh0YFxuICogbm9kZXMuXG4gKiBQYXJ0aWFsIG1hdGNoZXMgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gKlxuICogQHBhcmFtIHtOb2Rlc30gdHJlZVxuICogICBUcmVlIHRvIGNoYW5nZS5cbiAqIEBwYXJhbSB7RmluZEFuZFJlcGxhY2VMaXN0IHwgRmluZEFuZFJlcGxhY2VUdXBsZX0gbGlzdFxuICogICBPbmUgb3IgbW9yZSBmaW5kLWFuZC1yZXBsYWNlIHBhaXJzLlxuICogQHBhcmFtIHtSZWFkb25seTxPcHRpb25zPiB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRpb25zXVxuICogICBDb25maWd1cmF0aW9uICh3aGVuIGBmaW5kYCBpcyBub3QgYEZpbmRgKS5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQW5kUmVwbGFjZSh0cmVlLCBsaXN0LCBvcHRpb25zKSB7XG4gIGNvbnN0IHNldHRpbmdzID0gb3B0aW9ucyB8fCBlbXB0eU9wdGlvbnNcbiAgY29uc3QgaWdub3JlZCA9IGNvbnZlcnRFbGVtZW50KHNldHRpbmdzLmlnbm9yZSB8fCBkZWZhdWx0SWdub3JlKVxuICBjb25zdCBwYWlycyA9IHRvUGFpcnMobGlzdClcbiAgbGV0IHBhaXJJbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsrcGFpckluZGV4IDwgcGFpcnMubGVuZ3RoKSB7XG4gICAgdmlzaXRQYXJlbnRzKHRyZWUsICd0ZXh0JywgdmlzaXRvcilcbiAgfVxuXG4gIC8qKiBAdHlwZSB7aW1wb3J0KCd1bmlzdC11dGlsLXZpc2l0LXBhcmVudHMnKS5CdWlsZFZpc2l0b3I8Um9vdCwgJ3RleHQnPn0gKi9cbiAgZnVuY3Rpb24gdmlzaXRvcihub2RlLCBwYXJlbnRzKSB7XG4gICAgbGV0IGluZGV4ID0gLTFcbiAgICAvKiogQHR5cGUge1BhcmVudHMgfCB1bmRlZmluZWR9ICovXG4gICAgbGV0IGdyYW5kcGFyZW50XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IHBhcmVudHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBwYXJlbnRzW2luZGV4XVxuICAgICAgLyoqIEB0eXBlIHtBcnJheTxOb2Rlcz4gfCB1bmRlZmluZWR9ICovXG4gICAgICBjb25zdCBzaWJsaW5ncyA9IGdyYW5kcGFyZW50ID8gZ3JhbmRwYXJlbnQuY2hpbGRyZW4gOiB1bmRlZmluZWRcblxuICAgICAgaWYgKFxuICAgICAgICBpZ25vcmVkKFxuICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICBzaWJsaW5ncyA/IHNpYmxpbmdzLmluZGV4T2YocGFyZW50KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBncmFuZHBhcmVudFxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGdyYW5kcGFyZW50ID0gcGFyZW50XG4gICAgfVxuXG4gICAgaWYgKGdyYW5kcGFyZW50KSB7XG4gICAgICByZXR1cm4gaGFuZGxlcihub2RlLCBwYXJlbnRzKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSB0ZXh0IG5vZGUgd2hpY2ggaXMgbm90IGluIGFuIGlnbm9yZWQgcGFyZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHR9IG5vZGVcbiAgICogICBUZXh0IG5vZGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8UGFyZW50cz59IHBhcmVudHNcbiAgICogICBQYXJlbnRzLlxuICAgKiBAcmV0dXJucyB7VmlzaXRvclJlc3VsdH1cbiAgICogICBSZXN1bHQuXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVyKG5vZGUsIHBhcmVudHMpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBwYXJlbnRzW3BhcmVudHMubGVuZ3RoIC0gMV1cbiAgICBjb25zdCBmaW5kID0gcGFpcnNbcGFpckluZGV4XVswXVxuICAgIGNvbnN0IHJlcGxhY2UgPSBwYWlyc1twYWlySW5kZXhdWzFdXG4gICAgbGV0IHN0YXJ0ID0gMFxuICAgIC8qKiBAdHlwZSB7QXJyYXk8Tm9kZXM+fSAqL1xuICAgIGNvbnN0IHNpYmxpbmdzID0gcGFyZW50LmNoaWxkcmVuXG4gICAgY29uc3QgaW5kZXggPSBzaWJsaW5ncy5pbmRleE9mKG5vZGUpXG4gICAgbGV0IGNoYW5nZSA9IGZhbHNlXG4gICAgLyoqIEB0eXBlIHtBcnJheTxSb290Q29udGVudD59ICovXG4gICAgbGV0IG5vZGVzID0gW11cblxuICAgIGZpbmQubGFzdEluZGV4ID0gMFxuXG4gICAgbGV0IG1hdGNoID0gZmluZC5leGVjKG5vZGUudmFsdWUpXG5cbiAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gbWF0Y2guaW5kZXhcbiAgICAgIC8qKiBAdHlwZSB7UmVnRXhwTWF0Y2hPYmplY3R9ICovXG4gICAgICBjb25zdCBtYXRjaE9iamVjdCA9IHtcbiAgICAgICAgaW5kZXg6IG1hdGNoLmluZGV4LFxuICAgICAgICBpbnB1dDogbWF0Y2guaW5wdXQsXG4gICAgICAgIHN0YWNrOiBbLi4ucGFyZW50cywgbm9kZV1cbiAgICAgIH1cbiAgICAgIGxldCB2YWx1ZSA9IHJlcGxhY2UoLi4ubWF0Y2gsIG1hdGNoT2JqZWN0KVxuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLmxlbmd0aCA+IDAgPyB7dHlwZTogJ3RleHQnLCB2YWx1ZX0gOiB1bmRlZmluZWRcbiAgICAgIH1cblxuICAgICAgLy8gSXQgd2FzbuKAmXQgYSBtYXRjaCBhZnRlciBhbGwuXG4gICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIEZhbHNlIGFjdHMgYXMgaWYgdGhlcmUgd2FzIG5vIG1hdGNoLlxuICAgICAgICAvLyBTbyB3ZSBuZWVkIHRvIHJlc2V0IGBsYXN0SW5kZXhgLCB3aGljaCBjdXJyZW50bHkgYmVpbmcgYXQgdGhlIGVuZCBvZlxuICAgICAgICAvLyB0aGUgY3VycmVudCBtYXRjaCwgdG8gdGhlIGJlZ2lubmluZy5cbiAgICAgICAgZmluZC5sYXN0SW5kZXggPSBwb3NpdGlvbiArIDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdGFydCAhPT0gcG9zaXRpb24pIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKHt0eXBlOiAndGV4dCcsIHZhbHVlOiBub2RlLnZhbHVlLnNsaWNlKHN0YXJ0LCBwb3NpdGlvbil9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgbm9kZXMucHVzaCguLi52YWx1ZSlcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgIG5vZGVzLnB1c2godmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IHBvc2l0aW9uICsgbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgIGNoYW5nZSA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKCFmaW5kLmdsb2JhbCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IGZpbmQuZXhlYyhub2RlLnZhbHVlKVxuICAgIH1cblxuICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgIGlmIChzdGFydCA8IG5vZGUudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIG5vZGVzLnB1c2goe3R5cGU6ICd0ZXh0JywgdmFsdWU6IG5vZGUudmFsdWUuc2xpY2Uoc3RhcnQpfSlcbiAgICAgIH1cblxuICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSwgLi4ubm9kZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVzID0gW25vZGVdXG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4ICsgbm9kZXMubGVuZ3RoXG4gIH1cbn1cblxuLyoqXG4gKiBUdXJuIGEgdHVwbGUgb3IgYSBsaXN0IG9mIHR1cGxlcyBpbnRvIHBhaXJzLlxuICpcbiAqIEBwYXJhbSB7RmluZEFuZFJlcGxhY2VMaXN0IHwgRmluZEFuZFJlcGxhY2VUdXBsZX0gdHVwbGVPckxpc3RcbiAqICAgU2NoZW1hLlxuICogQHJldHVybnMge1BhaXJzfVxuICogICBDbGVhbiBwYWlycy5cbiAqL1xuZnVuY3Rpb24gdG9QYWlycyh0dXBsZU9yTGlzdCkge1xuICAvKiogQHR5cGUge1BhaXJzfSAqL1xuICBjb25zdCByZXN1bHQgPSBbXVxuXG4gIGlmICghQXJyYXkuaXNBcnJheSh0dXBsZU9yTGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBmaW5kIGFuZCByZXBsYWNlIHR1cGxlIG9yIGxpc3Qgb2YgdHVwbGVzJylcbiAgfVxuXG4gIC8qKiBAdHlwZSB7RmluZEFuZFJlcGxhY2VMaXN0fSAqL1xuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBjb3JyZWN0LlxuICBjb25zdCBsaXN0ID1cbiAgICAhdHVwbGVPckxpc3RbMF0gfHwgQXJyYXkuaXNBcnJheSh0dXBsZU9yTGlzdFswXSlcbiAgICAgID8gdHVwbGVPckxpc3RcbiAgICAgIDogW3R1cGxlT3JMaXN0XVxuXG4gIGxldCBpbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsraW5kZXggPCBsaXN0Lmxlbmd0aCkge1xuICAgIGNvbnN0IHR1cGxlID0gbGlzdFtpbmRleF1cbiAgICByZXN1bHQucHVzaChbdG9FeHByZXNzaW9uKHR1cGxlWzBdKSwgdG9GdW5jdGlvbih0dXBsZVsxXSldKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIFR1cm4gYSBmaW5kIGludG8gYW4gZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0ge0ZpbmR9IGZpbmRcbiAqICAgRmluZC5cbiAqIEByZXR1cm5zIHtSZWdFeHB9XG4gKiAgIEV4cHJlc3Npb24uXG4gKi9cbmZ1bmN0aW9uIHRvRXhwcmVzc2lvbihmaW5kKSB7XG4gIHJldHVybiB0eXBlb2YgZmluZCA9PT0gJ3N0cmluZycgPyBuZXcgUmVnRXhwKGVzY2FwZShmaW5kKSwgJ2cnKSA6IGZpbmRcbn1cblxuLyoqXG4gKiBUdXJuIGEgcmVwbGFjZSBpbnRvIGEgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtSZXBsYWNlfSByZXBsYWNlXG4gKiAgIFJlcGxhY2UuXG4gKiBAcmV0dXJucyB7UmVwbGFjZUZ1bmN0aW9ufVxuICogICBGdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9GdW5jdGlvbihyZXBsYWNlKSB7XG4gIHJldHVybiB0eXBlb2YgcmVwbGFjZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gcmVwbGFjZVxuICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVwbGFjZVxuICAgICAgfVxufVxuIl0sIm5hbWVzIjpbInZpc2l0UGFyZW50cyIsImNvbnZlcnRFbGVtZW50IiwiZXNjYXBlIiwiZW1wdHlPcHRpb25zIiwiZGVmYXVsdElnbm9yZSIsImZpbmRBbmRSZXBsYWNlIiwidHJlZSIsImxpc3QiLCJvcHRpb25zIiwic2V0dGluZ3MiLCJpZ25vcmVkIiwiaWdub3JlIiwicGFpcnMiLCJ0b1BhaXJzIiwicGFpckluZGV4IiwibGVuZ3RoIiwidmlzaXRvciIsIm5vZGUiLCJwYXJlbnRzIiwiaW5kZXgiLCJncmFuZHBhcmVudCIsInBhcmVudCIsInNpYmxpbmdzIiwiY2hpbGRyZW4iLCJ1bmRlZmluZWQiLCJpbmRleE9mIiwiaGFuZGxlciIsImZpbmQiLCJyZXBsYWNlIiwic3RhcnQiLCJjaGFuZ2UiLCJub2RlcyIsImxhc3RJbmRleCIsIm1hdGNoIiwiZXhlYyIsInZhbHVlIiwicG9zaXRpb24iLCJtYXRjaE9iamVjdCIsImlucHV0Iiwic3RhY2siLCJ0eXBlIiwicHVzaCIsInNsaWNlIiwiQXJyYXkiLCJpc0FycmF5IiwiZ2xvYmFsIiwic3BsaWNlIiwidHVwbGVPckxpc3QiLCJyZXN1bHQiLCJUeXBlRXJyb3IiLCJ0dXBsZSIsInRvRXhwcmVzc2lvbiIsInRvRnVuY3Rpb24iLCJSZWdFeHAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hast-util-find-and-replace/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/hast-util-find-and-replace/node_modules/escape-string-regexp/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/hast-util-find-and-replace/node_modules/escape-string-regexp/index.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ escapeStringRegexp)\n/* harmony export */ });\nfunction escapeStringRegexp(string) {\n    if (typeof string !== \"string\") {\n        throw new TypeError(\"Expected a string\");\n    }\n    // Escape characters with special meaning either inside or outside character sets.\n    // Use a simple backslash escape when it’s always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.\n    return string.replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\").replace(/-/g, \"\\\\x2d\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGFzdC11dGlsLWZpbmQtYW5kLXJlcGxhY2Uvbm9kZV9tb2R1bGVzL2VzY2FwZS1zdHJpbmctcmVnZXhwL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZSxTQUFTQSxtQkFBbUJDLE1BQU07SUFDaEQsSUFBSSxPQUFPQSxXQUFXLFVBQVU7UUFDL0IsTUFBTSxJQUFJQyxVQUFVO0lBQ3JCO0lBRUEsa0ZBQWtGO0lBQ2xGLDZKQUE2SjtJQUM3SixPQUFPRCxPQUNMRSxPQUFPLENBQUMsdUJBQXVCLFFBQy9CQSxPQUFPLENBQUMsTUFBTTtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL3RpY3RhY3RvZS8uL25vZGVfbW9kdWxlcy9oYXN0LXV0aWwtZmluZC1hbmQtcmVwbGFjZS9ub2RlX21vZHVsZXMvZXNjYXBlLXN0cmluZy1yZWdleHAvaW5kZXguanM/Y2M0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBlc2NhcGVTdHJpbmdSZWdleHAoc3RyaW5nKSB7XG5cdGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG5cdH1cblxuXHQvLyBFc2NhcGUgY2hhcmFjdGVycyB3aXRoIHNwZWNpYWwgbWVhbmluZyBlaXRoZXIgaW5zaWRlIG9yIG91dHNpZGUgY2hhcmFjdGVyIHNldHMuXG5cdC8vIFVzZSBhIHNpbXBsZSBiYWNrc2xhc2ggZXNjYXBlIHdoZW4gaXTigJlzIGFsd2F5cyB2YWxpZCwgYW5kIGEgYFxceG5uYCBlc2NhcGUgd2hlbiB0aGUgc2ltcGxlciBmb3JtIHdvdWxkIGJlIGRpc2FsbG93ZWQgYnkgVW5pY29kZSBwYXR0ZXJuc+KAmSBzdHJpY3RlciBncmFtbWFyLlxuXHRyZXR1cm4gc3RyaW5nXG5cdFx0LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nLCAnXFxcXCQmJylcblx0XHQucmVwbGFjZSgvLS9nLCAnXFxcXHgyZCcpO1xufVxuIl0sIm5hbWVzIjpbImVzY2FwZVN0cmluZ1JlZ2V4cCIsInN0cmluZyIsIlR5cGVFcnJvciIsInJlcGxhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hast-util-find-and-replace/node_modules/escape-string-regexp/index.js\n");

/***/ })

};
;